package gl;

import gl.native.ExtensionsNative;
import lime.utils.DataPointer;
#if !macro
import cpp.Char;
import cpp.Pointer;

// #if !macro
// @:build(gl.ExtensionsNative.ExtensionsMacro.build(false))
// #end
// class Extensions {} 

// wrapper class so lime doesn't kill itself
@:publicFields
class Extensions {
    static function accum(op:Int, value:Float):Void return ExtensionsNative.accum(op, value);
    static function accumxOES(op:Int, value:Int):Void return ExtensionsNative.accumxOES(op, value);
    static function activeProgramEXT(program:Int):Void return ExtensionsNative.activeProgramEXT(program);
    /**
    * - #### Purpose:
    * set the active program object for a program pipeline object
    * ### Description:
    * **glActiveShaderProgram** sets the linked program named by **program** to be the active program for the program pipeline object **pipeline**. The active program in the active program pipeline object is the target of calls to **`glUniform`** when no program has been made current through a call to **`glUseProgram`**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **pipeline** is not a name previously returned from a call to **`glGenProgramPipelines`** or if such a name has been deleted by a call to **`glDeleteProgramPipelines`**.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** refers to a program object that has not been successfully linked.
    * 
    * @param pipeline Specifies the program pipeline object to set the active program object for.
    * @param program Specifies the program object to set as the active program pipeline object **pipeline**.

    * @see **`glGenProgramPipelines`**, **`glDeleteProgramPipelines`**, **`glIsProgramPipeline`**, **`glUseProgram`**, **`glUniform`**

    **/
    static function activeShaderProgram(pipelin_e:Int, program:Int):Void return ExtensionsNative.activeShaderProgram(pipelin_e, program);
    static function activeShaderProgramEXT(pipelin_e:Int, program:Int):Void return ExtensionsNative.activeShaderProgramEXT(pipelin_e, program);
    static function activeStencilFaceEXT(face:Int):Void return ExtensionsNative.activeStencilFaceEXT(face);
    /**
    * - #### Purpose:
    * select active texture unit
    * ### Description:
    * **glActiveTexture** selects which texture unit subsequent texture state calls will affect. The number of texture units an implementation supports is implementation dependent, but must be at least 80.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **texture** is not one of `GL_TEXTURE`i, where i ranges from zero to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` minus one.
    * 
    * @param texture Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. **texture** must be one of `GL_TEXTURE`i, where i ranges from zero to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` minus one. The initial value is `GL_TEXTURE0`.

    * @see **`glGenTextures`**, **`glBindTexture`**, **`glCompressedTexImage1D`**, **`glCompressedTexImage2D`**, **`glCompressedTexImage3D`**, **`glCompressedTexSubImage1D`**, **`glCompressedTexSubImage2D`**, **`glCompressedTexSubImage3D`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glDeleteTextures`** **`glIsTexture`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage2DMultisample`**, **`glTexImage3D`**, **`glTexImage3DMultisample`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**, **`glTexParameter`**,

    **/
    static function activeTexture(texture:Int):Void return ExtensionsNative.activeTexture(texture);
    static function activeTextureARB(texture:Int):Void return ExtensionsNative.activeTextureARB(texture);
    static function activeVaryingNV(program:Int, name:String):Void return ExtensionsNative.activeVaryingNV(program, name);
    static function alphaFragmentOp1ATI(op:Int, dst:Int, dstMod:Int, arg1:Int, arg1Rep:Int, arg1Mod:Int):Void return ExtensionsNative.alphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
    static function alphaFragmentOp2ATI(op:Int, dst:Int, dstMod:Int, arg1:Int, arg1Rep:Int, arg1Mod:Int, arg2:Int, arg2Rep:Int, arg2Mod:Int):Void return ExtensionsNative.alphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    static function alphaFragmentOp3ATI(op:Int, dst:Int, dstMod:Int, arg1:Int, arg1Rep:Int, arg1Mod:Int, arg2:Int, arg2Rep:Int, arg2Mod:Int, arg3:Int, arg3Rep:Int, arg3Mod:Int):Void return ExtensionsNative.alphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    static function alphaFunc(func:Int, ref:Float):Void return ExtensionsNative.alphaFunc(func, ref);
    static function alphaFuncQCOM(func:Int, ref:Float):Void return ExtensionsNative.alphaFuncQCOM(func, ref);
    static function alphaFuncx(func:Int, ref:Int):Void return ExtensionsNative.alphaFuncx(func, ref);
    static function alphaFuncxOES(func:Int, ref:Int):Void return ExtensionsNative.alphaFuncxOES(func, ref);
    static function alphaToCoverageDitherControlNV(mode:Int):Void return ExtensionsNative.alphaToCoverageDitherControlNV(mode);
    static function applyFramebufferAttachmentCMAAINTEL():Void return ExtensionsNative.applyFramebufferAttachmentCMAAINTEL();
    static function applyTextureEXT(mode:Int):Void return ExtensionsNative.applyTextureEXT(mode);
    static function acquireKeyedMutexWin32EXT(memory:Int, key:Int, timeout:Int):Bool return ExtensionsNative.acquireKeyedMutexWin32EXT(memory, key, timeout);
    static function areProgramsResidentNV(n:Int, programs:DataPointer, residences:DataPointer):Bool return ExtensionsNative.areProgramsResidentNV(n, programs, residences);
    static function areTexturesResident(n:Int, textures:DataPointer, residences:DataPointer):Bool return ExtensionsNative.areTexturesResident(n, textures, residences);
    static function areTexturesResidentEXT(n:Int, textures:DataPointer, residences:DataPointer):Bool return ExtensionsNative.areTexturesResidentEXT(n, textures, residences);
    static function arrayElement(i:Int):Void return ExtensionsNative.arrayElement(i);
    static function arrayElementEXT(i:Int):Void return ExtensionsNative.arrayElementEXT(i);
    static function arrayObjectATI(array:Int, size:Int, type:Int, stride:Int, buffer:Int, offset:Int):Void return ExtensionsNative.arrayObjectATI(array, size, type, stride, buffer, offset);
    static function asyncCopyBufferSubDataNVX(waitSemaphoreCount:Int, waitSemaphoreArray:DataPointer, fenceValueArray:DataPointer, readGpu:Int, writeGpuMask:Int, readBuffer:Int, writeBuffer:Int, readOffset:Int, writeOffset:Int, size:Int, signalSemaphoreCount:Int, signalSemaphoreArray:DataPointer, signalValueArray:DataPointer):Int return ExtensionsNative.asyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    static function asyncCopyImageSubDataNVX(waitSemaphoreCount:Int, waitSemaphoreArray:DataPointer, waitValueArray:DataPointer, srcGpu:Int, dstGpuMask:Int, srcName:Int, srcTarget:Int, srcLevel:Int, srcX:Int, srcY:Int, srcZ:Int, dstName:Int, dstTarget:Int, dstLevel:Int, dstX:Int, dstY:Int, dstZ:Int, srcWidth:Int, srcHeight:Int, srcDepth:Int, signalSemaphoreCount:Int, signalSemaphoreArray:DataPointer, signalValueArray:DataPointer):Int return ExtensionsNative.asyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    static function asyncMarkerSGIX(marker:Int):Void return ExtensionsNative.asyncMarkerSGIX(marker);
    static function attachObjectARB(contain_erObj:Int, obj:Int):Void return ExtensionsNative.attachObjectARB(contain_erObj, obj);
    /**
    * - #### Purpose:
    * Attaches a shader object to a program object
    * ### Description:
    * In order to create a complete shader program, there must be a way to specify the list of things that will be linked together. Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be attached to that program object. **glAttachShader** attaches the shader object specified by **shader** to the program object specified by **program**. This indicates that **shader** will be included in link operations that will be performed on **program**.
    * 
    * All operations that can be performed on a shader object are valid whether or not the shader object is attached to a program object. It is permissible to attach a shader object to a program object before source code has been loaded into the shader object or before the shader object has been compiled. It is permissible to attach multiple shader objects of the same type because each may contain a portion of the complete shader. It is also permissible to attach a shader object to more than one program object. If a shader object is deleted while it is attached to a program object, it will be flagged for deletion, and deletion will not occur until **`glDetachShader`** is called to detach it from all program objects to which it is attached.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if either **program** or **shader** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **shader** is not a shader object.
    * 
    * `GL_INVALID_OPERATION` is generated if **shader** is already attached to **program**.
    * 
    * @param program Specifies the program object to which a shader object will be attached.
    * @param shader Specifies the shader object that is to be attached.

    * @see **`glCompileShader`**, **`glCreateShader`**, **`glDeleteShader`**, **`glDetachShader`**, **`glLinkProgram`**, **`glShaderSource`**

    **/
    static function attachShader(program:Int, shader:Int):Void return ExtensionsNative.attachShader(program, shader);
    static function begin(mode:Int):Void return ExtensionsNative.begin(mode);
    /**
    * - #### Purpose:
    * start conditional rendering
    * ### Description:
    * Conditional rendering is started using **glBeginConditionalRender** and ended using **glEndConditionalRender**. During conditional rendering, all vertex array commands, as well as **`glClear`** and **`glClearBuffer`** have no effect if the (`GL_SAMPLES_PASSED`) result of the query object **id** is zero, or if the (`GL_ANY_SAMPLES_PASSED`) result is `GL_FALSE`. The results of commands setting the current vertex state, such as **`glVertexAttrib`** are undefined. If the (`GL_SAMPLES_PASSED`) result is non-zero or if the (`GL_ANY_SAMPLES_PASSED`) result is `GL_TRUE`, such commands are not discarded. The **id** parameter to **glBeginConditionalRender** must be the name of a query object previously returned from a call to **`glGenQueries`**. **mode** specifies how the results of the query object are to be interpreted. If **mode** is `GL_QUERY_WAIT`, the GL waits for the results of the query to be available and then uses the results to determine if subsequent rendering commands are discarded. If **mode** is `GL_QUERY_NO_WAIT`, the GL may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete.
    * 
    * If **mode** is `GL_QUERY_BY_REGION_WAIT`, the GL will also wait for occlusion query results and discard rendering commands if the result of the occlusion query is zero. If the query result is non-zero, subsequent rendering commands are executed, but the GL may discard the results of the commands for any region of the framebuffer that did not contribute to the sample count in the specified occlusion query. Any such discarding is done in an implementation-dependent manner, but the rendering command results may not be discarded for any samples that contributed to the occlusion query sample count. If **mode** is `GL_QUERY_BY_REGION_NO_WAIT`, the GL operates as in `GL_QUERY_BY_REGION_WAIT`, but may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete.
    * 
    * 
    * ### Notes:
    * **glBeginConditionalRender** and **glEndConditionalRender** are available only if the GL version is 3.0 or greater.
    * 
    * The `GL_ANY_SAMPLES_PASSED` query result is available only if the GL version is 3.3 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **id** is not the name of an existing query object.
    * 
    * `GL_INVALID_ENUM` is generated if **mode** is not one of the accepted tokens.
    * 
    * `GL_INVALID_OPERATION` is generated if **glBeginConditionalRender** is called while conditional rendering is active, or if **glEndConditionalRender** is called while conditional rendering is inactive.
    * 
    * `GL_INVALID_OPERATION` is generated if **id** is the name of a query object with a target other than `GL_SAMPLES_PASSED` or `GL_ANY_SAMPLES_PASSED`.
    * 
    * `GL_INVALID_OPERATION` is generated if **id** is the name of a query currently in progress.
    * 
    * @param id Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.
    * @param mode Specifies how **glBeginConditionalRender** interprets the results of the occlusion query.

    * @see **`glGenQueries`**, **`glDeleteQueries`**, **`glBeginQuery`**

    **/
    static function beginConditionalRender(id:Int, mode:Int):Void return ExtensionsNative.beginConditionalRender(id, mode);
    static function beginConditionalRenderNV(id:Int, mode:Int):Void return ExtensionsNative.beginConditionalRenderNV(id, mode);
    static function beginConditionalRenderNVX(id:Int):Void return ExtensionsNative.beginConditionalRenderNVX(id);
    static function beginFragmentShaderATI():Void return ExtensionsNative.beginFragmentShaderATI();
    static function beginOcclusionQueryNV(id:Int):Void return ExtensionsNative.beginOcclusionQueryNV(id);
    static function beginPerfMonitorAMD(monitor:Int):Void return ExtensionsNative.beginPerfMonitorAMD(monitor);
    static function beginPerfQueryINTEL(queryHandle:Int):Void return ExtensionsNative.beginPerfQueryINTEL(queryHandle);
    /**
    * - #### Purpose:
    * delimit the boundaries of a query object
    * ### Description:
    * **glBeginQuery** and **glEndQuery** delimit the boundaries of a query object. **query** must be a name previously returned from a call to **`glGenQueries`**. If a query object with name **id** does not yet exist it is created with the type determined by **target**. **target** must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. The behavior of the query object depends on its type and is as follows.
    * 
    * If **target** is `GL_SAMPLES_PASSED`, **id** must be an unused name, or the name of an existing occlusion query object. When **glBeginQuery** is executed, the query object's samples-passed counter is reset to 0. Subsequent rendering will increment the counter for every sample that passes the depth test. If the value of `GL_SAMPLE_BUFFERS` is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of `GL_SAMPLE_BUFFERS` is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of `GL_SAMPLES` if any sample in the fragment is covered. When **glEndQuery** is executed, the samples-passed counter is assigned to the query object's result value. This value can be queried by calling **`glGetQueryObject`** with **pname** `GL_QUERY_RESULT`.
    * 
    * If **target** is `GL_ANY_SAMPLES_PASSED` or `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, **id** must be an unused name, or the name of an existing boolean occlusion query object. When **glBeginQuery** is executed, the query object's samples-passed flag is reset to `GL_FALSE`. Subsequent rendering causes the flag to be set to `GL_TRUE` if any sample passes the depth test in the case of `GL_ANY_SAMPLES_PASSED`, or if the implementation determines that any sample might pass the depth test in the case of `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`. The implementation may be able to provide a more efficient test in the case of `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` if some false positives are acceptable to the application. When **glEndQuery** is executed, the samples-passed flag is assigned to the query object's result value. This value can be queried by calling **`glGetQueryObject`** with **pname** `GL_QUERY_RESULT`.
    * 
    * If **target** is `GL_PRIMITIVES_GENERATED`, **id** must be an unused name, or the name of an existing primitive query object previously bound to the `GL_PRIMITIVES_GENERATED` query binding. When **glBeginQuery** is executed, the query object's primitives-generated counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader, or from the vertex shader if no geometry shader is present. When **glEndQuery** is executed, the primitives-generated counter is assigned to the query object's result value. This value can be queried by calling **`glGetQueryObject`** with **pname** `GL_QUERY_RESULT`.
    * 
    * If **target** is `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, **id** must be an unused name, or the name of an existing primitive query object previously bound to the `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN` query binding. When **glBeginQuery** is executed, the query object's primitives-written counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s). If transform feedback mode is not activated between the call to **glBeginQuery** and **glEndQuery**, the counter will not be incremented. When **glEndQuery** is executed, the primitives-written counter is assigned to the query object's result value. This value can be queried by calling **`glGetQueryObject`** with **pname** `GL_QUERY_RESULT`.
    * 
    * If **target** is `GL_TIME_ELAPSED`, **id** must be an unused name, or the name of an existing timer query object previously bound to the `GL_TIME_ELAPSED` query binding. When **glBeginQuery** is executed, the query object's time counter is reset to 0. When **glEndQuery** is executed, the elapsed server time that has passed since the call to **glBeginQuery** is written into the query object's time counter. This value can be queried by calling **`glGetQueryObject`** with **pname** `GL_QUERY_RESULT`.
    * 
    * Querying the `GL_QUERY_RESULT` implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. `GL_QUERY_RESULT_AVAILABLE` can be queried to determine if the result is immediately available or if the rendering is not yet complete.
    * 
    * 
    * ### Notes:
    * If the query target's count exceeds the maximum value representable in the number of available bits, as reported by **`glGetQueryiv`** with **target** set to the appropriate query target and **pname** `GL_QUERY_COUNTER_BITS`, the count becomes undefined.
    * 
    * An implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless.
    * 
    * When `GL_SAMPLE_BUFFERS` is 0, the samples-passed counter of an occlusion query will increment once for each fragment that passes the depth test. When `GL_SAMPLE_BUFFERS` is 1, an implementation may either increment the samples-passed counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all samples of a fragment if any one of them passes the depth test.
    * 
    * The query targets `GL_ANY_SAMPLES_PASSED`, and `GL_TIME_ELAPSED` are availale only if the GL version is 3.3 or higher.
    * 
    * The query target `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` is available only of the GL version is 4.3 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not one of the accepted tokens.
    * 
    * `GL_INVALID_OPERATION` is generated if **glBeginQuery** is executed while a query object of the same **target** is already active.
    * 
    * `GL_INVALID_OPERATION` is generated if **glEndQuery** is executed when a query object of the same **target** is not active.
    * 
    * `GL_INVALID_OPERATION` is generated if **id** is 0.
    * 
    * `GL_INVALID_OPERATION` is generated if **id** is the name of an already active query object.
    * 
    * `GL_INVALID_OPERATION` is generated if **id** refers to an existing query object whose type does not does not match **target**.
    * 
    * @param target Specifies the target type of query object established between **glBeginQuery** and the subsequent **glEndQuery**. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.
    * @param id Specifies the name of a query object.

    * @see **`glBeginQueryIndexed`**, **`glDeleteQueries`**, **glEndQuery**, **`glGenQueries`**, **`glGetQueryObject`**, **`glGetQueryiv`**, **`glIsQuery`**

    **/
    static function beginQuery(target:Int, id:Int):Void return ExtensionsNative.beginQuery(target, id);
    static function beginQueryARB(target:Int, id:Int):Void return ExtensionsNative.beginQueryARB(target, id);
    static function beginQueryEXT(target:Int, id:Int):Void return ExtensionsNative.beginQueryEXT(target, id);
    /**
    * - #### Purpose:
    * delimit the boundaries of a query object on an indexed target
    * ### Description:
    * **glBeginQueryIndexed** and **glEndQueryIndexed** delimit the boundaries of a query object. **query** must be a name previously returned from a call to **`glGenQueries`**. If a query object with name **id** does not yet exist it is created with the type determined by **target**. **target** must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. The behavior of the query object depends on its type and is as follows.
    * 
    * **index** specifies the index of the query target and must be between a **target**-specific maximum.
    * 
    * If **target** is `GL_SAMPLES_PASSED`, **id** must be an unused name, or the name of an existing occlusion query object. When **glBeginQueryIndexed** is executed, the query object's samples-passed counter is reset to 0. Subsequent rendering will increment the counter for every sample that passes the depth test. If the value of `GL_SAMPLE_BUFFERS` is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of `GL_SAMPLE_BUFFERS` is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of `GL_SAMPLES` if any sample in the fragment is covered. When **glEndQueryIndexed** is executed, the samples-passed counter is assigned to the query object's result value. This value can be queried by calling **`glGetQueryObject`** with **pname** `GL_QUERY_RESULT`. When **target** is `GL_SAMPLES_PASSED`, **index** must be zero.
    * 
    * If **target** is `GL_ANY_SAMPLES_PASSED`, **id** must be an unused name, or the name of an existing boolean occlusion query object. When **glBeginQueryIndexed** is executed, the query object's samples-passed flag is reset to `GL_FALSE`. Subsequent rendering causes the flag to be set to `GL_TRUE` if any sample passes the depth test. When **glEndQueryIndexed** is executed, the samples-passed flag is assigned to the query object's result value. This value can be queried by calling **`glGetQueryObject`** with **pname** `GL_QUERY_RESULT`. When **target** is `GL_ANY_SAMPLES_PASSED`, **index** must be zero.
    * 
    * If **target** is `GL_PRIMITIVES_GENERATED`, **id** must be an unused name, or the name of an existing primitive query object previously bound to the `GL_PRIMITIVES_GENERATED` query binding. When **glBeginQueryIndexed** is executed, the query object's primitives-generated counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader to the stream given by **index**, or from the vertex shader if **index** is zero and no geometry shader is present. When **glEndQueryIndexed** is executed, the primitives-generated counter for stream **index** is assigned to the query object's result value. This value can be queried by calling **`glGetQueryObject`** with **pname** `GL_QUERY_RESULT`. When **target** is `GL_PRIMITIVES_GENERATED`, **index** must be less than the value of `GL_MAX_VERTEX_STREAMS`.
    * 
    * If **target** is `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, **id** must be an unused name, or the name of an existing primitive query object previously bound to the `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN` query binding. When **glBeginQueryIndexed** is executed, the query object's primitives-written counter for the stream specified by **index** is reset to 0. Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s) for stream **index**. If transform feedback mode is not activated between the call to **glBeginQueryIndexed** and **glEndQueryIndexed**, the counter will not be incremented. When **glEndQueryIndexed** is executed, the primitives-written counter for stream **index** is assigned to the query object's result value. This value can be queried by calling **`glGetQueryObject`** with **pname** `GL_QUERY_RESULT`. When **target** is `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, **index** must be less than the value of `GL_MAX_VERTEX_STREAMS`.
    * 
    * If **target** is `GL_TIME_ELAPSED`, **id** must be an unused name, or the name of an existing timer query object previously bound to the `GL_TIME_ELAPSED` query binding. When **glBeginQueryIndexed** is executed, the query object's time counter is reset to 0. When **glEndQueryIndexed** is executed, the elapsed server time that has passed since the call to **glBeginQueryIndexed** is written into the query object's time counter. This value can be queried by calling **`glGetQueryObject`** with **pname** `GL_QUERY_RESULT`. When **target** is `GL_TIME_ELAPSED`, **index** must be zero.
    * 
    * Querying the `GL_QUERY_RESULT` implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. `GL_QUERY_RESULT_AVAILABLE` can be queried to determine if the result is immediately available or if the rendering is not yet complete.
    * 
    * 
    * ### Notes:
    * If the query target's count exceeds the maximum value representable in the number of available bits, as reported by **`glGetQueryiv`** with **target** set to the appropriate query target and **pname** `GL_QUERY_COUNTER_BITS`, the count becomes undefined.
    * 
    * An implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless.
    * 
    * When `GL_SAMPLE_BUFFERS` is 0, the samples-passed counter of an occlusion query will increment once for each fragment that passes the depth test. When `GL_SAMPLE_BUFFERS` is 1, an implementation may either increment the samples-passed counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all samples of a fragment if any one of them passes the depth test.
    * 
    * Calling **`glBeginQuery`** or **glEndQuery** is equivalent to calling **`glBeginQueryIndexed`** or **glEndQueryIndexed** with **index** set to zero, respectively.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not one of the accepted tokens.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than the query target-specific maximum.
    * 
    * `GL_INVALID_OPERATION` is generated if **glBeginQueryIndexed** is executed while a query object of the same **target** is already active.
    * 
    * `GL_INVALID_OPERATION` is generated if **glEndQueryIndexed** is executed when a query object of the same **target** is not active.
    * 
    * `GL_INVALID_OPERATION` is generated if **id** is 0.
    * 
    * `GL_INVALID_OPERATION` is generated if **id** is the name of an already active query object.
    * 
    * `GL_INVALID_OPERATION` is generated if **id** refers to an existing query object whose type does not does not match **target**.
    * 
    * @param target Specifies the target type of query object established between **glBeginQueryIndexed** and the subsequent **glEndQueryIndexed**. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.
    * @param index Specifies the index of the query target upon which to begin the query.
    * @param id Specifies the name of a query object.

    * @see **`glBeginQuery`**, **`glDeleteQueries`**, **glEndQuery**, **`glGenQueries`**, **`glGetQueryObject`**, **`glGetQueryiv`**, **`glIsQuery`**

    **/
    static function beginQueryIndexed(target:Int, in_dex:Int, id:Int):Void return ExtensionsNative.beginQueryIndexed(target, in_dex, id);
    /**
    * - #### Purpose:
    * start transform feedback operation
    * ### Description:
    * Transform feedback mode captures the values of varying variables written by the vertex shader (or, if active, the geometry shader). Transform feedback is said to be active after a call to **glBeginTransformFeedback** until a subsequent call to **glEndTransformFeedback**. Transform feedback commands must be paired.
    * 
    * If no geometry shader is present, while transform feedback is active the **mode** parameter to **`glDrawArrays`** must match those specified in the following table:
    * 
    * If a geometry shader is present, the output primitive type from the geometry shader must match those provided in the following table:
    * 
    * 
    * ### Notes:
    * Geometry shaders, and the `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY` and `GL_LINE_STRIP_ADJACENCY` primtive modes are available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **glBeginTransformFeedback** is executed while transform feedback is active.
    * 
    * `GL_INVALID_OPERATION` is generated if **glEndTransformFeedback** is executed while transform feedback is not active.
    * 
    * `GL_INVALID_OPERATION` is generated by **`glDrawArrays`** if no geometry shader is present, transform feedback is active and **mode** is not one of the allowed modes.
    * 
    * `GL_INVALID_OPERATION` is generated by **`glDrawArrays`** if a geometry shader is present, transform feedback is active and the output primitive type of the geometry shader does not match the transform feedback **primitiveMode**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glBeginTransformFeedback** if any binding point used in transform feedback mode does not have a buffer object bound.
    * 
    * `GL_INVALID_OPERATION` is generated by **glBeginTransformFeedback** if no binding points would be used, either because no program object is active of because the active program object has specified no varying variables to record.
    * 
    * @param primitiveMode Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.

    * @see **/
    static function beginTransformFeedback(primitiveMode:Int):Void return ExtensionsNative.beginTransformFeedback(primitiveMode);
    static function beginTransformFeedbackEXT(primitiveMode:Int):Void return ExtensionsNative.beginTransformFeedbackEXT(primitiveMode);
    static function beginTransformFeedbackNV(primitiveMode:Int):Void return ExtensionsNative.beginTransformFeedbackNV(primitiveMode);
    static function beginVertexShaderEXT():Void return ExtensionsNative.beginVertexShaderEXT();
    static function beginVideoCaptureNV(video_capture_slot:Int):Void return ExtensionsNative.beginVideoCaptureNV(video_capture_slot);
    /**
    * - #### Purpose:
    * Associates a generic vertex attribute index with a named attribute variable
    * ### Description:
    * **glBindAttribLocation** is used to associate a user-defined attribute variable in the program object specified by **program** with a generic vertex attribute index. The name of the user-defined attribute variable is passed as a null terminated string in **name**. The generic vertex attribute index to be bound to this variable is specified by **index**. When **program** is made part of current state, values provided via the generic vertex attribute **index** will modify the value of the user-defined attribute variable specified by **name**.
    * 
    * If **name** refers to a matrix attribute variable, **index** refers to the first column of the matrix. Other matrix columns are then automatically bound to locations **index+1** for a matrix of type **mat2**; **index+1** and **index+2** for a matrix of type **mat3**; and **index+1**, **index+2**, and **index+3** for a matrix of type **mat4**.
    * 
    * This command makes it possible for vertex shaders to use descriptive names for attribute variables rather than generic variables that are numbered from zero to the value of `GL_MAX_VERTEX_ATTRIBS` minus one. The values sent to each generic attribute index are part of current state. If a different program object is made current by calling **`glUseProgram`**, the generic vertex attributes are tracked in such a way that the same values will be observed by attributes in the new program object that are also bound to **index**.
    * 
    * Attribute variable name-to-generic attribute index bindings for a program object can be explicitly assigned at any time by calling **glBindAttribLocation**. Attribute bindings do not go into effect until **`glLinkProgram`** is called. After a program object has been linked successfully, the index values for generic attributes remain fixed (and their values can be queried) until the next link command occurs.
    * 
    * Any attribute binding that occurs after the program object has been linked will not take effect until the next time the program object is linked.
    * 
    * 
    * ### Notes:
    * **glBindAttribLocation** can be called before any vertex shader objects are bound to the specified program object. It is also permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader.
    * 
    * If **name** was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple indices, but you can bind multiple user-defined attribute variables to the same index.
    * 
    * Applications are allowed to bind more than one user-defined attribute variable to the same generic vertex attribute index. This is called aliasing, and it is allowed only if just one of the aliased attributes is active in the executable program, or if no path through the shader consumes more than one attribute of a set of attributes aliased to the same location. The compiler and linker are allowed to assume that no aliasing is done and are free to employ optimizations that work only in the absence of aliasing. OpenGL implementations are not required to do error checking to detect aliasing.
    * 
    * Active attributes that are not explicitly bound will be bound by the linker when **`glLinkProgram`** is called. The locations assigned can be queried by calling **`glGetAttribLocation`**.
    * 
    * OpenGL copies the **name** string when **glBindAttribLocation** is called, so an application may free its copy of the **name** string immediately after the function returns.
    * 
    * Generic attribute locations may be specified in the shader source text using a **location** layout qualifier. In this case, the location of the attribute specified in the shader's source takes precedence and may be queried by calling **`glGetAttribLocation`**.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.
    * 
    * `GL_INVALID_OPERATION` is generated if **name** starts with the reserved prefix "gl_".
    * 
    * `GL_INVALID_VALUE` is generated if **program** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * @param program Specifies the handle of the program object in which the association is to be made.
    * @param index Specifies the index of the generic vertex attribute to be bound.
    * @param name Specifies a null terminated string containing the name of the vertex shader attribute variable to which **index** is to be bound.

    * @see **glDisableVertexAttribArray**, **`glEnableVertexAttribArray`**, **`glUseProgram`**, **`glVertexAttrib`**, **`glVertexAttribPointer`**

    **/
    static function bindAttribLocation(program:Int, in_dex:Int, name:String):Void return ExtensionsNative.bindAttribLocation(program, in_dex, name);
    static function bindAttribLocationARB(programObj:Int, in_dex:Int, name:String):Void return ExtensionsNative.bindAttribLocationARB(programObj, in_dex, name);
    /**
    * - #### Purpose:
    * bind a named buffer object
    * ### Description:
    * **glBindBuffer** binds a buffer object to the specified buffer binding point. Calling **glBindBuffer** with **target** set to one of the accepted symbolic constants and **buffer** set to the name of a buffer object binds that buffer object name to the target. If no buffer object with name **buffer** exists, one is created with that name. When a buffer object is bound to a target, the previous binding for that target is automatically broken.
    * 
    * Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, **buffer** set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target (if supported for that target). Buffer object names and the corresponding buffer object contents are local to the shared object space of the current GL rendering context; two rendering contexts share buffer object names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.
    * 
    * **`glGenBuffers`** must be used to generate a set of unused buffer object names.
    * 
    * The state of a buffer object immediately after it is first bound is an unmapped zero-sized memory buffer with `GL_READ_WRITE` access and `GL_STATIC_DRAW` usage.
    * 
    * While a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer object, and queries of the target to which it is bound return state from the bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to modify or query state on the target to which it is bound generates an `GL_INVALID_OPERATION` error.
    * 
    * When a non-zero buffer object is bound to the `GL_ARRAY_BUFFER` target, the vertex array pointer parameter is interpreted as an offset within the buffer object measured in basic machine units.
    * 
    * When a non-zero buffer object is bound to the `GL_DRAW_INDIRECT_BUFFER` target, parameters for draws issued through **`glDrawArraysIndirect`** and **`glDrawElementsIndirect`** are sourced from the specified offset in that buffer object's data store.
    * 
    * When a non-zero buffer object is bound to the `GL_DISPATCH_INDIRECT_BUFFER` target, the parameters for compute dispatches issued through **`glDispatchComputeIndirect`** are sourced from the specified offset in that buffer object's data store.
    * 
    * While a non-zero buffer object is bound to the `GL_ELEMENT_ARRAY_BUFFER` target, the indices parameter of **`glDrawElements`**, **`glDrawElementsInstanced`**, **`glDrawElementsBaseVertex`**, **`glDrawRangeElements`**, **`glDrawRangeElementsBaseVertex`**, **`glMultiDrawElements`**, or **`glMultiDrawElementsBaseVertex`** is interpreted as an offset within the buffer object measured in basic machine units.
    * 
    * While a non-zero buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target, the following commands are affected: **`glGetCompressedTexImage`**, **`glGetTexImage`**, and **`glReadPixels`**. The pointer parameter is interpreted as an offset within the buffer object measured in basic machine units.
    * 
    * While a non-zero buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target, the following commands are affected: **`glCompressedTexImage1D`**, **`glCompressedTexImage2D`**, **`glCompressedTexImage3D`**, **`glCompressedTexSubImage1D`**, **`glCompressedTexSubImage2D`**, **`glCompressedTexSubImage3D`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, and **`glTexSubImage3D`**. The pointer parameter is interpreted as an offset within the buffer object measured in basic machine units.
    * 
    * The buffer targets `GL_COPY_READ_BUFFER` and `GL_COPY_WRITE_BUFFER` are provided to allow **`glCopyBufferSubData`** to be used without disturbing the state of other bindings. However, **`glCopyBufferSubData`** may be used with any pair of buffer binding points.
    * 
    * The `GL_TRANSFORM_FEEDBACK_BUFFER` buffer binding point may be passed to **glBindBuffer**, but will not directly affect transform feedback state. Instead, the indexed `GL_TRANSFORM_FEEDBACK_BUFFER` bindings must be used through a call to **`glBindBufferBase`** or **`glBindBufferRange`**. This will affect the generic `GL_TRANSFORM_FEEDBACK_BUFFER` binding.
    * 
    * Likewise, the `GL_UNIFORM_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER` and `GL_SHADER_STORAGE_BUFFER` buffer binding points may be used, but do not directly affect uniform buffer, atomic counter buffer or shader storage buffer state, respectively. **`glBindBufferBase`** or **`glBindBufferRange`** must be used to bind a buffer to an indexed uniform buffer, atomic counter buffer or shader storage buffer binding point.
    * 
    * The `GL_QUERY_BUFFER` binding point is used to specify a buffer object that is to receive the results of query objects through calls to the **`glGetQueryObject`** family of commands.
    * 
    * A buffer object binding created with **glBindBuffer** remains active until a different buffer object name is bound to the same target, or until the bound buffer object is deleted with **`glDeleteBuffers`**.
    * 
    * Once created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may make choices about how to optimize the storage of a buffer object based on its initial binding target.
    * 
    * 
    * ### Notes:
    * The `GL_COPY_READ_BUFFER`, `GL_UNIFORM_BUFFER` and `GL_TEXTURE_BUFFER` targets are available only if the GL version is 3.1 or greater.
    * 
    * The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.
    * 
    * The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.
    * 
    * The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not one of the allowable values.
    * 
    * `GL_INVALID_VALUE` is generated if **buffer** is not a name previously returned from a call to **`glGenBuffers`**.
    * 
    * @param target Specifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of a buffer object.

    * @see **`glGenBuffers`**, **`glBindBufferBase`**, **`glBindBufferRange`**, **`glMapBuffer`**, **`glUnmapBuffer`**, **`glDeleteBuffers`**, **`glGet`**, **`glIsBuffer`**

    **/
    static function bindBuffer(target:Int, buffer:Int):Void return ExtensionsNative.bindBuffer(target, buffer);
    static function bindBufferARB(target:Int, buffer:Int):Void return ExtensionsNative.bindBufferARB(target, buffer);
    /**
    * - #### Purpose:
    * bind a buffer object to an indexed buffer target
    * ### Description:
    * **glBindBufferBase** binds the buffer object **buffer** to the binding point at index **index** of the array of targets specified by **target**. Each **target** represents an indexed array of buffer binding points, as well as a single general binding point that can be used by other buffer manipulation functions such as **`glBindBuffer`** or **`glMapBuffer`**. In addition to binding **buffer** to the indexed buffer binding target, **glBindBufferBase** also binds **buffer** to the generic buffer binding point specified by **target**.
    * 
    * 
    * ### Notes:
    * Calling **glBindBufferBase** is equivalent to calling **`glBindBufferRange`** with **offset** zero and **size** equal to the size of the buffer.
    * 
    * The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.
    * 
    * The `GL_SHADER_STORAGE_BUFFER` target is available only if the GL version is 4.3 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the number of **target**-specific indexed binding points.
    * 
    * `GL_INVALID_VALUE` is generated if **buffer** does not have an associated data store, or if the size of that store is zero.
    * 
    * @param target Specify the target of the bind operation. **target** must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.
    * @param index Specify the index of the binding point within the array specified by **target**.
    * @param buffer The name of a buffer object to bind to the specified binding point.

    * @see **`glGenBuffers`**, **`glDeleteBuffers`**, **`glBindBuffer`**, **`glBindBufferRange`**, **`glMapBuffer`**, **`glUnmapBuffer`**,

    **/
    static function bindBufferBase(target:Int, in_dex:Int, buffer:Int):Void return ExtensionsNative.bindBufferBase(target, in_dex, buffer);
    static function bindBufferBaseEXT(target:Int, in_dex:Int, buffer:Int):Void return ExtensionsNative.bindBufferBaseEXT(target, in_dex, buffer);
    static function bindBufferBaseNV(target:Int, in_dex:Int, buffer:Int):Void return ExtensionsNative.bindBufferBaseNV(target, in_dex, buffer);
    static function bindBufferOffsetEXT(target:Int, in_dex:Int, buffer:Int, offset:Int):Void return ExtensionsNative.bindBufferOffsetEXT(target, in_dex, buffer, offset);
    static function bindBufferOffsetNV(target:Int, in_dex:Int, buffer:Int, offset:Int):Void return ExtensionsNative.bindBufferOffsetNV(target, in_dex, buffer, offset);
    /**
    * - #### Purpose:
    * bind a range within a buffer object to an indexed buffer target
    * ### Description:
    * **glBindBufferRange** binds a range the buffer object **buffer** represented by **offset** and **size** to the binding point at index **index** of the array of targets specified by **target**. Each **target** represents an indexed array of buffer binding points, as well as a single general binding point that can be used by other buffer manipulation functions such as **`glBindBuffer`** or **`glMapBuffer`**. In addition to binding a range of **buffer** to the indexed buffer binding target, **glBindBufferRange** also binds the range to the generic buffer binding point specified by **target**.
    * 
    * **offset** specifies the offset in basic machine units into the buffer object **buffer** and **size** specifies the amount of data that can be read from the buffer object while used as an indexed target.
    * 
    * 
    * ### Notes:
    * The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.
    * 
    * The `GL_SHADER_STORAGE_BUFFER` target is available only if the GL version is 4.3 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the number of **target**-specific indexed binding points.
    * 
    * `GL_INVALID_VALUE` is generated if **size** is less than or equal to zero, or if **offset** + **size** is greater than the value of `GL_BUFFER_SIZE`.
    * 
    * Additional errors may be generated if **offset** violates any **target**-specific alignmemt restrictions.
    * 
    * @param target Specify the target of the bind operation. **target** must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER`, or `GL_SHADER_STORAGE_BUFFER`.
    * @param index Specify the index of the binding point within the array specified by **target**.
    * @param buffer The name of a buffer object to bind to the specified binding point.
    * @param offset The starting offset in basic machine units into the buffer object **buffer**.
    * @param size The amount of data in machine units that can be read from the buffer object while used as an indexed target.

    * @see **`glGenBuffers`**, **`glDeleteBuffers`**, **`glBindBuffer`**, **`glBindBufferBase`**, **`glMapBuffer`**, **`glUnmapBuffer`**,

    **/
    static function bindBufferRange(target:Int, in_dex:Int, buffer:Int, offset:Int, size:Int):Void return ExtensionsNative.bindBufferRange(target, in_dex, buffer, offset, size);
    static function bindBufferRangeEXT(target:Int, in_dex:Int, buffer:Int, offset:Int, size:Int):Void return ExtensionsNative.bindBufferRangeEXT(target, in_dex, buffer, offset, size);
    static function bindBufferRangeNV(target:Int, in_dex:Int, buffer:Int, offset:Int, size:Int):Void return ExtensionsNative.bindBufferRangeNV(target, in_dex, buffer, offset, size);
    /**
    * - #### Purpose:
    * bind one or more buffer objects to a sequence of indexed buffer targets
    * ### Description:
    * **glBindBuffersBase** binds a set of **count** buffer objects whose names are given in the array **buffers** to the **count** consecutive binding points starting from index **first** of the array of targets specified by **target**. If **buffers** is `NULL` then **glBindBuffersBase** unbinds any buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to the following pseudo-code, which calls **`glBindBufferBase`**, with the exception that the non-indexed **target** is not changed by **glBindBuffersBase**:
    * 
    * Each entry in **buffers** will be checked individually and if found to be invalid, the state for that buffer binding index will not be changed and an error will be generated. However, the state for other buffer binding indices referenced by the command will still be updated.
    * 
    * 
    * ### Notes:
    * **glBindBuffersBase** is available only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.
    * 
    * `GL_INVALID_OPERATION` is generated if **first** + **count** is greater than the number of target-specific indexed binding points.
    * 
    * `GL_INVALID_OPERATION` is generated if any value in **buffers** is not zero or the name of an existing buffer object.
    * 
    * @param target Specify the target of the bind operation. **target** must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.
    * @param first Specify the index of the first binding point within the array specified by **target**.
    * @param count Specify the number of contiguous binding points to which to bind buffers.
    * @param buffers A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or `NULL`.

    * @see **`glGenBuffers`**, **`glDeleteBuffers`**, **`glBindBuffer`**, **`glBindBufferBase`**, **`glBindBufferRange`**, **`glBindBuffersRange`**, **`glMapBuffer`**, **`glUnmapBuffer`**

    **/
    static function bindBuffersBase(target:Int, first:Int, count:Int, buffers:DataPointer):Void return ExtensionsNative.bindBuffersBase(target, first, count, buffers);
    /**
    * - #### Purpose:
    * bind ranges of one or more buffer objects to a sequence of indexed buffer targets
    * ### Description:
    * **glBindBuffersRange** binds a set of **count** ranges from buffer objects whose names are given in the array **buffers** to the **count** consecutive binding points starting from index **first** of the array of targets specified by **target**. **offsets** specifies the address of an array containing **count** starting offsets within the buffers, and **sizes** specifies the address of an array of **count** sizes of the ranges. If **buffers** is `NULL` then **offsets** and **sizes** are ignored and **glBindBuffersRange** unbinds any buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to the following pseudo-code, which calls **`glBindBufferRange`**, with the exception that the non-indexed **target** is not changed by **glBindBuffersRange**:
    * 
    * Each entry in **buffers**, **offsets**, and **sizes** will be checked individually and if found to be invalid, the state for that buffer binding index will not be changed and an error will be generated. However, the state for other buffer binding indices referenced by the command will still be updated.
    * 
    * 
    * ### Notes:
    * **glBindBuffersBase** is available only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.
    * 
    * `GL_INVALID_OPERATION` is generated if **first** + **count** is greater than the number of target-specific indexed binding points.
    * 
    * `GL_INVALID_OPERATION` is generated if any value in **buffers** is not zero or the name of an existing buffer object.
    * 
    * `GL_INVALID_VALUE` is generated by if any value in **offsets** is less than zero or if any value in **sizes** is less than zero.
    * 
    * `GL_INVALID_VALUE` is generated if any pair of values in **offsets** and **sizes** does not respectively satisfy the constraints described for those parameters for the specified target.
    * 
    * @param target Specify the target of the bind operation. **target** must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.
    * @param first Specify the index of the first binding point within the array specified by **target**.
    * @param count Specify the number of contiguous binding points to which to bind buffers.
    * @param buffers A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or `NULL`.
    * @param offsets A pointer to an array of offsets into the corresponding buffer in **buffers** to bind, or `NULL` if **buffers** is `NULL`.
    * @param sizes A pointer to an array of sizes of the corresponding buffer in **buffers** to bind, or `NULL` if **buffers** is `NULL`.

    * @see **`glGenBuffers`**, **`glDeleteBuffers`**, **`glBindBuffer`**, **`glBindBufferBase`**, **`glBindBufferRange`**, **`glBindBuffersRange`**, **`glMapBuffer`**, **`glUnmapBuffer`**

    **/
    static function bindBuffersRange(target:Int, first:Int, count:Int, buffers:DataPointer, offsets:DataPointer, sizes:DataPointer):Void return ExtensionsNative.bindBuffersRange(target, first, count, buffers, offsets, sizes);
    /**
    * - #### Purpose:
    * bind a user-defined varying out variable to a fragment shader color number
    * ### Description:
    * **glBindFragDataLocation** explicitly specifies the binding of the user-defined varying out variable **name** to fragment shader color number **colorNumber** for program **program**. If **name** was bound previously, its assigned binding is replaced with **colorNumber**. **name** must be a null-terminated string. **colorNumber** must be less than `GL_MAX_DRAW_BUFFERS`.
    * 
    * The bindings specified by **glBindFragDataLocation** have no effect until **program** is next linked. Bindings may be specified at any time after **program** has been created. Specifically, they may be specified before shader objects are attached to the program. Therefore, any name may be specified in **name**, including a name that is never used as a varying out variable in any fragment shader object. Names beginning with `gl_` are reserved by the GL.
    * 
    * In addition to the errors generated by **glBindFragDataLocation**, the program **program** will fail to link if: The number of active outputs is greater than the value `GL_MAX_DRAW_BUFFERS`. More than one varying out variable is bound to the same color number.
    * 
    * 
    * ### Notes:
    * Varying out varyings may have indexed locations assigned explicitly in the shader text using a location layout qualifier. If a shader statically assigns a location to a varying out variable in the shader text, that location is used and any location assigned with **glBindFragDataLocation** is ignored.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **colorNumber** is greater than or equal to `GL_MAX_DRAW_BUFFERS`.
    * 
    * `GL_INVALID_OPERATION` is generated if **name** starts with the reserved `gl_` prefix.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not the name of a program object.
    * 
    * @param program The name of the program containing varying out variable whose binding to modify
    * @param colorNumber The color number to bind the user-defined varying out variable to
    * @param name The name of the user-defined varying out variable whose binding to modify

    * @see **`glCreateProgram`**, **`glGetFragDataLocation`**

    **/
    static function bindFragDataLocation(program:Int, color:Int, name:String):Void return ExtensionsNative.bindFragDataLocation(program, color, name);
    static function bindFragDataLocationEXT(program:Int, color:Int, name:String):Void return ExtensionsNative.bindFragDataLocationEXT(program, color, name);
    /**
    * - #### Purpose:
    * bind a user-defined varying out variable to a fragment shader color number and index
    * ### Description:
    * **glBindFragDataLocationIndexed** specifies that the varying out variable **name** in **program** should be bound to fragment color **colorNumber** when the program is next linked. **index** may be zero or one to specify that the color be used as either the first or second color input to the blend equation, respectively.
    * 
    * The bindings specified by **glBindFragDataLocationIndexed** have no effect until **program** is next linked. Bindings may be specified at any time after **program** has been created. Specifically, they may be specified before shader objects are attached to the program. Therefore, any name may be specified in **name**, including a name that is never used as a varying out variable in any fragment shader object. Names beginning with `gl_` are reserved by the GL.
    * 
    * If **name** was bound previously, its assigned binding is replaced with **colorNumber** and **index**. **name** must be a null-terminated string. **index** must be less than or equal to one, and **colorNumber** must be less than the value of `GL_MAX_DRAW_BUFFERS` if **index** is zero, and less than the value of `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS` if index is greater than or equal to one.
    * 
    * In addition to the errors generated by **glBindFragDataLocationIndexed**, the program **program** will fail to link if: The number of active outputs is greater than the value `GL_MAX_DRAW_BUFFERS`. More than one varying out variable is bound to the same color number.
    * 
    * 
    * ### Notes:
    * Varying out varyings may have locations assigned explicitly in the shader text using a location layout qualifier. If a shader statically assigns a location to a varying out variable in the shader text, that location is used and any location assigned with **glBindFragDataLocation** is ignored.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **colorNumber** is greater than or equal to `GL_MAX_DRAW_BUFFERS`.
    * 
    * `GL_INVALID_VALUE` is generated if **colorNumber** is greater than or equal to `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS` and **index** is greater than or equal to one.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than one.
    * 
    * `GL_INVALID_OPERATION` is generated if **name** starts with the reserved `gl_` prefix.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not the name of a program object.
    * 
    * @param program The name of the program containing varying out variable whose binding to modify
    * @param colorNumber The color number to bind the user-defined varying out variable to
    * @param index The index of the color input to bind the user-defined varying out variable to
    * @param name The name of the user-defined varying out variable whose binding to modify

    * @see **`glCreateProgram`**, **`glLinkProgram`** **`glGetFragDataLocation`**, **`glGetFragDataIndex`** **`glBindFragDataLocation`**

    **/
    static function bindFragDataLocationIndexed(program:Int, colorNumber:Int, in_dex:Int, name:String):Void return ExtensionsNative.bindFragDataLocationIndexed(program, colorNumber, in_dex, name);
    static function bindFragDataLocationIndexedEXT(program:Int, colorNumber:Int, in_dex:Int, name:String):Void return ExtensionsNative.bindFragDataLocationIndexedEXT(program, colorNumber, in_dex, name);
    static function bindFragmentShaderATI(id:Int):Void return ExtensionsNative.bindFragmentShaderATI(id);
    /**
    * - #### Purpose:
    * bind a framebuffer to a framebuffer target
    * ### Description:
    * **glBindFramebuffer** binds the framebuffer object with name **framebuffer** to the framebuffer target specified by **target**. **target** must be either `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. If a framebuffer object is bound to `GL_DRAW_FRAMEBUFFER` or `GL_READ_FRAMEBUFFER`, it becomes the target for rendering or readback operations, respectively, until it is deleted or another framebuffer is bound to the corresponding bind point. Calling **glBindFramebuffer** with **target** set to `GL_FRAMEBUFFER` binds **framebuffer** to both the read and draw framebuffer targets. **framebuffer** is the name of a framebuffer object previously returned from a call to **`glGenFramebuffers`**, or zero to break the existing binding of a framebuffer object to **target**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`.
    * 
    * `GL_INVALID_OPERATION` is generated if **framebuffer** is not zero or the name of a framebuffer previously returned from a call to **`glGenFramebuffers`**.
    * 
    * @param target Specifies the framebuffer target of the binding operation.
    * @param framebuffer Specifies the name of the framebuffer object to bind.

    * @see **`glGenFramebuffers`**, **`glFramebufferRenderbuffer`**, **`glFramebufferTexture`**, **glFramebufferTexture1D**, **glFramebufferTexture2D**, **glFramebufferTexture3D**, **`glFramebufferTextureLayer`**, **`glDeleteFramebuffers`**, **`glIsFramebuffer`**

    **/
    static function bindFramebuffer(target:Int, framebuffer:Int):Void return ExtensionsNative.bindFramebuffer(target, framebuffer);
    static function bindFramebufferEXT(target:Int, framebuffer:Int):Void return ExtensionsNative.bindFramebufferEXT(target, framebuffer);
    static function bindFramebufferOES(target:Int, framebuffer:Int):Void return ExtensionsNative.bindFramebufferOES(target, framebuffer);
    /**
    * - #### Purpose:
    * bind a level of a texture to an image unit
    * ### Description:
    * **glBindImageTexture** binds a single level of a texture to an image unit for the purpose of reading and writing it from shaders. **unit** specifies the zero-based index of the image unit to which to bind the texture level. **texture** specifies the name of an existing texture object to bind to the image unit. If **texture** is zero, then any existing binding to the image unit is broken. **level** specifies the level of the texture to bind to the image unit.
    * 
    * If **texture** is the name of a one-, two-, or three-dimensional array texture, a cube map or cube map array texture, or a two-dimensional multisample array texture, then it is possible to bind either the entire array, or only a single layer of the array to the image unit. In such cases, if **layered** is `GL_TRUE`, the entire array is attached to the image unit and **layer** is ignored. However, if **layered** is `GL_FALSE` then **layer** specifies the layer of the array to attach to the image unit.
    * 
    * **access** specifies the access types to be performed by shaders and may be set to `GL_READ_ONLY`, `GL_WRITE_ONLY`, or `GL_READ_WRITE` to indicate read-only, write-only or read-write access, respectively. Violation of the access type specified in **access** (for example, if a shader writes to an image bound with **access** set to `GL_READ_ONLY`) will lead to undefined results, possibly including program termination.
    * 
    * **format** specifies the format that is to be used when performing formatted stores into the image from shaders. **format** must be compatible with the texture's internal format and must be one of the formats listed in the following table.
    * 
    * Internal Image Formats Image Unit Format Format Qualifier `GL_RGBA32F` rgba32f `GL_RGBA16F` rgba16f `GL_RG32F` rg32f `GL_RG16F` rg16f `GL_R11F_G11F_B10F` r11f_g11f_b10f `GL_R32F` r32f `GL_R16F` r16f `GL_RGBA32UI` rgba32ui `GL_RGBA16UI` rgba16ui `GL_RGB10_A2UI` rgb10_a2ui `GL_RGBA8UI` rgba8ui `GL_RG32UI` rg32ui `GL_RG16UI` rg16ui `GL_RG8UI` rg8ui `GL_R32UI` r32ui `GL_R16UI` r16ui `GL_R8UI` r8ui `GL_RGBA32I` rgba32i `GL_RGBA16I` rgba16i `GL_RGBA8I` rgba8i `GL_RG32I` rg32i `GL_RG16I` rg16i `GL_RG8I` rg8i `GL_R32I` r32i `GL_R16I` r16i `GL_R8I` r8i `GL_RGBA16` rgba16 `GL_RGB10_A2` rgb10_a2 `GL_RGBA8` rgba8 `GL_RG16` rg16 `GL_RG8` rg8 `GL_R16` r16 `GL_R8` r8 `GL_RGBA16_SNORM` rgba16_snorm `GL_RGBA8_SNORM` rgba8_snorm `GL_RG16_SNORM` rg16_snorm `GL_RG8_SNORM` rg8_snorm `GL_R16_SNORM` r16_snorm `GL_R8_SNORM` r8_snorm
    * 
    * When a texture is bound to an image unit, the **format** parameter for the image unit need not exactly match the texture internal format as long as the formats are considered compatible as defined in the OpenGL Specification. The matching criterion used for a given texture may be determined by calling **`glGetTexParameter`** with **value** set to `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, with return values of `GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE` and `GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS`, specifying matches by size and class, respectively.
    * 
    * 
    * ### Notes:
    * The **glBindImageTexture** is available only if the GL version is 4.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **unit** greater than or equal to the value of `GL_MAX_IMAGE_UNITS`.
    * 
    * `GL_INVALID_VALUE` is generated if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_VALUE` is generated if **level** or **layer** is less than zero.
    * 
    * `GL_INVALID_ENUM` is generated if **access** or **format** is not one of the supported tokens.
    * 
    * @param unit Specifies the index of the image unit to which to bind the texture
    * @param texture Specifies the name of the texture to bind to the image unit.
    * @param level Specifies the level of the texture that is to be bound.
    * @param layered Specifies whether a layered texture binding is to be established.
    * @param layer If **layered** is `GL_FALSE`, specifies the layer of **texture** to be bound to the image unit. Ignored otherwise.
    * @param access Specifies a token indicating the type of access that will be performed on the image.
    * @param format Specifies the format that the elements of the image will be treated as for the purposes of formatted stores.

    * @see **`glGenTextures`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexStorage1D`**, **`glTexStorage2D`**, **`glTexStorage3D`**, **`glBindTexture`**

    **/
    static function bindImageTexture(unit:Int, texture:Int, level:Int, layered:Bool, layer:Int, access:Int, format:Int):Void return ExtensionsNative.bindImageTexture(unit, texture, level, layered, layer, access, format);
    static function bindImageTextureEXT(in_dex:Int, texture:Int, level:Int, layered:Bool, layer:Int, access:Int, format:Int):Void return ExtensionsNative.bindImageTextureEXT(in_dex, texture, level, layered, layer, access, format);
    /**
    * - #### Purpose:
    * bind one or more named texture images to a sequence of consecutive image units
    * ### Description:
    * **glBindImageTextures** binds images from an array of existing texture objects to a specified number of consecutive image units. **count** specifies the number of texture objects whose names are stored in the array **textures**. That number of texture names are read from the array and bound to the **count** consecutive texture units starting from **first**. If the name zero appears in the **textures** array, any existing binding to the image unit is reset. Any non-zero entry in **textures** must be the name of an existing texture object. When a non-zero entry in **textures** is present, the image at level zero is bound, the binding is considered layered, with the first layer set to zero, and the image is bound for read-write access. The image unit format parameter is taken from the internal format of the image at level zero of the texture object. For cube map textures, the internal format of the positive X image of level zero is used. If **textures** is `NULL` then it is as if an appropriately sized array containing only zeros had been specified.
    * 
    * **glBindImageTextures** is equivalent to the following pseudo code:
    * 
    * Each entry in **textures** will be checked individually and if found to be invalid, the state for that image unit will not be changed and an error will be generated. However, the state for other texture image units referenced by the command will still be updated.
    * 
    * 
    * ### Notes:
    * **glBindImageTextures** is available only if the GL version is 4.4 or higher.
    * 
    * Note that because **glBindImageTextures** cannot create new textures (even if a name passed has been previously generated by call to **`glGenTextures`**), names passed to **glBindImageTextures** must have been bound at least once previously via a call to **`glBindTexture`**.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **first** + **count** is greater than the number of image units supported by the implementation.
    * 
    * `GL_INVALID_OPERATION` is generated if any value in **textures** is not zero or the name of an existing texture object.
    * 
    * `GL_INVALID_OPERATION` error is generated if the internal format of the level zero texture image of any texture in textures is not supported.
    * 
    * `GL_INVALID_OPERATION` error is generated if the width, height, or depth of the level zero texture image of any texture in textures is zero.
    * 
    * @param first Specifies the first image unit to which a texture is to be bound.
    * @param count Specifies the number of textures to bind.
    * @param textures Specifies the address of an array of names of existing texture objects.

    * @see **`glBindTexture`**, **`glBindTextures`**, **`glDeleteTextures`**, **`glGenTextures`**, **`glGet`**, **`glGetTexParameter`**, **`glIsTexture`**, **`glTexStorage1D`**, **`glTexStorage2D`**, **`glTexStorage2DMultisample`**, **`glTexStorage3D`**, **`glTexStorage3DMultisample`**, **`glTexBuffer`**, **`glTexParameter`**

    **/
    static function bindImageTextures(first:Int, count:Int, textures:DataPointer):Void return ExtensionsNative.bindImageTextures(first, count, textures);
    static function bindLightParameterEXT(light:Int, value:Int):Int return ExtensionsNative.bindLightParameterEXT(light, value);
    static function bindMaterialParameterEXT(face:Int, value:Int):Int return ExtensionsNative.bindMaterialParameterEXT(face, value);
    static function bindMultiTextureEXT(texunit:Int, target:Int, texture:Int):Void return ExtensionsNative.bindMultiTextureEXT(texunit, target, texture);
    static function bindParameterEXT(value:Int):Int return ExtensionsNative.bindParameterEXT(value);
    static function bindProgramARB(target:Int, program:Int):Void return ExtensionsNative.bindProgramARB(target, program);
    static function bindProgramNV(target:Int, id:Int):Void return ExtensionsNative.bindProgramNV(target, id);
    /**
    * - #### Purpose:
    * bind a program pipeline to the current context
    * ### Description:
    * **glBindProgramPipeline** binds a program pipeline object to the current context. **pipeline** must be a name previously returned from a call to **`glGenProgramPipelines`**. If no program pipeline exists with name **pipeline** then a new pipeline object is created with that name and initialized to the default state vector.
    * 
    * When a program pipeline object is bound using **glBindProgramPipeline**, any previous binding is broken and is replaced with a binding to the specified pipeline object. If **pipeline** is zero, the previous binding is broken and is not replaced, leaving no pipeline object bound. If no current program object has been established by **`glUseProgram`**, the program objects used for each stage and for uniform updates are taken from the bound program pipeline object, if any. If there is a current program object established by **`glUseProgram`**, the bound program pipeline object has no effect on rendering or uniform updates. When a bound program pipeline object is used for rendering, individual shader executables are taken from its program objects.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **pipeline** is not zero or a name previously returned from a call to **`glGenProgramPipelines`** or if such a name has been deleted by a call to **`glDeleteProgramPipelines`**.
    * 
    * @param pipeline Specifies the name of the pipeline object to bind to the context.

    * @see **`glCreateShader`**, **`glCreateProgram`**, **`glCompileShader`**, **`glLinkProgram`**, **`glGenProgramPipelines`**, **`glDeleteProgramPipelines`**, **`glIsProgramPipeline`**

    **/
    static function bindProgramPipeline(pipelin_e:Int):Void return ExtensionsNative.bindProgramPipeline(pipelin_e);
    static function bindProgramPipelineEXT(pipelin_e:Int):Void return ExtensionsNative.bindProgramPipelineEXT(pipelin_e);
    /**
    * - #### Purpose:
    * bind a renderbuffer to a renderbuffer target
    * ### Description:
    * **glBindRenderbuffer** binds the renderbuffer object with name **renderbuffer** to the renderbuffer target specified by **target**. **target** must be `GL_RENDERBUFFER`. **renderbuffer** is the name of a renderbuffer object previously returned from a call to **`glGenRenderbuffers`**, or zero to break the existing binding of a renderbuffer object to **target**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_RENDERBUFFER`.
    * 
    * `GL_INVALID_OPERATION` is generated if **renderbuffer** is not zero or the name of a renderbuffer previously returned from a call to **`glGenRenderbuffers`**.
    * 
    * @param target Specifies the renderbuffer target of the binding operation. **target** must be `GL_RENDERBUFFER`.
    * @param renderbuffer Specifies the name of the renderbuffer object to bind.

    * @see **`glDeleteRenderbuffers`**, **`glGenRenderbuffers`**, **`glIsRenderbuffer`**, **`glRenderbufferStorage`**, **`glRenderbufferStorageMultisample`**

    **/
    static function bindRenderbuffer(target:Int, renderbuffer:Int):Void return ExtensionsNative.bindRenderbuffer(target, renderbuffer);
    static function bindRenderbufferEXT(target:Int, renderbuffer:Int):Void return ExtensionsNative.bindRenderbufferEXT(target, renderbuffer);
    static function bindRenderbufferOES(target:Int, renderbuffer:Int):Void return ExtensionsNative.bindRenderbufferOES(target, renderbuffer);
    /**
    * - #### Purpose:
    * bind a named sampler to a texturing target
    * ### Description:
    * **glBindSampler** binds **sampler** to the texture unit at index **unit**. **sampler** must be zero or the name of a sampler object previously returned from a call to **`glGenSamplers`**. **unit** must be less than the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`.
    * 
    * When a sampler object is bound to a texture unit, its state supersedes that of the texture object bound to that texture unit. If the sampler name zero is bound to a texture unit, the currently bound texture's sampler state becomes active. A single sampler object may be bound to multiple texture units simultaneously.
    * 
    * 
    * ### Notes:
    * **glBindSampler** is available only if the GL version is 3.3 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **unit** is greater than or equal to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`.
    * 
    * `GL_INVALID_OPERATION` is generated if **sampler** is not zero or a name previously returned from a call to **`glGenSamplers`**, or if such a name has been deleted by a call to **`glDeleteSamplers`**.
    * 
    * @param unit Specifies the index of the texture unit to which the sampler is bound.
    * @param sampler Specifies the name of a sampler.

    * @see **`glGenSamplers`**, **`glDeleteSamplers`**, **`glGet`**, **`glSamplerParameter`**, **`glGetSamplerParameter`**, **`glGenTextures`**, **`glBindTexture`**, **`glDeleteTextures`**

    **/
    static function bindSampler(unit:Int, sampler:Int):Void return ExtensionsNative.bindSampler(unit, sampler);
    /**
    * - #### Purpose:
    * bind one or more named sampler objects to a sequence of consecutive sampler units
    * ### Description:
    * **glBindSamplers** binds samplers from an array of existing sampler objects to a specified number of consecutive sampler units. **count** specifies the number of sampler objects whose names are stored in the array **samplers**. That number of sampler names is read from the array and bound to the **count** consecutive sampler units starting from **first**.
    * 
    * If the name zero appears in the **samplers** array, any existing binding to the sampler unit is reset. Any non-zero entry in **samplers** must be the name of an existing sampler object. When a non-zero entry in **samplers** is present, that sampler object is bound to the corresponding sampler unit. If **samplers** is `NULL` then it is as if an appropriately sized array containing only zeros had been specified.
    * 
    * **glBindSamplers** is equivalent to the following pseudo code:
    * 
    * Each entry in **samplers** will be checked individually and if found to be invalid, the state for that sampler unit will not be changed and an error will be generated. However, the state for other sampler units referenced by the command will still be updated.
    * 
    * 
    * ### Notes:
    * **glBindSamplers** is available only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **first** + **count** is greater than the number of sampler units supported by the implementation.
    * 
    * `GL_INVALID_OPERATION` is generated if any value in **samplers** is not zero or the name of an existing sampler object.
    * 
    * @param first Specifies the first sampler unit to which a sampler object is to be bound.
    * @param count Specifies the number of samplers to bind.
    * @param samplers Specifies the address of an array of names of existing sampler objects.

    * @see **`glGenSamplers`**, **`glBindSampler`**, **`glDeleteSamplers`**, **`glGet`**, **`glSamplerParameter`**, **`glGetSamplerParameter`**, **`glGenTextures`**, **`glBindTexture`**, **`glDeleteTextures`**

    **/
    static function bindSamplers(first:Int, count:Int, samplers:DataPointer):Void return ExtensionsNative.bindSamplers(first, count, samplers);
    static function bindShadingRateImageNV(texture:Int):Void return ExtensionsNative.bindShadingRateImageNV(texture);
    static function bindTexGenParameterEXT(unit:Int, coord:Int, value:Int):Int return ExtensionsNative.bindTexGenParameterEXT(unit, coord, value);
    /**
    * - #### Purpose:
    * bind a named texture to a texturing target
    * ### Description:
    * **glBindTexture** lets you create or use a named texture. Calling **glBindTexture** with **target** set to `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` and **texture** set to the name of the new texture binds the texture name to the target. When a texture is bound to a target, the previous binding for that target is automatically broken.
    * 
    * Texture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared object space of the current GL rendering context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.
    * 
    * You must use **`glGenTextures`** to generate a set of new texture names.
    * 
    * When a texture is first bound, it assumes the specified target: A texture first bound to `GL_TEXTURE_1D` becomes one-dimensional texture, a texture first bound to `GL_TEXTURE_2D` becomes two-dimensional texture, a texture first bound to `GL_TEXTURE_3D` becomes three-dimensional texture, a texture first bound to `GL_TEXTURE_1D_ARRAY` becomes one-dimensional array texture, a texture first bound to `GL_TEXTURE_2D_ARRAY` becomes two-dimensional array texture, a texture first bound to `GL_TEXTURE_RECTANGLE` becomes rectangle texture, a texture first bound to `GL_TEXTURE_CUBE_MAP` becomes a cube-mapped texture, a texture first bound to `GL_TEXTURE_CUBE_MAP_ARRAY` becomes a cube-mapped array texture, a texture first bound to `GL_TEXTURE_BUFFER` becomes a buffer texture, a texture first bound to `GL_TEXTURE_2D_MULTISAMPLE` becomes a two-dimensional multisampled texture, and a texture first bound to `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` becomes a two-dimensional multisampled array texture. The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the default `GL_TEXTURE_1D` at GL initialization, and similarly for the other texture types.
    * 
    * While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization.
    * 
    * A texture binding created with **glBindTexture** remains active until a different texture is bound to the same target, or until the bound texture is deleted with **`glDeleteTextures`**.
    * 
    * Once created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use **glBindTexture** to bind an existing named texture to one of the texture targets than it is to reload the texture image using **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`** or another similar function.
    * 
    * 
    * ### Notes:
    * The `GL_TEXTURE_2D_MULTISAMPLE` and `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` targets are available only if the GL version is 3.2 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not one of the allowable values.
    * 
    * `GL_INVALID_VALUE` is generated if **texture** is not a name returned from a previous call to **`glGenTextures`**.
    * 
    * `GL_INVALID_OPERATION` is generated if **texture** was previously created with a target that doesn't match that of **target**.
    * 
    * @param target Specifies the target to which the texture is bound. Must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.
    * @param texture Specifies the name of a texture.

    * @see **`glDeleteTextures`**, **`glGenTextures`**, **`glGet`**, **`glGetTexParameter`**, **`glIsTexture`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage2DMultisample`**, **`glTexImage3D`**, **`glTexImage3DMultisample`**, **`glTexBuffer`**, **`glTexParameter`**

    **/
    static function bindTexture(target:Int, texture:Int):Void return ExtensionsNative.bindTexture(target, texture);
    static function bindTextureEXT(target:Int, texture:Int):Void return ExtensionsNative.bindTextureEXT(target, texture);
    /**
    * - #### Purpose:
    * bind an existing texture object to the specified texture unit
    * ### Description:
    * **glBindTextureUnit** binds an existing texture object to the texture unit numbered **unit**.
    * 
    * **texture** must be zero or the name of an existing texture object. When **texture** is the name of an existing texture object, that object is bound to the target, in the corresponding texture unit, that was specified when the object was created. When **texture** is zero, each of the targets enumerated at the beginning of this section is reset to its default texture for the corresponding texture image unit.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` error is generated if **texture** is not zero or the name of an existing texture object.
    * 
    * @param unit Specifies the texture unit, to which the texture object should be bound to.
    * @param texture Specifies the name of a texture.

    * @see **`glDeleteTextures`**, **`glGenTextures`**, **`glGet`**, **`glGetTexParameter`**, **`glIsTexture`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage2DMultisample`**, **`glTexImage3D`**, **`glTexImage3DMultisample`**, **`glTexBuffer`**, **`glTexParameter`**

    **/
    static function bindTextureUnit(unit:Int, texture:Int):Void return ExtensionsNative.bindTextureUnit(unit, texture);
    static function bindTextureUnitParameterEXT(unit:Int, value:Int):Int return ExtensionsNative.bindTextureUnitParameterEXT(unit, value);
    /**
    * - #### Purpose:
    * bind one or more named textures to a sequence of consecutive texture units
    * ### Description:
    * **glBindTextures** binds an array of existing texture objects to a specified number of consecutive texture units. **count** specifies the number of texture objects whose names are stored in the array **textures**. That number of texture names are read from the array and bound to the **count** consecutive texture units starting from **first**. The target, or type of texture is deduced from the texture object and each texture is bound to the corresponding target of the texture unit. If the name zero appears in the **textures** array, any existing binding to any target of the texture unit is reset and the default texture for that target is bound in its place. Any non-zero entry in **textures** must be the name of an existing texture object. If **textures** is `NULL` then it is as if an appropriately sized array containing only zeros had been specified.
    * 
    * With the exception that the active texture selector maintains its current value, **glBindTextures** is equivalent to the following pseudo code:
    * 
    * Each entry in **textures** will be checked individually and if found to be invalid, the state for that texture unit will not be changed and an error will be generated. However, the state for other texture units referenced by the command will still be updated.
    * 
    * 
    * ### Notes:
    * **glBindTextures** is available only if the GL version is 4.4 or higher.
    * 
    * Note that because **glBindTextures** cannot create new textures (even if a name passed has been previously generated by call to **`glGenTextures`**), names passed to **glBindTextures** must have been bound at least once previously via a call to **`glBindTexture`**.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **first** + **count** is greater than the number of texture image units supported by the implementation.
    * 
    * `GL_INVALID_OPERATION` is generated if any value in textures is not zero or the name of an existing texture object.
    * 
    * @param first Specifies the first texture unit to which a texture is to be bound.
    * @param count Specifies the number of textures to bind.
    * @param textures Specifies the address of an array of names of existing texture objects.

    * @see **`glBindTexture`**, **`glDeleteTextures`**, **`glGenTextures`**, **`glGet`**, **`glGetTexParameter`**, **`glIsTexture`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage2DMultisample`**, **`glTexImage3D`**, **`glTexImage3DMultisample`**, **`glTexBuffer`**, **`glTexParameter`**

    **/
    static function bindTextures(first:Int, count:Int, textures:DataPointer):Void return ExtensionsNative.bindTextures(first, count, textures);
    /**
    * - #### Purpose:
    * bind a transform feedback object
    * ### Description:
    * **glBindTransformFeedback** binds the transform feedback object with name **id** to the current GL state. **id** must be a name previously returned from a call to **`glGenTransformFeedbacks`**. If **id** has not previously been bound, a new transform feedback object with name **id** and initialized with the default transform state vector is created.
    * 
    * In the initial state, a default transform feedback object is bound and treated as a transform feedback object with a name of zero. If the name zero is subsequently bound, the default transform feedback object is again bound to the GL state.
    * 
    * While a transform feedback buffer object is bound, GL operations on the target to which it is bound affect the bound transform feedback object, and queries of the target to which a transform feedback object is bound return state from the bound object. When buffer objects are bound for transform feedback, they are attached to the currently bound transform feedback object. Buffer objects are used for trans- form feedback only if they are attached to the currently bound transform feedback object.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_TRANSFORM_FEEDBACK`.
    * 
    * `GL_INVALID_OPERATION` is generated if the transform feedback operation is active on the currently bound transform feedback object, and that operation is not paused.
    * 
    * `GL_INVALID_OPERATION` is generated if **id** is not zero or the name of a transform feedback object returned from a previous call to **`glGenTransformFeedbacks`**, or if such a name has been deleted by **`glDeleteTransformFeedbacks`**.
    * 
    * @param target Specifies the target to which to bind the transform feedback object **id**. **target** must be `GL_TRANSFORM_FEEDBACK`.
    * @param id Specifies the name of a transform feedback object reserved by **`glGenTransformFeedbacks`**.

    * @see **`glGenTransformFeedbacks`**, **`glDeleteTransformFeedbacks`**, **`glIsTransformFeedback`**, **`glBeginTransformFeedback`**, **`glPauseTransformFeedback`**, **`glResumeTransformFeedback`**, **glEndTransformFeedback**

    **/
    static function bindTransformFeedback(target:Int, id:Int):Void return ExtensionsNative.bindTransformFeedback(target, id);
    static function bindTransformFeedbackNV(target:Int, id:Int):Void return ExtensionsNative.bindTransformFeedbackNV(target, id);
    /**
    * - #### Purpose:
    * bind a vertex array object
    * ### Description:
    * **glBindVertexArray** binds the vertex array object with name **array**. **array** is the name of a vertex array object previously returned from a call to **`glGenVertexArrays`**, or zero to break the existing vertex array object binding.
    * 
    * If no vertex array object with name **array** exists, one is created when **array** is first bound. If the bind is successful no change is made to the state of the vertex array object, and any previous vertex array object binding is broken.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **array** is not zero or the name of a vertex array object previously returned from a call to **`glGenVertexArrays`**.
    * 
    * @param array Specifies the name of the vertex array to bind.

    * @see **`glDeleteVertexArrays`**, **`glEnableVertexAttribArray`**, **`glGenVertexArrays`**, **`glIsVertexArray`**, **`glVertexAttribPointer`**

    **/
    static function bindVertexArray(array:Int):Void return ExtensionsNative.bindVertexArray(array);
    static function bindVertexArrayAPPLE(array:Int):Void return ExtensionsNative.bindVertexArrayAPPLE(array);
    static function bindVertexArrayOES(array:Int):Void return ExtensionsNative.bindVertexArrayOES(array);
    /**
    * - #### Purpose:
    * bind a buffer to a vertex buffer bind point
    * ### Description:
    * **glBindVertexBuffer** and **glVertexArrayVertexBuffer** bind the buffer named **buffer** to the vertex buffer binding point whose index is given by **bindingindex**. **glBindVertexBuffer** modifies the binding of the currently bound vertex array object, whereas **glVertexArrayVertexBuffer** allows the caller to specify ID of the vertex array object with an argument named **vaobj**, for which the binding should be modified. **offset** and **stride** specify the offset of the first element within the buffer and the distance between elements within the buffer, respectively, and are both measured in basic machine units. **bindingindex** must be less than the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`. **offset** and **stride** must be greater than or equal to zero. If **buffer** is zero, then any buffer currently bound to the specified binding point is unbound.
    * 
    * If **buffer** is not the name of an existing buffer object, the GL first creates a new state vector, initialized with a zero-sized memory buffer and comprising all the state and with the same initial values as in case of **glBindBuffer**. **buffer** is then attached to the specified **bindingindex** of the vertex array object.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated by **glBindVertexBuffer** if no vertex array object is bound.
    * 
    * `GL_INVALID_OPERATION` is generated by **glVertexArrayVertexBuffer** if **vaobj** is not the name of an existing vertex array object.
    * 
    * `GL_INVALID_VALUE` is generated if **bindingindex** is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.
    * 
    * `GL_INVALID_VALUE` is generated if **offset** or **stride** is less than zero, or if stride is greater than the value of `GL_MAX_VERTEX_ATTRIB_STRIDE`.
    * 
    * `GL_INVALID_VALUE` is generated if **buffer** is not zero or the name of an existing buffer object (as returned by **glGenBuffers** or **glCreateBuffers**).
    * 
    * @param vaobj Specifies the name of the vertex array object to be used by **glVertexArrayVertexBuffer** function.
    * @param bindingindex The index of the vertex buffer binding point to which to bind the buffer.
    * @param buffer The name of a buffer to bind to the vertex buffer binding point.
    * @param offset The offset of the first element of the buffer.
    * @param stride The distance between elements within the buffer.

    * @see **`glVertexAttribBinding`**, **`glVertexAttribFormat`**, **`glVertexAttribPointer`**, **`glVertexBindingDivisor`**.

    **/
    static function bindVertexBuffer(bin_din_gin_dex:Int, buffer:Int, offset:Int, stride:Int):Void return ExtensionsNative.bindVertexBuffer(bin_din_gin_dex, buffer, offset, stride);
    /**
    * - #### Purpose:
    * attach multiple buffer objects to a vertex array object
    * ### Description:
    * **glBindVertexBuffers** and **glVertexArrayVertexBuffers** bind storage from an array of existing buffer objects to a specified number of consecutive vertex buffer binding points units in a vertex array object. For **glBindVertexBuffers**, the vertex array object is the currently bound vertex array object. For **glVertexArrayVertexBuffers**, **vaobj** is the name of the vertex array object.
    * 
    * **count** existing buffer objects are bound to vertex buffer binding points numbered $first$ through $first + count - 1$. If **buffers** is not NULL, it specifies an array of **count** values, each of which must be zero or the name of an existing buffer object. **offsets** and **strides** specify arrays of **count** values indicating the offset of the first element and stride between elements in each buffer, respectively. If **buffers** is NULL, each affected vertex buffer binding point from $first$ through $first + count - 1$ will be reset to have no bound buffer object. In this case, the offsets and strides associated with the binding points are set to default values, ignoring **offsets** and **strides**.
    * 
    * **glBindVertexBuffers** is equivalent (assuming no errors are generated) to:for (i = 0; i &lt; count; i++) { if (buffers == NULL) { glBindVertexBuffer(first + i, 0, 0, 16); } else { glBindVertexBuffer(first + i, buffers[i], offsets[i], strides[i]); } } except that buffers will not be created if they do not exist.
    * 
    * **glVertexArrayVertexBuffers** is equivalent to the pseudocode above, but replacing **glBindVertexBuffers**(args) with **glVertexArrayVertexBuffers**(vaobj, args).
    * 
    * The values specified in **buffers**, **offsets**, and **strides** will be checked separately for each vertex buffer binding point. When a value for a specific vertex buffer binding point is invalid, the state for that binding point will be unchanged and an error will be generated. However, state for other vertex buffer binding points will still be changed if their corresponding values are valid.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated by **glBindVertexBuffers** if no vertex array object is bound.
    * 
    * `GL_INVALID_OPERATION` is generated by **glVertexArrayVertexBuffers** if **vaobj** is not the name of the vertex array object.
    * 
    * `GL_INVALID_OPERATION` is generated if $first + count$ is greater than the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.
    * 
    * `GL_INVALID_OPERATION` is generated if any value in `buffers` is not zero or the name of an existing buffer object.
    * 
    * `GL_INVALID_VALUE` is generated if any value in **offsets** or **strides** is negative, or if a value is **stride** is greater than the value of `GL_MAX_VERTEX_ATTRIB_STRIDE`.
    * 
    * @param vaobj Specifies the name of the vertex array object for **glVertexArrayVertexBuffers**.
    * @param first Specifies the first vertex buffer binding point to which a buffer object is to be bound.
    * @param count Specifies the number of buffers to bind.
    * @param buffers Specifies the address of an array of names of existing buffer objects.
    * @param offsets Specifies the address of an array of offsets to associate with the binding points.
    * @param strides Specifies the address of an array of strides to associate with the binding points.

    * @see **`glGenBuffers`**, **`glBindBuffer`**, **`glDeleteBuffers`** **`glDeleteTextures`**

    **/
    static function bindVertexBuffers(first:Int, count:Int, buffers:DataPointer, offsets:DataPointer, strides:DataPointer):Void return ExtensionsNative.bindVertexBuffers(first, count, buffers, offsets, strides);
    static function bindVertexShaderEXT(id:Int):Void return ExtensionsNative.bindVertexShaderEXT(id);
    static function bindVideoCaptureStreamBufferNV(video_capture_slot:Int, stream:Int, frame_region:Int, offset:Int):Void return ExtensionsNative.bindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
    static function bindVideoCaptureStreamTextureNV(video_capture_slot:Int, stream:Int, frame_region:Int, target:Int, texture:Int):Void return ExtensionsNative.bindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
    static function binormal3bEXT(bx:Int, by:Int, bz:Int):Void return ExtensionsNative.binormal3bEXT(bx, by, bz);
    static function binormal3bvEXT(v:DataPointer):Void return ExtensionsNative.binormal3bvEXT(v);
    static function binormal3dEXT(bx:DataPointer, by:DataPointer, bz:DataPointer):Void return ExtensionsNative.binormal3dEXT(bx, by, bz);
    static function binormal3dvEXT(v:DataPointer):Void return ExtensionsNative.binormal3dvEXT(v);
    static function binormal3fEXT(bx:Float, by:Float, bz:Float):Void return ExtensionsNative.binormal3fEXT(bx, by, bz);
    static function binormal3fvEXT(v:DataPointer):Void return ExtensionsNative.binormal3fvEXT(v);
    static function binormal3iEXT(bx:Int, by:Int, bz:Int):Void return ExtensionsNative.binormal3iEXT(bx, by, bz);
    static function binormal3ivEXT(v:DataPointer):Void return ExtensionsNative.binormal3ivEXT(v);
    static function binormal3sEXT(bx:Int, by:Int, bz:Int):Void return ExtensionsNative.binormal3sEXT(bx, by, bz);
    static function binormal3svEXT(v:DataPointer):Void return ExtensionsNative.binormal3svEXT(v);
    static function binormalPointerEXT(type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.binormalPointerEXT(type, stride, poin_ter);
    static function bitmap(width:Int, height:Int, xorig:Float, yorig:Float, xmove:Float, ymove:Float, bitmap:DataPointer):Void return ExtensionsNative.bitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
    static function bitmapxOES(width:Int, height:Int, xorig:Int, yorig:Int, xmove:Int, ymove:Int, bitmap:DataPointer):Void return ExtensionsNative.bitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap);
    static function blendBarrier():Void return ExtensionsNative.blendBarrier();
    static function blendBarrierKHR():Void return ExtensionsNative.blendBarrierKHR();
    static function blendBarrierNV():Void return ExtensionsNative.blendBarrierNV();
    /**
    * - #### Purpose:
    * set the blend color
    * ### Description:
    * The `GL_BLEND_COLOR` may be used to calculate the source and destination blending factors. The color components are clamped to the range 0 1 before being stored. See **`glBlendFunc`** for a complete description of the blending operations. Initially the `GL_BLEND_COLOR` is set to (0, 0, 0, 0).
    * 
    * 
    * ### Notes:
    * The type of the **red**, **green**, **blue**, and **alpha** parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the **`removedTypes`** page.
    * 
    * 
    * ### Errors:
    * @param red green blue alpha specify the components of `GL_BLEND_COLOR`

    * @see **`glBlendEquation`**, **`glBlendFunc`**, **`glGetString`**, **`removedTypes`**

    **/
    static function blendColor(red:Float, green:Float, blue:Float, alpha:Float):Void return ExtensionsNative.blendColor(red, green, blue, alpha);
    static function blendColorEXT(red:Float, green:Float, blue:Float, alpha:Float):Void return ExtensionsNative.blendColorEXT(red, green, blue, alpha);
    static function blendColorxOES(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.blendColorxOES(red, green, blue, alpha);
    /**
    * - #### Purpose:
    * specify the equation used for both the RGB blend equation and the Alpha blend equation
    * ### Description:
    * The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function sets both the RGB blend equation and the alpha blend equation to a single equation. **glBlendEquationi** specifies the blend equation for a single draw buffer whereas **glBlendEquation** sets the blend equation for all draw buffers.
    * 
    * These equations use the source and destination blend factors specified by either **`glBlendFunc`** or **`glBlendFuncSeparate`**. See **`glBlendFunc`** or **`glBlendFuncSeparate`** for a description of the various blend factors.
    * 
    * In the equations that follow, source and destination color components are referred to as R s G s B s A s and R d G d B d A d, respectively. The result color is referred to as R r G r B r A r. The source and destination blend factors are denoted s R s G s B s A and d R d G d B d A, respectively. For these equations all color components are understood to have values in the range 0 1. Mode RGB Components Alpha Component `GL_FUNC_ADD` Rr = R s &amp;it; s R + R d &amp;it; d R Gr = G s &amp;it; s G + G d &amp;it; d G Br = B s &amp;it; s B + B d &amp;it; d B Ar = A s &amp;it; s A + A d &amp;it; d A `GL_FUNC_SUBTRACT` Rr = R s &amp;it; s R - R d &amp;it; d R Gr = G s &amp;it; s G - G d &amp;it; d G Br = B s &amp;it; s B - B d &amp;it; d B Ar = A s &amp;it; s A - A d &amp;it; d A `GL_FUNC_REVERSE_SUBTRACT` Rr = R d &amp;it; d R - R s &amp;it; s R Gr = G d &amp;it; d G - G s &amp;it; s G Br = B d &amp;it; d B - B s &amp;it; s B Ar = A d &amp;it; d A - A s &amp;it; s A `GL_MIN` Rr = min &amp;af; R s R d Gr = min &amp;af; G s G d Br = min &amp;af; B s B d Ar = min &amp;af; A s A d `GL_MAX` Rr = max &amp;af; R s R d Gr = max &amp;af; G s G d Br = max &amp;af; B s B d Ar = max &amp;af; A s A d
    * 
    * The results of these equations are clamped to the range 0 1.
    * 
    * The `GL_MIN` and `GL_MAX` equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The `GL_FUNC_ADD` equation is useful for antialiasing and transparency, among other things.
    * 
    * Initially, both the RGB blend equation and the alpha blend equation are set to `GL_FUNC_ADD`.
    * 
    * 
    * 
    * 
    * ### Notes:
    * The `GL_MIN`, and `GL_MAX` equations do not use the source or destination factors, only the source and destination colors.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not one of `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MAX`, or `GL_MIN`.
    * 
    * `GL_INVALID_VALUE` is generated by **glBlendEquationi** if **buf** is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.
    * 
    * @param buf for **glBlendEquationi**, specifies the index of the draw buffer for which to set the blend equation.
    * @param mode specifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.

    * @see **`glBlendColor`**, **`glBlendFunc`** **`glBlendFuncSeparate`**

    **/
    static function blendEquation(mode:Int):Void return ExtensionsNative.blendEquation(mode);
    static function blendEquationEXT(mode:Int):Void return ExtensionsNative.blendEquationEXT(mode);
    static function blendEquationIndexedAMD(buf:Int, mode:Int):Void return ExtensionsNative.blendEquationIndexedAMD(buf, mode);
    static function blendEquationOES(mode:Int):Void return ExtensionsNative.blendEquationOES(mode);
    /**
    * - #### Purpose:
    * set the RGB blend equation and the alpha blend equation separately
    * ### Description:
    * The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). These functions specify one blend equation for the RGB-color components and one blend equation for the alpha component. **glBlendEquationSeparatei** specifies the blend equations for a single draw buffer whereas **glBlendEquationSeparate** sets the blend equations for all draw buffers.
    * 
    * The blend equations use the source and destination blend factors specified by either **`glBlendFunc`** or **`glBlendFuncSeparate`**. See **`glBlendFunc`** or **`glBlendFuncSeparate`** for a description of the various blend factors.
    * 
    * In the equations that follow, source and destination color components are referred to as R s G s B s A s and R d G d B d A d, respectively. The result color is referred to as R r G r B r A r. The source and destination blend factors are denoted s R s G s B s A and d R d G d B d A, respectively. For these equations all color components are understood to have values in the range 0 1. Mode RGB Components Alpha Component `GL_FUNC_ADD` Rr = R s &amp;it; s R + R d &amp;it; d R Gr = G s &amp;it; s G + G d &amp;it; d G Br = B s &amp;it; s B + B d &amp;it; d B Ar = A s &amp;it; s A + A d &amp;it; d A `GL_FUNC_SUBTRACT` Rr = R s &amp;it; s R - R d &amp;it; d R Gr = G s &amp;it; s G - G d &amp;it; d G Br = B s &amp;it; s B - B d &amp;it; d B Ar = A s &amp;it; s A - A d &amp;it; d A `GL_FUNC_REVERSE_SUBTRACT` Rr = R d &amp;it; d R - R s &amp;it; s R Gr = G d &amp;it; d G - G s &amp;it; s G Br = B d &amp;it; d B - B s &amp;it; s B Ar = A d &amp;it; d A - A s &amp;it; s A `GL_MIN` Rr = min &amp;af; R s R d Gr = min &amp;af; G s G d Br = min &amp;af; B s B d Ar = min &amp;af; A s A d `GL_MAX` Rr = max &amp;af; R s R d Gr = max &amp;af; G s G d Br = max &amp;af; B s B d Ar = max &amp;af; A s A d
    * 
    * The results of these equations are clamped to the range 0 1.
    * 
    * The `GL_MIN` and `GL_MAX` equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The `GL_FUNC_ADD` equation is useful for antialiasing and transparency, among other things.
    * 
    * Initially, both the RGB blend equation and the alpha blend equation are set to `GL_FUNC_ADD`.
    * 
    * 
    * 
    * 
    * ### Notes:
    * The `GL_MIN`, and `GL_MAX` equations do not use the source or destination factors, only the source and destination colors.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if either **modeRGB** or **modeAlpha** is not one of `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MAX`, or `GL_MIN`.
    * 
    * `GL_INVALID_VALUE` is generated by **glBlendEquationSeparatei** if **buf** is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.
    * 
    * @param buf for **glBlendEquationSeparatei**, specifies the index of the draw buffer for which to set the blend equations.
    * @param modeRGB specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.
    * @param modeAlpha specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.

    * @see **`glGetString`**, **`glBlendColor`**, **`glBlendFunc`**, **`glBlendFuncSeparate`**

    **/
    static function blendEquationSeparate(modeRGB:Int, modeAlpha:Int):Void return ExtensionsNative.blendEquationSeparate(modeRGB, modeAlpha);
    static function blendEquationSeparateEXT(modeRGB:Int, modeAlpha:Int):Void return ExtensionsNative.blendEquationSeparateEXT(modeRGB, modeAlpha);
    static function blendEquationSeparateIndexedAMD(buf:Int, modeRGB:Int, modeAlpha:Int):Void return ExtensionsNative.blendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
    static function blendEquationSeparateOES(modeRGB:Int, modeAlpha:Int):Void return ExtensionsNative.blendEquationSeparateOES(modeRGB, modeAlpha);
    static function blendEquationSeparatei(buf:Int, modeRGB:Int, modeAlpha:Int):Void return ExtensionsNative.blendEquationSeparatei(buf, modeRGB, modeAlpha);
    static function blendEquationSeparateiARB(buf:Int, modeRGB:Int, modeAlpha:Int):Void return ExtensionsNative.blendEquationSeparateiARB(buf, modeRGB, modeAlpha);
    static function blendEquationSeparateiEXT(buf:Int, modeRGB:Int, modeAlpha:Int):Void return ExtensionsNative.blendEquationSeparateiEXT(buf, modeRGB, modeAlpha);
    static function blendEquationSeparateiOES(buf:Int, modeRGB:Int, modeAlpha:Int):Void return ExtensionsNative.blendEquationSeparateiOES(buf, modeRGB, modeAlpha);
    static function blendEquationi(buf:Int, mode:Int):Void return ExtensionsNative.blendEquationi(buf, mode);
    static function blendEquationiARB(buf:Int, mode:Int):Void return ExtensionsNative.blendEquationiARB(buf, mode);
    static function blendEquationiEXT(buf:Int, mode:Int):Void return ExtensionsNative.blendEquationiEXT(buf, mode);
    static function blendEquationiOES(buf:Int, mode:Int):Void return ExtensionsNative.blendEquationiOES(buf, mode);
    /**
    * - #### Purpose:
    * specify pixel arithmetic
    * ### Description:
    * Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use **`glEnable`** and **glDisable** with argument `GL_BLEND` to enable and disable blending.
    * 
    * **glBlendFunc** defines the operation of blending for all draw buffers when it is enabled. **glBlendFunci** defines the operation of blending for a single draw buffer specified by **buf** when enabled for that draw buffer. **sfactor** specifies which method is used to scale the source color components. **dfactor** specifies which method is used to scale the destination color components. Both parameters must be one of the following symbolic constants: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`, `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, `GL_ONE_MINUS_CONSTANT_ALPHA`, `GL_SRC_ALPHA_SATURATE`, `GL_SRC1_COLOR`, `GL_ONE_MINUS_SRC1_COLOR`, `GL_SRC1_ALPHA`, and `GL_ONE_MINUS_SRC1_ALPHA`. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, first source, second source and destination color components are referred to as R s0 G s0 B s0 A s0, R s1 G s1 B s1 A s1 and R d G d B d A d, respectively. The color specified by **`glBlendColor`** is referred to as R c G c B c A c. They are understood to have integer values between 0 and k R k G k B k A, where
    * 
    * k c = 2 m c - 1
    * 
    * and m R m G m B m A is the number of red, green, blue, and alpha bitplanes.
    * 
    * Source and destination scale factors are referred to as s R s G s B s A and d R d G d B d A. The scale factors described in the table, denoted f R f G f B f A, represent either source or destination factors. All scale factors have range 0 1.
    * 
    * 
    * 
    * In the table,
    * 
    * i = min &amp;af; A s k A - A d k A
    * 
    * To determine the blended RGBA values of a pixel, the system uses the following equations:
    * 
    * R d = min &amp;af; k R R s &amp;it; s R + R d &amp;it; d R G d = min &amp;af; k G G s &amp;it; s G + G d &amp;it; d G B d = min &amp;af; k B B s &amp;it; s B + B d &amp;it; d B A d = min &amp;af; k A A s &amp;it; s A + A d &amp;it; d A
    * 
    * Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values.
    * 
    * 
    * 
    * 
    * ### Notes:
    * Incoming (source) alpha would typically be used as a material opacity, ranging from 1.0 (K A), representing complete opacity, to 0.0 (0), representing complete transparency.
    * 
    * When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See **`glDrawBuffer`**.)
    * 
    * When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum number of enabled draw buffers is given by `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`, which may be lower than `GL_MAX_DRAW_BUFFERS`.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if either **sfactor** or **dfactor** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated by **glBlendFunci** if **buf** is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.
    * 
    * @param buf For **glBlendFunci**, specifies the index of the draw buffer for which to set the blend function.
    * @param sfactor Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is `GL_ONE`.
    * @param dfactor Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`.

    * @see **`glBlendColor`**, **`glBlendEquation`**, **`glBlendFuncSeparate`**, **`glClear`**, **`glDrawBuffer`**, **`glEnable`**, **`glLogicOp`**, **`glStencilFunc`**

    **/
    static function blendFunc(sfactor:Int, dfactor:Int):Void return ExtensionsNative.blendFunc(sfactor, dfactor);
    static function blendFuncIndexedAMD(buf:Int, src:Int, dst:Int):Void return ExtensionsNative.blendFuncIndexedAMD(buf, src, dst);
    /**
    * - #### Purpose:
    * specify pixel arithmetic for RGB and alpha components separately
    * ### Description:
    * Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use **`glEnable`** and **glDisable** with argument `GL_BLEND` to enable and disable blending.
    * 
    * **glBlendFuncSeparate** defines the operation of blending for all draw buffers when it is enabled. **glBlendFuncSeparatei** defines the operation of blending for a single draw buffer specified by **buf** when enabled for that draw buffer. **srcRGB** specifies which method is used to scale the source RGB-color components. **dstRGB** specifies which method is used to scale the destination RGB-color components. Likewise, **srcAlpha** specifies which method is used to scale the source alpha color component, and **dstAlpha** specifies which method is used to scale the destination alpha component. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha.
    * 
    * In the table and in subsequent equations, first source, second source and destination color components are referred to as R s0 G s0 B s0 A s0, R s1 G s1 B s1 A s1, and R d G d B d A d, respectively. The color specified by **`glBlendColor`** is referred to as R c G c B c A c. They are understood to have integer values between 0 and k R k G k B k A, where
    * 
    * k c = 2 m c - 1
    * 
    * and m R m G m B m A is the number of red, green, blue, and alpha bitplanes.
    * 
    * Source and destination scale factors are referred to as s R s G s B s A and d R d G d B d A. All scale factors have range 0 1.
    * 
    * 
    * 
    * In the table,
    * 
    * i = min &amp;af; A s 1 - A d
    * 
    * To determine the blended RGBA values of a pixel, the system uses the following equations:
    * 
    * R d = min &amp;af; k R R s &amp;it; s R + R d &amp;it; d R G d = min &amp;af; k G G s &amp;it; s G + G d &amp;it; d G B d = min &amp;af; k B B s &amp;it; s B + B d &amp;it; d B A d = min &amp;af; k A A s &amp;it; s A + A d &amp;it; d A
    * 
    * Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when **srcRGB** is `GL_SRC_ALPHA`, **dstRGB** is `GL_ONE_MINUS_SRC_ALPHA`, and A s is equal to k A, the equations reduce to simple replacement:
    * 
    * R d = R s G d = G s B d = B s A d = A s
    * 
    * 
    * 
    * 
    * ### Notes:
    * Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 (K A), representing complete opacity, to 0.0 (0), representing complete transparency.
    * 
    * When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See **`glDrawBuffer`**.)
    * 
    * When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum number of enabled draw buffers is given by `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`, which may be lower than `GL_MAX_DRAW_BUFFERS`.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if either **srcRGB** or **dstRGB** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated by **glBlendFuncSeparatei** if **buf** is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.
    * 
    * @param buf For **glBlendFuncSeparatei**, specifies the index of the draw buffer for which to set the blend functions.
    * @param srcRGB Specifies how the red, green, and blue blending factors are computed. The initial value is `GL_ONE`.
    * @param dstRGB Specifies how the red, green, and blue destination blending factors are computed. The initial value is `GL_ZERO`.
    * @param srcAlpha Specified how the alpha source blending factor is computed. The initial value is `GL_ONE`.
    * @param dstAlpha Specified how the alpha destination blending factor is computed. The initial value is `GL_ZERO`.

    * @see **`glBlendColor`**, **`glBlendFunc`**, **`glBlendEquation`**, **`glClear`**, **`glDrawBuffer`**, **`glEnable`**, **`glLogicOp`**, **`glStencilFunc`**

    **/
    static function blendFuncSeparate(sfactorRGB:Int, dfactorRGB:Int, sfactorAlpha:Int, dfactorAlpha:Int):Void return ExtensionsNative.blendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    static function blendFuncSeparateEXT(sfactorRGB:Int, dfactorRGB:Int, sfactorAlpha:Int, dfactorAlpha:Int):Void return ExtensionsNative.blendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    static function blendFuncSeparateINGR(sfactorRGB:Int, dfactorRGB:Int, sfactorAlpha:Int, dfactorAlpha:Int):Void return ExtensionsNative.blendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    static function blendFuncSeparateIndexedAMD(buf:Int, srcRGB:Int, dstRGB:Int, srcAlpha:Int, dstAlpha:Int):Void return ExtensionsNative.blendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    static function blendFuncSeparateOES(srcRGB:Int, dstRGB:Int, srcAlpha:Int, dstAlpha:Int):Void return ExtensionsNative.blendFuncSeparateOES(srcRGB, dstRGB, srcAlpha, dstAlpha);
    static function blendFuncSeparatei(buf:Int, srcRGB:Int, dstRGB:Int, srcAlpha:Int, dstAlpha:Int):Void return ExtensionsNative.blendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    static function blendFuncSeparateiARB(buf:Int, srcRGB:Int, dstRGB:Int, srcAlpha:Int, dstAlpha:Int):Void return ExtensionsNative.blendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    static function blendFuncSeparateiEXT(buf:Int, srcRGB:Int, dstRGB:Int, srcAlpha:Int, dstAlpha:Int):Void return ExtensionsNative.blendFuncSeparateiEXT(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    static function blendFuncSeparateiOES(buf:Int, srcRGB:Int, dstRGB:Int, srcAlpha:Int, dstAlpha:Int):Void return ExtensionsNative.blendFuncSeparateiOES(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    static function blendFunci(buf:Int, src:Int, dst:Int):Void return ExtensionsNative.blendFunci(buf, src, dst);
    static function blendFunciARB(buf:Int, src:Int, dst:Int):Void return ExtensionsNative.blendFunciARB(buf, src, dst);
    static function blendFunciEXT(buf:Int, src:Int, dst:Int):Void return ExtensionsNative.blendFunciEXT(buf, src, dst);
    static function blendFunciOES(buf:Int, src:Int, dst:Int):Void return ExtensionsNative.blendFunciOES(buf, src, dst);
    static function blendParameteriNV(pname:Int, value:Int):Void return ExtensionsNative.blendParameteriNV(pname, value);
    /**
    * - #### Purpose:
    * copy a block of pixels from one framebuffer object to another
    * ### Description:
    * **glBlitFramebuffer** and **glBlitNamedFramebuffer** transfer a rectangle of pixel values from one region of a read framebuffer to another region of a draw framebuffer.
    * 
    * For **glBlitFramebuffer**, the read and draw framebuffers are those bound to the `GL_READ_FRAMEBUFFER` and `GL_DRAW_FRAMEBUFFER` targets respectively.
    * 
    * For **glBlitNamedFramebuffer**, **readFramebuffer** and **drawFramebuffer** are the names of the read and draw framebuffer objects respectively. If **readFramebuffer** or **drawFramebuffer** is zero, then the default read or draw framebuffer respectively is used.
    * 
    * **mask** is the bitwise OR of a number of values indicating which buffers are to be copied. The values are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`. The pixels corresponding to these buffers are copied from the source rectangle bounded by the locations (**srcX0**, **srcY0**) and (**srcX1**, **srcY1**) to the destination rectangle bounded by the locations (**dstX0**, **dstY0**) and (**dstX1**, **dstY1**). The lower bounds of the rectangle are inclusive, while the upper bounds are exclusive.
    * 
    * The actual region taken from the read framebuffer is limited to the intersection of the source buffers being transferred, which may include the color buffer selected by the read buffer, the depth buffer, and/or the stencil buffer depending on mask. The actual region written to the draw framebuffer is limited to the intersection of the destination buffers being written, which may include multiple draw buffers, the depth buffer, and/or the stencil buffer depending on mask. Whether or not the source or destination regions are altered due to these limits, the scaling and offset applied to pixels being transferred is performed as though no such limits were present.
    * 
    * If the sizes of the source and destination rectangles are not equal, **filter** specifies the interpolation method that will be applied to resize the source image , and must be `GL_NEAREST` or `GL_LINEAR`. `GL_LINEAR` is only a valid interpolation method for the color buffer. If **filter** is not `GL_NEAREST` and **mask** includes `GL_DEPTH_BUFFER_BIT` or `GL_STENCIL_BUFFER_BIT`, no data is transferred and a `GL_INVALID_OPERATION` error is generated.
    * 
    * If **filter** is `GL_LINEAR` and the source rectangle would require sampling outside the bounds of the source framebuffer, values are read as if the `GL_CLAMP_TO_EDGE` texture wrapping mode were applied.
    * 
    * When the color buffer is transferred, values are taken from the read buffer of the specified read framebuffer and written to each of the draw buffers of the specified draw framebuffer.
    * 
    * If the source and destination rectangles overlap or are the same, and the read and draw buffers are the same, the result of the operation is undefined.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated by **BlitNamedFramebuffer** if **readFramebuffer** or **drawFramebuffer** is not zero or the name of an existing framebuffer object.
    * 
    * `GL_INVALID_OPERATION` is generated if **mask** contains any of the `GL_DEPTH_BUFFER_BIT` or `GL_STENCIL_BUFFER_BIT` and **filter** is not `GL_NEAREST`.
    * 
    * `GL_INVALID_OPERATION` is generated if **mask** contains `GL_COLOR_BUFFER_BIT` and any of the following conditions hold: The read buffer contains fixed-point or floating-point values and any draw buffer contains neither fixed-point nor floating-point values. The read buffer contains unsigned integer values and any draw buffer does not contain unsigned integer values. The read buffer contains signed integer values and any draw buffer does not contain signed integer values.
    * 
    * `GL_INVALID_OPERATION` is generated if **mask** contains `GL_DEPTH_BUFFER_BIT` or `GL_STENCIL_BUFFER_BIT` and the source and destination depth and stencil formats do not match.
    * 
    * `GL_INVALID_OPERATION` is generated if **filter** is `GL_LINEAR` and the read buffer contains integer data.
    * 
    * `GL_INVALID_OPERATION` is generated if both the			read and draw framebuffers are multisampled, and their effective			values of `GL_SAMPLES` are not identical.
    * 
    * `GL_INVALID_OPERATION` is generated if the value of `GL_SAMPLE_BUFFERS` for either read or draw buffers is greater than zero and the dimensions of the source and destination rectangles is not identical.
    * 
    * `GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the specified read and draw framebuffers are not framebuffer complete.
    * 
    * @param readFramebuffer Specifies the name of the source framebuffer object for **glBlitNamedFramebuffer**.
    * @param drawFramebuffer Specifies the name of the destination framebuffer object for **glBlitNamedFramebuffer**.
    * @param srcX0 srcY0 srcX1 srcY1 Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
    * @param dstX0 dstY0 dstX1 dstY1 Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
    * @param mask The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT` and `GL_STENCIL_BUFFER_BIT`.
    * @param filter Specifies the interpolation to be applied if the image is stretched. Must be `GL_NEAREST` or `GL_LINEAR`.

    * @see **`glReadPixels`** **`glCheckFramebufferStatus`**, **`glGenFramebuffers`** **`glBindFramebuffer`** **`glDeleteFramebuffers`**

    **/
    static function blitFramebuffer(srcX0:Int, srcY0:Int, srcX1:Int, srcY1:Int, dstX0:Int, dstY0:Int, dstX1:Int, dstY1:Int, mask:Int, filter:Int):Void return ExtensionsNative.blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    static function blitFramebufferANGLE(srcX0:Int, srcY0:Int, srcX1:Int, srcY1:Int, dstX0:Int, dstY0:Int, dstX1:Int, dstY1:Int, mask:Int, filter:Int):Void return ExtensionsNative.blitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    static function blitFramebufferEXT(srcX0:Int, srcY0:Int, srcX1:Int, srcY1:Int, dstX0:Int, dstY0:Int, dstX1:Int, dstY1:Int, mask:Int, filter:Int):Void return ExtensionsNative.blitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    static function blitFramebufferLayerEXT(srcX0:Int, srcY0:Int, srcX1:Int, srcY1:Int, srcLayer:Int, dstX0:Int, dstY0:Int, dstX1:Int, dstY1:Int, dstLayer:Int, mask:Int, filter:Int):Void return ExtensionsNative.blitFramebufferLayerEXT(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, filter);
    static function blitFramebufferLayersEXT(srcX0:Int, srcY0:Int, srcX1:Int, srcY1:Int, dstX0:Int, dstY0:Int, dstX1:Int, dstY1:Int, mask:Int, filter:Int):Void return ExtensionsNative.blitFramebufferLayersEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    static function blitFramebufferNV(srcX0:Int, srcY0:Int, srcX1:Int, srcY1:Int, dstX0:Int, dstY0:Int, dstX1:Int, dstY1:Int, mask:Int, filter:Int):Void return ExtensionsNative.blitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    static function blitNamedFramebuffer(readFramebuffer:Int, drawFramebuffer:Int, srcX0:Int, srcY0:Int, srcX1:Int, srcY1:Int, dstX0:Int, dstY0:Int, dstX1:Int, dstY1:Int, mask:Int, filter:Int):Void return ExtensionsNative.blitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    static function bufferAddressRangeNV(pname:Int, in_dex:Int, address:Int, length:Int):Void return ExtensionsNative.bufferAddressRangeNV(pname, in_dex, address, length);
    static function bufferAttachMemoryNV(target:Int, memory:Int, offset:Int):Void return ExtensionsNative.bufferAttachMemoryNV(target, memory, offset);
    /**
    * - #### Purpose:
    * creates and initializes a buffer object's data
        store
    * ### Description:
    * **glBufferData** and **glNamedBufferData** create a new data store for a buffer object. In case of **glBufferData**, the buffer object currently bound to **target** is used. For **glNamedBufferData**, a buffer object associated with ID specified by the caller in **buffer** will be used instead.
    * 
    * While creating the new storage, any pre-existing data store is deleted. The new data store is created with the specified **size** in bytes and **usage**. If **data** is not `NULL`, the data store is initialized with data from this pointer. In its initial state, the new data store is not mapped, it has a `NULL` mapped pointer, and its mapped access is `GL_READ_WRITE`.
    * 
    * **usage** is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation to make more intelligent decisions that may significantly impact buffer object performance. It does not, however, constrain the actual usage of the data store. **usage** can be broken down into two parts: first, the frequency of access (modification and usage), and second, the nature of that access. The frequency of access may be one of these:
    * 
    * *`STREAM`* The data store contents will be modified once and used at most a few times.
    * 
    * *`STATIC`* The data store contents will be modified once and used many times.
    * 
    * *`DYNAMIC`* The data store contents will be modified repeatedly and used many times.
    * 
    * The nature of access may be one of these:
    * 
    * *`DRAW`* The data store contents are modified by the application, and used as the source for GL drawing and image specification commands.
    * 
    * *`READ`* The data store contents are modified by reading data from the GL, and used to return that data when queried by the application.
    * 
    * *`COPY`* The data store contents are modified by reading data from the GL, and used as the source for GL drawing and image specification commands.
    * 
    * 
    * ### Notes:
    * If **data** is `NULL`, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
    * 
    * Clients must align data elements consistently with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising N bytes be a multiple of N.
    * 
    * The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.
    * 
    * The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.
    * 
    * The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glBufferData** if **target** is not one of the accepted buffer targets.
    * 
    * `GL_INVALID_ENUM` is generated if **usage** is not `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`.
    * 
    * `GL_INVALID_VALUE` is generated if **size** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated by **glBufferData** if the reserved buffer object name 0 is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glNamedBufferData** if buffer is not the name of an existing buffer object.
    * 
    * `GL_INVALID_OPERATION` is generated if the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer object is `GL_TRUE`.
    * 
    * `GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store with the specified **size**.
    * 
    * @param target Specifies the target to which the buffer object is bound for **glBufferData**, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of the buffer object for **glNamedBufferData** function.
    * @param size Specifies the size in bytes of the buffer object's new data store.
    * @param data Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied.
    * @param usage Specifies the expected usage pattern of the data store. The symbolic constant must be `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`.

    * @see **`glBindBuffer`**, **`glBufferSubData`**, **`glMapBuffer`**, **`glUnmapBuffer`**

    **/
    static function bufferData(target:Int, size:Int, data:DataPointer, usage:Int):Void return ExtensionsNative.bufferData(target, size, data, usage);
    static function bufferDataARB(target:Int, size:Int, data:DataPointer, usage:Int):Void return ExtensionsNative.bufferDataARB(target, size, data, usage);
    static function bufferPageCommitmentARB(target:Int, offset:Int, size:Int, commit:Bool):Void return ExtensionsNative.bufferPageCommitmentARB(target, offset, size, commit);
    static function bufferPageCommitmentMemNV(target:Int, offset:Int, size:Int, memory:Int, memOffset:Int, commit:Bool):Void return ExtensionsNative.bufferPageCommitmentMemNV(target, offset, size, memory, memOffset, commit);
    static function bufferParameteriAPPLE(target:Int, pname:Int, param:Int):Void return ExtensionsNative.bufferParameteriAPPLE(target, pname, param);
    /**
    * - #### Purpose:
    * creates and initializes a buffer object's immutable data
        store
    * ### Description:
    * **glBufferStorage** and **glNamedBufferStorage** create a new immutable data store. For **glBufferStorage**, the buffer object currently bound to **target** will be initialized. For **glNamedBufferStorage**, **buffer** is the name of the buffer object that will be configured. The size of the data store is specified by **size**. If an initial data is available, its address may be supplied in **data**. Otherwise, to create an uninitialized data store, **data** should be `NULL`.
    * 
    * The **flags** parameters specifies the intended usage of the buffer's data store. It must be a bitwise combination of a subset of the following flags: *``GL_DYNAMIC_STORAGE_BIT``* The contents of the data store may be updated after creation through calls to **`glBufferSubData`**. If this bit is not set, the buffer content may not be directly updated by the client. The data argument may be used to specify the initial content of the buffer's data store regardless of the presence of the `GL_DYNAMIC_STORAGE_BIT`. Regardless of the presence of this bit, buffers may always be updated with server-side calls such as **`glCopyBufferSubData`** and **`glClearBufferSubData`**. *``GL_MAP_READ_BIT``* The data store may be mapped by the client for read access and a pointer in the client's address space obtained that may be read from. *``GL_MAP_WRITE_BIT``* The data store may be mapped by the client for write access and a pointer in the client's address space obtained that may be written through. *``GL_MAP_PERSISTENT_BIT``* The client may request that the server read from or write to the buffer while it is mapped. The client's pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands. *``GL_MAP_COHERENT_BIT``* Shared access to buffers that are simultaneously mapped for client access and are used by the server will be coherent, so long as that mapping is performed using **`glMapBufferRange`**. That is, data written to the store by either the client or server will be immediately visible to the other with no further action taken by the application. In particular, If `GL_MAP_COHERENT_BIT` is not set and the client performs a write followed by a call to the **`glMemoryBarrier`** command with the `GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT` set, then in subsequent commands the server will see the writes. If `GL_MAP_COHERENT_BIT` is set and the client performs a write, then in subsequent commands the server will see the writes. If `GL_MAP_COHERENT_BIT` is not set and the server performs a write, the application must call **`glMemoryBarrier`** with the `GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT` set and then call **`glFenceSync`** with `GL_SYNC_GPU_COMMANDS_COMPLETE` (or **glFinish**). Then the CPU will see the writes after the sync is complete. If `GL_MAP_COHERENT_BIT` is set and the server does a write, the app must call **glFenceSync** with `GL_SYNC_GPU_COMMANDS_COMPLETE` (or **`glFinish`**). Then the CPU will see the writes after the sync is complete. *``GL_CLIENT_STORAGE_BIT``* When all other criteria for the buffer storage allocation are met, this bit may be used by an implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.
    * 
    * The allowed combinations of flags are subject to certain restrictions. They are as follows: If **flags** contains `GL_MAP_PERSISTENT_BIT`, it must also contain at least one of `GL_MAP_READ_BIT` or `GL_MAP_WRITE_BIT`. If **flags** contains `GL_MAP_COHERENT_BIT`, it must also contain `GL_MAP_PERSISTENT_BIT`.
    * 
    * 
    * ### Notes:
    * **glBufferStorage** is available only if the GL version is 4.4 or greater.
    * 
    * **glNamedBufferStorage** is available only if the GL version is 4.5 or greater.
    * 
    * If **data** is `NULL`, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glBufferStorage** if **target** is not one of the accepted buffer targets.
    * 
    * `GL_INVALID_OPERATION` is generated by **glNamedBufferStorage** if buffer is not the name of an existing buffer object.
    * 
    * `GL_INVALID_VALUE` is generated if **size** is less than or equal to zero.
    * 
    * `GL_INVALID_OPERATION` is generated by **glBufferStorage** if the reserved buffer object name 0 is bound to **target**.
    * 
    * `GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store with the properties requested in **flags**.
    * 
    * `GL_INVALID_VALUE` is generated if **flags** has any bits set other than those defined above.
    * 
    * `GL_INVALID_VALUE` error is generated if **flags** contains `GL_MAP_PERSISTENT_BIT` but does not contain at least one of `GL_MAP_READ_BIT` or `GL_MAP_WRITE_BIT`.
    * 
    * `GL_INVALID_VALUE` is generated if **flags** contains `GL_MAP_COHERENT_BIT`, but does not also contain `GL_MAP_PERSISTENT_BIT`.
    * 
    * `GL_INVALID_OPERATION` is generated by **glBufferStorage** if the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer bound to **target** is `GL_TRUE`.
    * 
    * @param target Specifies the target to which the buffer object is bound for **glBufferStorage**, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of the buffer object for **glNamedBufferStorage** function.
    * @param size Specifies the size in bytes of the buffer object's new data store.
    * @param data Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied.
    * @param flags Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. `GL_DYNAMIC_STORAGE_BIT`, `GL_MAP_READ_BIT` `GL_MAP_WRITE_BIT`, `GL_MAP_PERSISTENT_BIT`, `GL_MAP_COHERENT_BIT`, and `GL_CLIENT_STORAGE_BIT`.

    * @see **`glBindBuffer`**, **`glBufferSubData`**, **`glMapBuffer`**, **`glUnmapBuffer`**

    **/
    static function bufferStorage(target:Int, size:Int, data:DataPointer, flags:Int):Void return ExtensionsNative.bufferStorage(target, size, data, flags);
    static function bufferStorageEXT(target:Int, size:Int, data:DataPointer, flags:Int):Void return ExtensionsNative.bufferStorageEXT(target, size, data, flags);
    static function bufferStorageExternalEXT(target:Int, offset:Int, size:Int, clientBuffer:DataPointer, flags:Int):Void return ExtensionsNative.bufferStorageExternalEXT(target, offset, size, clientBuffer, flags);
    static function bufferStorageMemEXT(target:Int, size:Int, memory:Int, offset:Int):Void return ExtensionsNative.bufferStorageMemEXT(target, size, memory, offset);
    /**
    * - #### Purpose:
    * updates a subset of a buffer object's data store
    * ### Description:
    * **glBufferSubData** and **glNamedBufferSubData** redefine some or all of the data store for the specified buffer object. Data starting at byte offset **offset** and extending for **size** bytes is copied to the data store from the memory pointed to by **data**. **offset** and **size** must define a range lying entirely within the buffer object's data store.
    * 
    * 
    * ### Notes:
    * When replacing the entire data store, consider using **glBufferSubData** rather than completely recreating the data store with **glBufferData**. This avoids the cost of reallocating the data store.
    * 
    * Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering in the pipeline makes reference to data in the buffer object being updated by **glBufferSubData**, especially from the specific region being updated, that rendering must drain from the pipeline before the data store can be updated.
    * 
    * Clients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising $N$ bytes be a multiple of $N$.
    * 
    * The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.
    * 
    * The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.
    * 
    * The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glBufferSubData** if **target** is not one of the accepted buffer targets.
    * 
    * `GL_INVALID_OPERATION` is generated by **glBufferSubData** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glNamedBufferSubData** if **buffer** is not the name of an existing buffer object.
    * 
    * `GL_INVALID_VALUE` is generated if **offset** or **size** is negative, or if $offset + size$ is greater than the value of `GL_BUFFER_SIZE` for the specified buffer object.
    * 
    * `GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is mapped with **`glMapBufferRange`** or **`glMapBuffer`**, unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the **glMapBufferRange** **access** flags.
    * 
    * `GL_INVALID_OPERATION` is generated if the value of the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer object is `GL_TRUE` and the value of `GL_BUFFER_STORAGE_FLAGS` for the buffer object does not have the `GL_DYNAMIC_STORAGE_BIT` bit set.
    * 
    * @param target Specifies the target to which the buffer object is bound for **glBufferSubData**, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of the buffer object for **glNamedBufferSubData**.
    * @param offset Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
    * @param size Specifies the size in bytes of the data store region being replaced.
    * @param data Specifies a pointer to the new data that will be copied into the data store.

    * @see **`glBindBuffer`**, **`glBufferData`**, **`glMapBuffer`**, **`glMapBufferRange`**, **`glUnmapBuffer`**

    **/
    static function bufferSubData(target:Int, offset:Int, size:Int, data:DataPointer):Void return ExtensionsNative.bufferSubData(target, offset, size, data);
    static function bufferSubDataARB(target:Int, offset:Int, size:Int, data:DataPointer):Void return ExtensionsNative.bufferSubDataARB(target, offset, size, data);
    static function callCommandListNV(list:Int):Void return ExtensionsNative.callCommandListNV(list);
    static function callList(list:Int):Void return ExtensionsNative.callList(list);
    static function callLists(n:Int, type:Int, lists:DataPointer):Void return ExtensionsNative.callLists(n, type, lists);
    /**
    * - #### Purpose:
    * check the completeness status of a framebuffer
    * ### Description:
    * **glCheckFramebufferStatus** and **glCheckNamedFramebufferStatus** return the completeness status of a framebuffer object when treated as a read or draw framebuffer, depending on the value of **target**.
    * 
    * For **glCheckFramebufferStatus**, the framebuffer checked is that bound to **target**, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.
    * 
    * For **glCheckNamedFramebufferStatus**, **framebuffer** is zero or the name of the framebuffer object to check. If **framebuffer** is zero, then the status of the default read or draw framebuffer, as determined by **target**, is returned.
    * 
    * The return value is `GL_FRAMEBUFFER_COMPLETE` if the specified framebuffer is complete. Otherwise, the return value is determined as follows: `GL_FRAMEBUFFER_UNDEFINED` is returned if the specified framebuffer is the default read or draw framebuffer, but the default framebuffer does not exist. `GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT` is returned if any of the framebuffer attachment points are framebuffer incomplete. `GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT` is returned if the framebuffer does not have at least one image attached to it. `GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER` is returned if the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE` for any color attachment point(s) named by `GL_DRAW_BUFFERi`. `GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER` is returned if `GL_READ_BUFFER` is not `GL_NONE` and the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE` for the color attachment point named by `GL_READ_BUFFER`. `GL_FRAMEBUFFER_UNSUPPORTED` is returned if the combination of internal formats of the attached images violates an implementation-dependent set of restrictions. `GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE` is returned if the value of `GL_RENDERBUFFER_SAMPLES` is not the same for all attached renderbuffers; if the value of `GL_TEXTURE_SAMPLES` is the not same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of `GL_RENDERBUFFER_SAMPLES` does not match the value of `GL_TEXTURE_SAMPLES`. `GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE` is also returned if the value of `GL_TEXTURE_FIXED_SAMPLE_LOCATIONS` is not the same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of `GL_TEXTURE_FIXED_SAMPLE_LOCATIONS` is not `GL_TRUE` for all attached textures. `GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS` is returned if any framebuffer attachment is layered, and any populated attachment is not layered, or if all populated color attachments are not from textures of the same target.
    * 
    * Additionally, if an error occurs, zero is returned.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`.
    * 
    * `GL_INVALID_OPERATION` is generated by **glCheckNamedFramebufferStatus** if **framebuffer** is not zero or the name of an existing framebuffer object.
    * 
    * @param target Specify the target to which the framebuffer is bound for **glCheckFramebufferStatus**, and the target against which framebuffer completeness of **framebuffer** is checked for **glCheckNamedFramebufferStatus**.
    * @param framebuffer Specifies the name of the framebuffer object for **glCheckNamedFramebufferStatus**

    * @see **`glGenFramebuffers`**, **`glDeleteFramebuffers`** **`glBindFramebuffer`**

    **/
    static function checkFramebufferStatus(target:Int):Int return ExtensionsNative.checkFramebufferStatus(target);
    static function checkFramebufferStatusEXT(target:Int):Int return ExtensionsNative.checkFramebufferStatusEXT(target);
    static function checkFramebufferStatusOES(target:Int):Int return ExtensionsNative.checkFramebufferStatusOES(target);
    static function checkNamedFramebufferStatus(framebuffer:Int, target:Int):Int return ExtensionsNative.checkNamedFramebufferStatus(framebuffer, target);
    static function checkNamedFramebufferStatusEXT(framebuffer:Int, target:Int):Int return ExtensionsNative.checkNamedFramebufferStatusEXT(framebuffer, target);
    /**
    * - #### Purpose:
    * specify whether data read via
    * ### Description:
    * **glClampColor** controls color clamping that is performed during **`glReadPixels`**. **target** must be `GL_CLAMP_READ_COLOR`. If **clamp** is `GL_TRUE`, read color clamping is enabled; if **clamp** is `GL_FALSE`, read color clamping is disabled. If **clamp** is `GL_FIXED_ONLY`, read color clamping is enabled only if the selected read buffer has fixed point components and disabled otherwise.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_CLAMP_READ_COLOR`.
    * 
    * `GL_INVALID_ENUM` is generated if **clamp** is not `GL_TRUE` or `GL_FALSE`.
    * 
    * @param target Target for color clamping. **target** must be `GL_CLAMP_READ_COLOR`.
    * @param clamp Specifies whether to apply color clamping. **clamp** must be `GL_TRUE` or `GL_FALSE`.

    * @see **/
    static function clampColor(target:Int, clamp:Int):Void return ExtensionsNative.clampColor(target, clamp);
    static function clampColorARB(target:Int, clamp:Int):Void return ExtensionsNative.clampColorARB(target, clamp);
    /**
    * - #### Purpose:
    * clear buffers to preset values
    * ### Description:
    * **glClear** sets the bitplane area of the window to values previously selected by **glClearColor**, **glClearDepth**, and **glClearStencil**. Multiple color buffers can be cleared simultaneously by selecting more than one buffer at a time using **`glDrawBuffer`**.
    * 
    * The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of **glClear**. The scissor box bounds the cleared region. Alpha function, blend function, logical operation, stenciling, texture mapping, and depth-buffering are ignored by **glClear**.
    * 
    * **glClear** takes a single argument that is the bitwise OR of several values indicating which buffer is to be cleared.
    * 
    * The values are as follows:
    * 
    * *``GL_COLOR_BUFFER_BIT``* Indicates the buffers currently enabled for color writing.
    * 
    * *``GL_DEPTH_BUFFER_BIT``* Indicates the depth buffer.
    * 
    * *``GL_STENCIL_BUFFER_BIT``* Indicates the stencil buffer.
    * 
    * The value to which each buffer is cleared depends on the setting of the clear value for that buffer.
    * 
    * 
    * ### Notes:
    * If a buffer is not present, then a **glClear** directed at that buffer has no effect.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if any bit other than the three defined bits is set in **mask**.
    * 
    * @param mask Bitwise OR of masks that indicate the buffers to be cleared. The three masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`.

    * @see **glClearColor**, **glClearDepth**, **glClearStencil**, **`glColorMask`**, **`glDepthMask`**, **`glDrawBuffer`**, **`glScissor`**, **`glStencilMask`**

    **/
    static function clear(mask:Int):Void return ExtensionsNative.clear(mask);
    static function clearAccum(red:Float, green:Float, blue:Float, alpha:Float):Void return ExtensionsNative.clearAccum(red, green, blue, alpha);
    static function clearAccumxOES(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.clearAccumxOES(red, green, blue, alpha);
    /**
    * - #### Purpose:
    * fill a buffer object's data store with a fixed value
    * ### Description:
    * **glClearBufferData** and **glClearNamedBufferData** fill the entirety of a buffer object's data store with data from client memory.
    * 
    * Data, initially supplied in a format specified by **format** in data type **type** is read from the memory address given by **data** and converted into the internal representation given by **internalformat**, which must be one of the following sized internal formats:
    * 
    * This converted data is then replicated throughout the buffer object's data store. If **data** is NULL, then the buffer's data store is filled with zeros.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glClearBufferData** if **target** is not one of the generic buffer binding targets.
    * 
    * `GL_INVALID_VALUE` is generated by **glClearBufferData** if no buffer is bound **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glClearNamedBufferData** if **buffer** is not the name of an existing buffer object.
    * 
    * `GL_INVALID_ENUM` is generated if **internalformat** is not one of the valid sized internal formats listed in the table above.
    * 
    * `GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is mapped with **`glMapBufferRange`** or **`glMapBuffer`**, unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the **glMapBufferRange** **access** flags.
    * 
    * `GL_INVALID_VALUE` is generated if **format** is not a valid format, or **type** is not a valid type.
    * 
    * @param target Specifies the target to which the buffer object is bound for **glClearBufferData**, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of the buffer object for **glClearNamedBufferData**.
    * @param internalformat The internal format with which the data will be stored in the buffer object.
    * @param format The format of the data in memory addressed by **data**.
    * @param type The type of the data in memory addressed by **data**.
    * @param data The address of a memory location storing the data to be replicated into the buffer's data store.

    * @see **`glClearBufferSubData`**.

    **/
    static function clearBufferData(target:Int, in_ternalformat:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.clearBufferData(target, in_ternalformat, format, type, data);
    /**
    * - #### Purpose:
    * fill all or part of buffer object's data store with a fixed value
    * ### Description:
    * **glClearBufferSubData** and **glClearNamedBufferSubData** fill a specified region of a buffer object's data store with data from client memory.
    * 
    * **offset** and **size** specify the extent of the region within the data store of the buffer object to fill with data. Data, initially supplied in a format specified by **format** in data type **type** is read from the memory address given by **data** and converted into the internal representation given by **internalformat**, which must be one of the following sized internal formats:
    * 
    * This converted data is then replicated throughout the specified region of the buffer object's data store. If **data** is NULL, then the subrange of the buffer's data store is filled with zeros.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glClearBufferSubData** if **target** is not one of the generic buffer binding targets.
    * 
    * `GL_INVALID_VALUE` is generated by **glClearBufferSubData** if no buffer is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glClearNamedBufferSubData** if **buffer** is not the name of an existing buffer object.
    * 
    * `GL_INVALID_ENUM` is generated if **internalformat** is not one of the valid sized internal formats listed in the table above.
    * 
    * `GL_INVALID_VALUE` is generated if **offset** or **range** are not multiples of the number of basic machine units per-element for the internal format specified by **internalformat**. This value may be computed by multiplying the number of components for **internalformat** from the table by the size of the base type from the table.
    * 
    * `GL_INVALID_VALUE` is generated if **offset** or **size** is negative, or if $offset + size$ is greater than the value of `GL_BUFFER_SIZE` for the buffer object.
    * 
    * `GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is mapped with **`glMapBufferRange`** or **`glMapBuffer`**, unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the **glMapBufferRange** **access** flags.
    * 
    * `GL_INVALID_VALUE` is generated if **format** is not a valid format, or **type** is not a valid type.
    * 
    * @param target Specifies the target to which the buffer object is bound for **glClearBufferSubData**, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of the buffer object for **glClearNamedBufferSubData**.
    * @param internalformat The internal format with which the data will be stored in the buffer object.
    * @param offset The offset in basic machine units into the buffer object's data store at which to start filling.
    * @param size The size in basic machine units of the range of the data store to fill.
    * @param format The format of the data in memory addressed by **data**.
    * @param type The type of the data in memory addressed by **data**.
    * @param data The address of a memory location storing the data to be replicated into the buffer's data store.

    * @see **`glClearBufferData`**.

    **/
    static function clearBufferSubData(target:Int, in_ternalformat:Int, offset:Int, size:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.clearBufferSubData(target, in_ternalformat, offset, size, format, type, data);
    static function clearBufferfi(buffer:Int, drawbuffer:Int, depth:Float, stencil:Int):Void return ExtensionsNative.clearBufferfi(buffer, drawbuffer, depth, stencil);
    static function clearBufferfv(buffer:Int, drawbuffer:Int, value:DataPointer):Void return ExtensionsNative.clearBufferfv(buffer, drawbuffer, value);
    static function clearBufferiv(buffer:Int, drawbuffer:Int, value:DataPointer):Void return ExtensionsNative.clearBufferiv(buffer, drawbuffer, value);
    static function clearBufferuiv(buffer:Int, drawbuffer:Int, value:DataPointer):Void return ExtensionsNative.clearBufferuiv(buffer, drawbuffer, value);
    /**
    * - #### Purpose:
    * specify clear values for the color buffers
    * ### Description:
    * **glClearColor** specifies the red, green, blue, and alpha values used by **`glClear`** to clear the color buffers. Values specified by **glClearColor** are clamped to the range 0 1.
    * 
    * 
    * ### Notes:
    * The type of the **red**, **green**, **blue**, and **alpha** parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the **`removedTypes`** page.
    * 
    * 
    * ### Errors:
    * @param red green blue alpha Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.

    * @see **`glClear`**, **`removedTypes`**

    **/
    static function clearColor(red:Float, green:Float, blue:Float, alpha:Float):Void return ExtensionsNative.clearColor(red, green, blue, alpha);
    static function clearColorIiEXT(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.clearColorIiEXT(red, green, blue, alpha);
    static function clearColorIuiEXT(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.clearColorIuiEXT(red, green, blue, alpha);
    static function clearColorx(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.clearColorx(red, green, blue, alpha);
    static function clearColorxOES(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.clearColorxOES(red, green, blue, alpha);
    /**
    * - #### Purpose:
    * specify the clear value for the depth buffer
    * ### Description:
    * **glClearDepth** specifies the depth value used by **`glClear`** to clear the depth buffer. Values specified by **glClearDepth** are clamped to the range 0 1.
    * 
    * 
    * ### Notes:
    * The type of the **depth** parameter was changed from GLclampf to GLfloat for **glClearDepthf** and from GLclampd to GLdouble for **glClearDepth**. This change is transparent to user code and is described in detail on the **`removedTypes`** page.
    * 
    * 
    * ### Errors:
    * @param depth Specifies the depth value used when the depth buffer is cleared. The initial value is 1.

    * @see **`glClear`**, **`removedTypes`**

    **/
    static function clearDepth(depth:DataPointer):Void return ExtensionsNative.clearDepth(depth);
    static function clearDepthdNV(depth:DataPointer):Void return ExtensionsNative.clearDepthdNV(depth);
    static function clearDepthf(d:Float):Void return ExtensionsNative.clearDepthf(d);
    static function clearDepthfOES(depth:Float):Void return ExtensionsNative.clearDepthfOES(depth);
    static function clearDepthx(depth:Int):Void return ExtensionsNative.clearDepthx(depth);
    static function clearDepthxOES(depth:Int):Void return ExtensionsNative.clearDepthxOES(depth);
    static function clearIndex(c:Float):Void return ExtensionsNative.clearIndex(c);
    static function clearNamedBufferData(buffer:Int, in_ternalformat:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.clearNamedBufferData(buffer, in_ternalformat, format, type, data);
    static function clearNamedBufferDataEXT(buffer:Int, in_ternalformat:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.clearNamedBufferDataEXT(buffer, in_ternalformat, format, type, data);
    static function clearNamedBufferSubData(buffer:Int, in_ternalformat:Int, offset:Int, size:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.clearNamedBufferSubData(buffer, in_ternalformat, offset, size, format, type, data);
    static function clearNamedBufferSubDataEXT(buffer:Int, in_ternalformat:Int, offset:Int, size:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.clearNamedBufferSubDataEXT(buffer, in_ternalformat, offset, size, format, type, data);
    static function clearNamedFramebufferfi(framebuffer:Int, buffer:Int, drawbuffer:Int, depth:Float, stencil:Int):Void return ExtensionsNative.clearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);
    static function clearNamedFramebufferfv(framebuffer:Int, buffer:Int, drawbuffer:Int, value:DataPointer):Void return ExtensionsNative.clearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value);
    static function clearNamedFramebufferiv(framebuffer:Int, buffer:Int, drawbuffer:Int, value:DataPointer):Void return ExtensionsNative.clearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value);
    static function clearNamedFramebufferuiv(framebuffer:Int, buffer:Int, drawbuffer:Int, value:DataPointer):Void return ExtensionsNative.clearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value);
    static function clearPixelLocalStorageuiEXT(offset:Int, n:Int, values:DataPointer):Void return ExtensionsNative.clearPixelLocalStorageuiEXT(offset, n, values);
    /**
    * - #### Purpose:
    * specify the clear value for the stencil buffer
    * ### Description:
    * **glClearStencil** specifies the index used by **`glClear`** to clear the stencil buffer. **s** is masked with 2 m - 1, where m is the number of bits in the stencil buffer.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param s Specifies the index used when the stencil buffer is cleared. The initial value is 0.

    * @see **`glClear`**, **`glStencilFunc`**, **`glStencilFuncSeparate`**, **`glStencilMask`**, **`glStencilMaskSeparate`**, **`glStencilOp`**, **`glStencilOpSeparate`**

    **/
    static function clearStencil(s:Int):Void return ExtensionsNative.clearStencil(s);
    /**
    * - #### Purpose:
    * fills all a texture image with a constant value
    * ### Description:
    * **glClearTexImage** fills all an image contained in a texture with an application supplied value. **texture** must be the name of an existing texture. Further, **texture** may not be the name of a buffer texture, nor may its internal format be compressed.
    * 
    * **format** and **type** specify the format and type of the source data and are interpreted as they are for **`glTexImage3D`**. Textures with a base internal format of `GL_DEPTH_COMPONENT`, `GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL` require depth component, stencil, or depth-stencil component data respectively. Textures with other base internal formats require RGBA formats. Textures with integer internal formats require integer data.
    * 
    * **data** is a pointer to an array of between one and four components of texel data that will be used as the source for the constant fill value. The elements of data are converted by the GL into the internal format of the texture image (that was specified when the level was defined by any of the **glTexImage***, **glTexStorage*** or **glCopyTexImage*** commands), and then used to fill the specified range of the destination texture level. If **data** is `NULL`, then the pointer is ignored and the sub-range of the texture image is filled with zeros. If texture is a multisample texture, all the samples in a texel are cleared to the value specified by data.
    * 
    * 
    * ### Notes:
    * **glClearTexImage** is available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **texture** is zero or not the name of an existing texture object.
    * 
    * `GL_INVALID_OPERATION` is generated if **texture** is a buffer texture.
    * 
    * `GL_INVALID_OPERATION` is generated if **texture** has a compressed internal format.
    * 
    * `GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_COMPONENT` and **format** is not `GL_DEPTH_COMPONENT`.
    * 
    * `GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_STENCIL` and **format** is not `GL_DEPTH_STENCIL`.
    * 
    * `GL_INVALID_OPERATION` is generated if the base internal format is `GL_STENCIL_INDEX` and **format** is not `GL_STENCIL_INDEX`.
    * 
    * `GL_INVALID_OPERATION` is generated if the base internal format is `GL_RGBA` and **format** is `GL_DEPTH_COMPONENT`, `GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL`.
    * 
    * `GL_INVALID_OPERATION` is generated if the internal format is integer and **format** does not specify integer data.
    * 
    * `GL_INVALID_OPERATION` is generated if the internal format is not integer and **format** specifies integer data.
    * 
    * `GL_INVALID_OPERATION` is generated if the image array identified by **level** has not previously been defined by a call to **glTexImage*** or **glTexStorage***.
    * 
    * @param texture The name of an existing texture object containing the image to be cleared.
    * @param level The level of **texture** containing the region to be cleared.
    * @param format The format of the data whose address in memory is given by **data**.
    * @param type The type of the data whose address in memory is given by **data**.
    * @param data The address in memory of the data to be used to clear the specified region.

    * @see **`glClearTexSubImage`**, **`glTexStorage1D`**, **`glTexStorage2D`**, **`glTexStorage3D`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**

    **/
    static function clearTexImage(texture:Int, level:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.clearTexImage(texture, level, format, type, data);
    static function clearTexImageEXT(texture:Int, level:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.clearTexImageEXT(texture, level, format, type, data);
    /**
    * - #### Purpose:
    * fills all or part of a texture image with a constant value
    * ### Description:
    * **glClearTexSubImage** fills all or part of an image contained in a texture with an application supplied value. **texture** must be the name of an existing texture. Further, **texture** may not be the name of a buffer texture, nor may its internal format be compressed.
    * 
    * Arguments **xoffset**, **yoffset**, and **zoffset** specify the lower left texel coordinates of a width-wide by height-high by depth-deep rectangular subregion of the texel array.
    * 
    * For one-dimensional array textures, **yoffset** is interpreted as the first layer to be cleared and **height** is the number of layers to clear. For two-dimensional array textures, **zoffset** is interpreted as the first layer to be cleared and **depth** is the number of layers to clear. Cube map textures are treated as an array of six slices in the z-dimension, where the value of **zoffset** is interpreted as specifying the cube map face for the corresponding layer and **depth** is the number of faces to clear. For cube map array textures, **zoffset** is the first layer-face to clear, and **depth** is the number of layer-faces to clear. Each layer-face is translated into an array layer and a cube map face as described in the OpenGL Specification.
    * 
    * Negative values of **xoffset**, **yoffset**, and **zoffset** correspond to the coordinates of border texels. Taking ws, hs, ds, wb, hb, and db to be the specified **width**, **height**, **depth**, and the border width, border height, and border depth of the texel array and taking x, y, z, w, h, and d to be the **xoffset**, **yoffset**, **zoffset**, **width**, **height**, and **depth** argument values, any of the following relationships generates a `GL_INVALID_OPERATION` error: x &lt; w b x + w &gt; w s - w b y &lt; - h b y + h &gt; h s - h b z &lt; - d b z + d &gt; d s - d b
    * 
    * For texture types that do not have certain dimensions, this command treats those dimensions as having a size of 1. For example, to clear a portion of a two-dimensional texture, use **zoffset** equal to zero and **depth** equal to one.
    * 
    * **format** and **type** specify the format and type of the source data and are interpreted as they are for **`glTexImage3D`**. Textures with a base internal format of `GL_DEPTH_COMPONENT`, `GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL` require depth component, stencil, or depth-stencil component data respectively. Textures with other base internal formats require RGBA formats. Textures with integer internal formats require integer data.
    * 
    * **data** is a pointer to an array of between one and four components of texel data that will be used as the source for the constant fill value. The elements of data are converted by the GL into the internal format of the texture image (that was specified when the level was defined by any of the **glTexImage***, **glTexStorage*** or **glCopyTexImage*** commands), and then used to fill the specified range of the destination texture level. If **data** is `NULL`, then the pointer is ignored and the sub-range of the texture image is filled with zeros. If texture is a multisample texture, all the samples in a texel are cleared to the value specified by data.
    * 
    * 
    * ### Notes:
    * **glClearTexSubImage** is available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **texture** is zero or not the name of an existing texture object.
    * 
    * `GL_INVALID_OPERATION` is generated if **texture** is a buffer texture.
    * 
    * `GL_INVALID_OPERATION` is generated if **texture** has a compressed internal format.
    * 
    * `GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_COMPONENT` and **format** is not `GL_DEPTH_COMPONENT`.
    * 
    * `GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_STENCIL` and **format** is not `GL_DEPTH_STENCIL`.
    * 
    * `GL_INVALID_OPERATION` is generated if the base internal format is `GL_STENCIL_INDEX` and **format** is not `GL_STENCIL_INDEX`.
    * 
    * `GL_INVALID_OPERATION` is generated if the base internal format is `GL_RGBA` and **format** is `GL_DEPTH_COMPONENT`, `GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL`.
    * 
    * `GL_INVALID_OPERATION` is generated if the internal format is integer and **format** does not specify integer data.
    * 
    * `GL_INVALID_OPERATION` is generated if the internal format is not integer and **format** specifies integer data.
    * 
    * `GL_INVALID_OPERATION` error is generated if the **xoffset**, **yoffset**, **zoffset**, **width**, **height**, and **depth** parameters (or combinations thereof) specify a region that falls outside the defined texture image array (including border, if any).
    * 
    * @param texture The name of an existing texture object containing the image to be cleared.
    * @param level The level of **texture** containing the region to be cleared.
    * @param xoffset The coordinate of the left edge of the region to be cleared.
    * @param yoffset The coordinate of the lower edge of the region to be cleared.
    * @param zoffset The coordinate of the front of the region to be cleared.
    * @param width The width of the region to be cleared.
    * @param height The height of the region to be cleared.
    * @param depth The depth of the region to be cleared.
    * @param format The format of the data whose address in memory is given by **data**.
    * @param type The type of the data whose address in memory is given by **data**.
    * @param data The address in memory of the data to be used to clear the specified region.

    * @see **`glClearTexImage`**, **`glTexStorage1D`**, **`glTexStorage2D`**, **`glTexStorage3D`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**

    **/
    static function clearTexSubImage(texture:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.clearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
    static function clearTexSubImageEXT(texture:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.clearTexSubImageEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
    static function clientActiveTexture(texture:Int):Void return ExtensionsNative.clientActiveTexture(texture);
    static function clientActiveTextureARB(texture:Int):Void return ExtensionsNative.clientActiveTextureARB(texture);
    static function clientActiveVertexStreamATI(stream:Int):Void return ExtensionsNative.clientActiveVertexStreamATI(stream);
    static function clientAttribDefaultEXT(mask:Int):Void return ExtensionsNative.clientAttribDefaultEXT(mask);
    static function clientWaitSemaphoreui64NVX(fenceObjectCount:Int, semaphoreArray:DataPointer, fenceValueArray:DataPointer):Void return ExtensionsNative.clientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray, fenceValueArray);
    /**
    * - #### Purpose:
    * block and wait for a sync object to become signaled
    * ### Description:
    * **glClientWaitSync** causes the client to block and wait for the sync object specified by **sync** to become signaled. If **sync** is signaled when **glClientWaitSync** is called, **glClientWaitSync** returns immediately, otherwise it will block and wait for up to **timeout** nanoseconds for **sync** to become signaled.
    * 
    * The return value is one of four status values: `GL_ALREADY_SIGNALED` indicates that **sync** was signaled at the time that **glClientWaitSync** was called. `GL_TIMEOUT_EXPIRED` indicates that at least **timeout** nanoseconds passed and **sync** did not become signaled. `GL_CONDITION_SATISFIED` indicates that **sync** was signaled before the timeout expired. `GL_WAIT_FAILED` indicates that an error occurred. Additionally, an OpenGL error will be generated.
    * 
    * 
    * ### Notes:
    * **glClientWaitSync** is available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **sync** is not the name of an existing sync object.
    * 
    * `GL_INVALID_VALUE` is generated if **flags** contains any unsupported flag.
    * 
    * @param sync The sync object whose status to wait on.
    * @param flags A bitfield controlling the command flushing behavior. **flags** may be `GL_SYNC_FLUSH_COMMANDS_BIT`.
    * @param timeout The timeout, specified in nanoseconds, for which the implementation should wait for **sync** to become signaled.

    * @see **`glFenceSync`**, **`glIsSync`** **`glWaitSync`**

    **/
    static function clientWaitSync(sync:DataPointer, flags:Int, timeout:Int):Int return ExtensionsNative.clientWaitSync(sync, flags, timeout);
    static function clientWaitSyncAPPLE(sync:DataPointer, flags:Int, timeout:Int):Int return ExtensionsNative.clientWaitSyncAPPLE(sync, flags, timeout);
    /**
    * - #### Purpose:
    * control clip coordinate to window coordinate behavior
    * ### Description:
    * **glClipControl** controls the clipping volume behavior and the clip coordinate to window coordinate transformation behavior.
    * 
    * The view volume is defined by $$z_{min} \leq z_c \leq w_c$$ where $z_{min} = -w_c$ when **depth** is `GL_NEGATIVE_ONE_TO_ONE`, and $z_{min} = 0$ when **depth** is `GL_ZERO_TO_ONE`.
    * 
    * The normalized device coordinate $y_d$ is given by $$y_d = { { f \times y_c } \over w_c }$$ where $f = 1$ when **origin** is `GL_LOWER_LEFT`, and $f = -1$ when **origin** is `GL_UPPER_LEFT`.
    * 
    * The window coordinate $z_w$ is given by $$z_w = s \times z_d + b$$ where $s = { { f - n } \over 2 }$ and $b = { {n + f} \over 2 }$ when **depth** is `GL_NEGATIVE_ONE_TO_ONE`, and $s = f - n$ and $b = n$ when **depth** is `GL_ZERO_TO_ONE`. $n$ and $f$ are the near and far depth range values set with **`glDepthRange`**.
    * 
    * Finally, the polygon area computation defined by **`gl_FrontFacing`** to determine if a polygon is front- or back-facing has its sign negated when **origin** is `GL_UPPER_LEFT`.
    * 
    * 
    * ### Notes:
    * The default GL clip volume definition is for a **origin** of `GL_LOWER_LEFT` and a **depth** of `GL_NEGATIVE_ONE_TO_ONE`.
    * 
    * An **origin** of `GL_UPPER_LEFT` and a **depth** of `GL_ZERO_TO_ONE` corresponds to Direct3D's clip volume definition.
    * 
    * An **origin** of `GL_UPPER_LEFT` and a **depth** of `GL_NEGATIVE_ONE_TO_ONE` corresponds to the upper-left origin of the window coordinate system of Microsoft Windows and the X Window System.
    * 
    * There is extensive discussion of the uses and further consequences of the different clip volume settings in the GL_ARB_clip_control extension specification in the OpenGL Registry at URL http://www.opengl.org/registry/.
    * 
    * 
    * ### Errors:
    * An `GL_INVALID_ENUM` error is generated if **origin** is not `GL_LOWER_LEFT` or `GL_UPPER_LEFT`.
    * 
    * An `GL_INVALID_ENUM` error is generated if **depth** is not `GL_NEGATIVE_ONE_TO_ONE` or `GL_ZERO_TO_ONE`.
    * 
    * @param origin Specifies the clip control origin. Must be one of `GL_LOWER_LEFT` or `GL_UPPER_LEFT`.
    * @param depth Specifies the clip control depth mode. Must be one of `GL_NEGATIVE_ONE_TO_ONE` or `GL_ZERO_TO_ONE`.

    * @see **`gl_ClipDistance`**, **`gl_CullDistance`**, **`gl_FrontFacing`**, **`glDepthRange`**.

    **/
    static function clipControl(origin_:Int, depth:Int):Void return ExtensionsNative.clipControl(origin_, depth);
    static function clipControlEXT(origin_:Int, depth:Int):Void return ExtensionsNative.clipControlEXT(origin_, depth);
    static function clipPlane(plane:Int, equation:DataPointer):Void return ExtensionsNative.clipPlane(plane, equation);
    static function clipPlanef(p:Int, eqn:DataPointer):Void return ExtensionsNative.clipPlanef(p, eqn);
    static function clipPlanefIMG(p:Int, eqn:DataPointer):Void return ExtensionsNative.clipPlanefIMG(p, eqn);
    static function clipPlanefOES(plane:Int, equation:DataPointer):Void return ExtensionsNative.clipPlanefOES(plane, equation);
    static function clipPlanex(plane:Int, equation:DataPointer):Void return ExtensionsNative.clipPlanex(plane, equation);
    static function clipPlanexIMG(p:Int, eqn:DataPointer):Void return ExtensionsNative.clipPlanexIMG(p, eqn);
    static function clipPlanexOES(plane:Int, equation:DataPointer):Void return ExtensionsNative.clipPlanexOES(plane, equation);
    static function color3b(red:Int, green:Int, blue:Int):Void return ExtensionsNative.color3b(red, green, blue);
    static function color3bv(v:DataPointer):Void return ExtensionsNative.color3bv(v);
    static function color3d(red:DataPointer, green:DataPointer, blue:DataPointer):Void return ExtensionsNative.color3d(red, green, blue);
    static function color3dv(v:DataPointer):Void return ExtensionsNative.color3dv(v);
    static function color3f(red:Float, green:Float, blue:Float):Void return ExtensionsNative.color3f(red, green, blue);
    static function color3fVertex3fSUN(r:Float, g:Float, b:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.color3fVertex3fSUN(r, g, b, x, y, z);
    static function color3fVertex3fvSUN(c:DataPointer, v:DataPointer):Void return ExtensionsNative.color3fVertex3fvSUN(c, v);
    static function color3fv(v:DataPointer):Void return ExtensionsNative.color3fv(v);
    static function color3hNV(red:Int, green:Int, blue:Int):Void return ExtensionsNative.color3hNV(red, green, blue);
    static function color3hvNV(v:DataPointer):Void return ExtensionsNative.color3hvNV(v);
    static function color3i(red:Int, green:Int, blue:Int):Void return ExtensionsNative.color3i(red, green, blue);
    static function color3iv(v:DataPointer):Void return ExtensionsNative.color3iv(v);
    static function color3s(red:Int, green:Int, blue:Int):Void return ExtensionsNative.color3s(red, green, blue);
    static function color3sv(v:DataPointer):Void return ExtensionsNative.color3sv(v);
    static function color3ub(red:Int, green:Int, blue:Int):Void return ExtensionsNative.color3ub(red, green, blue);
    static function color3ubv(v:DataPointer):Void return ExtensionsNative.color3ubv(v);
    static function color3ui(red:Int, green:Int, blue:Int):Void return ExtensionsNative.color3ui(red, green, blue);
    static function color3uiv(v:DataPointer):Void return ExtensionsNative.color3uiv(v);
    static function color3us(red:Int, green:Int, blue:Int):Void return ExtensionsNative.color3us(red, green, blue);
    static function color3usv(v:DataPointer):Void return ExtensionsNative.color3usv(v);
    static function color3xOES(red:Int, green:Int, blue:Int):Void return ExtensionsNative.color3xOES(red, green, blue);
    static function color3xvOES(components:DataPointer):Void return ExtensionsNative.color3xvOES(components);
    static function color4b(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.color4b(red, green, blue, alpha);
    static function color4bv(v:DataPointer):Void return ExtensionsNative.color4bv(v);
    static function color4d(red:DataPointer, green:DataPointer, blue:DataPointer, alpha:DataPointer):Void return ExtensionsNative.color4d(red, green, blue, alpha);
    static function color4dv(v:DataPointer):Void return ExtensionsNative.color4dv(v);
    static function color4f(red:Float, green:Float, blue:Float, alpha:Float):Void return ExtensionsNative.color4f(red, green, blue, alpha);
    static function color4fNormal3fVertex3fSUN(r:Float, g:Float, b:Float, a:Float, nx:Float, ny:Float, nz:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.color4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
    static function color4fNormal3fVertex3fvSUN(c:DataPointer, n:DataPointer, v:DataPointer):Void return ExtensionsNative.color4fNormal3fVertex3fvSUN(c, n, v);
    static function color4fv(v:DataPointer):Void return ExtensionsNative.color4fv(v);
    static function color4hNV(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.color4hNV(red, green, blue, alpha);
    static function color4hvNV(v:DataPointer):Void return ExtensionsNative.color4hvNV(v);
    static function color4i(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.color4i(red, green, blue, alpha);
    static function color4iv(v:DataPointer):Void return ExtensionsNative.color4iv(v);
    static function color4s(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.color4s(red, green, blue, alpha);
    static function color4sv(v:DataPointer):Void return ExtensionsNative.color4sv(v);
    static function color4ub(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.color4ub(red, green, blue, alpha);
    static function color4ubVertex2fSUN(r:Int, g:Int, b:Int, a:Int, x:Float, y:Float):Void return ExtensionsNative.color4ubVertex2fSUN(r, g, b, a, x, y);
    static function color4ubVertex2fvSUN(c:DataPointer, v:DataPointer):Void return ExtensionsNative.color4ubVertex2fvSUN(c, v);
    static function color4ubVertex3fSUN(r:Int, g:Int, b:Int, a:Int, x:Float, y:Float, z:Float):Void return ExtensionsNative.color4ubVertex3fSUN(r, g, b, a, x, y, z);
    static function color4ubVertex3fvSUN(c:DataPointer, v:DataPointer):Void return ExtensionsNative.color4ubVertex3fvSUN(c, v);
    static function color4ubv(v:DataPointer):Void return ExtensionsNative.color4ubv(v);
    static function color4ui(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.color4ui(red, green, blue, alpha);
    static function color4uiv(v:DataPointer):Void return ExtensionsNative.color4uiv(v);
    static function color4us(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.color4us(red, green, blue, alpha);
    static function color4usv(v:DataPointer):Void return ExtensionsNative.color4usv(v);
    static function color4x(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.color4x(red, green, blue, alpha);
    static function color4xOES(red:Int, green:Int, blue:Int, alpha:Int):Void return ExtensionsNative.color4xOES(red, green, blue, alpha);
    static function color4xvOES(components:DataPointer):Void return ExtensionsNative.color4xvOES(components);
    static function colorFormatNV(size:Int, type:Int, stride:Int):Void return ExtensionsNative.colorFormatNV(size, type, stride);
    static function colorFragmentOp1ATI(op:Int, dst:Int, dstMask:Int, dstMod:Int, arg1:Int, arg1Rep:Int, arg1Mod:Int):Void return ExtensionsNative.colorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
    static function colorFragmentOp2ATI(op:Int, dst:Int, dstMask:Int, dstMod:Int, arg1:Int, arg1Rep:Int, arg1Mod:Int, arg2:Int, arg2Rep:Int, arg2Mod:Int):Void return ExtensionsNative.colorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    static function colorFragmentOp3ATI(op:Int, dst:Int, dstMask:Int, dstMod:Int, arg1:Int, arg1Rep:Int, arg1Mod:Int, arg2:Int, arg2Rep:Int, arg2Mod:Int, arg3:Int, arg3Rep:Int, arg3Mod:Int):Void return ExtensionsNative.colorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    /**
    * - #### Purpose:
    * enable and disable writing of frame buffer color components
    * ### Description:
    * **glColorMask** and **glColorMaski** specify whether the individual color components in the frame buffer can or cannot be written. **glColorMaski** sets the mask for a specific draw buffer, whereas **glColorMask** sets the mask for all draw buffers. If **red** is `GL_FALSE`, for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted.
    * 
    * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param buf For **glColorMaski**, specifies the index of the draw buffer whose color mask to set.
    * @param red green blue alpha Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components are written.

    * @see **`glClear`**, **`glDepthMask`**, **`glStencilMask`**

    **/
    static function colorMask(red:Bool, green:Bool, blue:Bool, alpha:Bool):Void return ExtensionsNative.colorMask(red, green, blue, alpha);
    static function colorMaskIndexedEXT(in_dex:Int, r:Bool, g:Bool, b:Bool, a:Bool):Void return ExtensionsNative.colorMaskIndexedEXT(in_dex, r, g, b, a);
    static function colorMaski(in_dex:Int, r:Bool, g:Bool, b:Bool, a:Bool):Void return ExtensionsNative.colorMaski(in_dex, r, g, b, a);
    static function colorMaskiEXT(in_dex:Int, r:Bool, g:Bool, b:Bool, a:Bool):Void return ExtensionsNative.colorMaskiEXT(in_dex, r, g, b, a);
    static function colorMaskiOES(in_dex:Int, r:Bool, g:Bool, b:Bool, a:Bool):Void return ExtensionsNative.colorMaskiOES(in_dex, r, g, b, a);
    static function colorMaterial(face:Int, mode:Int):Void return ExtensionsNative.colorMaterial(face, mode);
    static function colorP3ui(type:Int, color:Int):Void return ExtensionsNative.colorP3ui(type, color);
    static function colorP3uiv(type:Int, color:DataPointer):Void return ExtensionsNative.colorP3uiv(type, color);
    static function colorP4ui(type:Int, color:Int):Void return ExtensionsNative.colorP4ui(type, color);
    static function colorP4uiv(type:Int, color:DataPointer):Void return ExtensionsNative.colorP4uiv(type, color);
    static function colorPointer(size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.colorPointer(size, type, stride, poin_ter);
    static function colorPointerEXT(size:Int, type:Int, stride:Int, count:Int, poin_ter:DataPointer):Void return ExtensionsNative.colorPointerEXT(size, type, stride, count, poin_ter);
    static function colorPointerListIBM(size:Int, type:Int, stride:Int, poin_ter:DataPointer, ptrstride:Int):Void return ExtensionsNative.colorPointerListIBM(size, type, stride, poin_ter, ptrstride);
    static function colorPointervINTEL(size:Int, type:Int, poin_ter:DataPointer):Void return ExtensionsNative.colorPointervINTEL(size, type, poin_ter);
    static function colorSubTable(target:Int, start:Int, count:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.colorSubTable(target, start, count, format, type, data);
    static function colorSubTableEXT(target:Int, start:Int, count:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.colorSubTableEXT(target, start, count, format, type, data);
    static function colorTable(target:Int, in_ternalformat:Int, width:Int, format:Int, type:Int, table:DataPointer):Void return ExtensionsNative.colorTable(target, in_ternalformat, width, format, type, table);
    static function colorTableEXT(target:Int, in_ternalFormat:Int, width:Int, format:Int, type:Int, table:DataPointer):Void return ExtensionsNative.colorTableEXT(target, in_ternalFormat, width, format, type, table);
    static function colorTableParameterfv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.colorTableParameterfv(target, pname, params);
    static function colorTableParameterfvSGI(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.colorTableParameterfvSGI(target, pname, params);
    static function colorTableParameteriv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.colorTableParameteriv(target, pname, params);
    static function colorTableParameterivSGI(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.colorTableParameterivSGI(target, pname, params);
    static function colorTableSGI(target:Int, in_ternalformat:Int, width:Int, format:Int, type:Int, table:DataPointer):Void return ExtensionsNative.colorTableSGI(target, in_ternalformat, width, format, type, table);
    static function combinerInputNV(stage:Int, portion:Int, variable:Int, in_put:Int, mappin_g:Int, componentUsage:Int):Void return ExtensionsNative.combinerInputNV(stage, portion, variable, in_put, mappin_g, componentUsage);
    static function combinerOutputNV(stage:Int, portion:Int, abOutput:Int, cdOutput:Int, sumOutput:Int, scale:Int, bias:Int, abDotProduct:Bool, cdDotProduct:Bool, muxSum:Bool):Void return ExtensionsNative.combinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
    static function combinerParameterfNV(pname:Int, param:Float):Void return ExtensionsNative.combinerParameterfNV(pname, param);
    static function combinerParameterfvNV(pname:Int, params:DataPointer):Void return ExtensionsNative.combinerParameterfvNV(pname, params);
    static function combinerParameteriNV(pname:Int, param:Int):Void return ExtensionsNative.combinerParameteriNV(pname, param);
    static function combinerParameterivNV(pname:Int, params:DataPointer):Void return ExtensionsNative.combinerParameterivNV(pname, params);
    static function combinerStageParameterfvNV(stage:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.combinerStageParameterfvNV(stage, pname, params);
    static function commandListSegmentsNV(list:Int, segments:Int):Void return ExtensionsNative.commandListSegmentsNV(list, segments);
    static function compileCommandListNV(list:Int):Void return ExtensionsNative.compileCommandListNV(list);
    /**
    * - #### Purpose:
    * Compiles a shader object
    * ### Description:
    * **glCompileShader** compiles the source code strings that have been stored in the shader object specified by **shader**.
    * 
    * The compilation status will be stored as part of the shader object's state. This value will be set to `GL_TRUE` if the shader was compiled without errors and is ready for use, and `GL_FALSE` otherwise. It can be queried by calling **`glGetShader`** with arguments **shader** and `GL_COMPILE_STATUS`.
    * 
    * Compilation of a shader can fail for a number of reasons as specified by the OpenGL Shading Language Specification. Whether or not the compilation was successful, information about the compilation can be obtained from the shader object's information log by calling **`glGetShaderInfoLog`**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **shader** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **shader** is not a shader object.
    * 
    * @param shader Specifies the shader object to be compiled.

    * @see **`glCreateShader`**, **`glLinkProgram`**, **`glShaderSource`**

    **/
    static function compileShader(shader:Int):Void return ExtensionsNative.compileShader(shader);
    static function compileShaderARB(shaderObj:Int):Void return ExtensionsNative.compileShaderARB(shaderObj);
    static function compileShaderIncludeARB(shader:Int, count:Int, path:String, length:DataPointer):Void return ExtensionsNative.compileShaderIncludeARB(shader, count, path, length);
    static function compressedMultiTexImage1DEXT(texunit:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, border:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedMultiTexImage1DEXT(texunit, target, level, in_ternalformat, width, border, imageSize, bits);
    static function compressedMultiTexImage2DEXT(texunit:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, border:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedMultiTexImage2DEXT(texunit, target, level, in_ternalformat, width, height, border, imageSize, bits);
    static function compressedMultiTexImage3DEXT(texunit:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, border:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedMultiTexImage3DEXT(texunit, target, level, in_ternalformat, width, height, depth, border, imageSize, bits);
    static function compressedMultiTexSubImage1DEXT(texunit:Int, target:Int, level:Int, xoffset:Int, width:Int, format:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits);
    static function compressedMultiTexSubImage2DEXT(texunit:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    static function compressedMultiTexSubImage3DEXT(texunit:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    /**
    * - #### Purpose:
    * specify a one-dimensional texture image in a compressed format
    * ### Description:
    * Texturing allows elements of an image array to be read by shaders.
    * 
    * **glCompressedTexImage1D** loads a previously defined, and retrieved, compressed one-dimensional texture image if **target** is `GL_TEXTURE_1D` (see **`glTexImage1D`**).
    * 
    * If **target** is `GL_PROXY_TEXTURE_1D`, no data is read from **data**, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see **`glGetError`**). To query for an entire mipmap array, use an image array level greater than or equal to 1.
    * 
    * **internalformat** must be an extension-specified compressed-texture format. When a texture is loaded with **`glTexImage1D`** using a generic compressed texture format (e.g., `GL_COMPRESSED_RGB`) the GL selects from one of its extensions supporting compressed textures. In order to load the compressed texture image using **glCompressedTexImage1D**, query the compressed texture image's size and format using **`glGetTexLevelParameter`**.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
    * 
    * If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for **`glTexImage1D`**. In the following description, denote by bs, bw, bh, and bd the values of pixel storage modes `GL_UNPACK_COMPRESSED_BLOCK_SIZE`, `GL_UNPACK_COMPRESSED_BLOCK_WIDTH`, `GL_UNPACK_COMPRESSED_BLOCK_HEIGHT`, and `GL_UNPACK_COMPRESSED_BLOCK_DEPTH`, respectively. bs is the compressed block size in bytes; bw, bh, and bd are the compressed block width, height, and depth in pixels.
    * 
    * By default the pixel storage modes `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_IMAGE_HEIGHT` and `GL_UNPACK_SKIP_IMAGES` are ignored for compressed images. To enable `GL_UNPACK_SKIP_PIXELS` and `GL_UNPACK_ROW_LENGTH`, bs and bw must both be non-zero. To also enable `GL_UNPACK_SKIP_ROWS` and `GL_UNPACK_IMAGE_HEIGHT`, bh must be non-zero. To also enable `GL_UNPACK_SKIP_IMAGES`, bd must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.
    * 
    * When selecting a sub-rectangle from a compressed image, the value of `GL_UNPACK_SKIP_PIXELS` must be a multiple of bw
    * 
    * **imageSize** must be equal to:
    * 
    * b s &amp;times; width b w
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **internalformat** is not a supported specific compressed internal formats, or is one of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.
    * 
    * `GL_INVALID_VALUE` is generated if **imageSize** is not consistent with the format, dimensions, and contents of the specified compressed image data.
    * 
    * `GL_INVALID_VALUE` is generated if **border** is not 0.
    * 
    * `GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * Undefined results, including abnormal program termination, are generated if **data** is not encoded in a manner consistent with the extension specification defining the internal compression format.
    * 
    * @param target Specifies the target texture. Must be `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param internalformat Specifies the format of the compressed image data stored at address **data**.
    * @param width Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
    * @param border This value must be 0.
    * @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by **data**.
    * @param data Specifies a pointer to the compressed image data in memory.

    * @see **`glActiveTexture`**, **`glCompressedTexImage2D`**, **`glCompressedTexImage3D`**, **`glCompressedTexSubImage1D`**, **`glCompressedTexSubImage2D`**, **`glCompressedTexSubImage3D`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**, **`glTexParameter`**

    **/
    static function compressedTexImage1D(target:Int, level:Int, in_ternalformat:Int, width:Int, border:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexImage1D(target, level, in_ternalformat, width, border, imageSize, data);
    static function compressedTexImage1DARB(target:Int, level:Int, in_ternalformat:Int, width:Int, border:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexImage1DARB(target, level, in_ternalformat, width, border, imageSize, data);
    /**
    * - #### Purpose:
    * specify a two-dimensional texture image in a compressed format
    * ### Description:
    * Texturing allows elements of an image array to be read by shaders.
    * 
    * **glCompressedTexImage2D** loads a previously defined, and retrieved, compressed two-dimensional texture image if **target** is `GL_TEXTURE_2D`, or one of the cube map faces such as `GL_TEXTURE_CUBE_MAP_POSITIVE_X`. (see **`glTexImage2D`**).
    * 
    * If **target** is `GL_TEXTURE_1D_ARRAY`, **data** is treated as an array of compressed 1D textures.
    * 
    * If **target** is `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_CUBE_MAP`, no data is read from **data**, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see **`glGetError`**). To query for an entire mipmap array, use an image array level greater than or equal to 1.
    * 
    * **internalformat** must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. When a texture is loaded with **`glTexImage2D`** using a generic compressed texture format (e.g., `GL_COMPRESSED_RGB`), the GL selects from one of its extensions supporting compressed textures. In order to load the compressed texture image using **glCompressedTexImage2D**, query the compressed texture image's size and format using **`glGetTexLevelParameter`**.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
    * 
    * If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for **`glTexImage2D`**. In the following description, denote by bs, bw, bh, and bd, the values of pixel storage modes `GL_UNPACK_COMPRESSED_BLOCK_SIZE`, `GL_UNPACK_COMPRESSED_BLOCK_WIDTH`, `GL_UNPACK_COMPRESSED_BLOCK_HEIGHT`, and `GL_UNPACK_COMPRESSED_BLOCK_DEPTH`, respectively. bs is the compressed block size in bytes; bw, bh, and bd are the compressed block width, height, and depth in pixels.
    * 
    * By default the pixel storage modes `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_IMAGE_HEIGHT` and `GL_UNPACK_SKIP_IMAGES` are ignored for compressed images. To enable `GL_UNPACK_SKIP_PIXELS` and `GL_UNPACK_ROW_LENGTH`, bs and bw must both be non-zero. To also enable `GL_UNPACK_SKIP_ROWS` and `GL_UNPACK_IMAGE_HEIGHT`, bh must be non-zero. To also enable `GL_UNPACK_SKIP_IMAGES`, bd must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.
    * 
    * When selecting a sub-rectangle from a compressed image: The value of `GL_UNPACK_SKIP_PIXELS` must be a multiple of bw; the value of `GL_UNPACK_SKIP_ROWS` must be a multiple of bw.
    * 
    * **imageSize** must be equal to:
    * 
    * b s &amp;times; width b w &amp;times; height b h
    * 
    * 
    * ### Notes:
    * The specific compressed internal formats `GL_COMPRESSED_RGB8_ETC2`, `GL_COMPRESSED_SRGB8_ETC2`, `GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2`, `GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2`, `GL_COMPRESSED_RGBA8_ETC2_EAC`, `GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC`, `GL_COMPRESSED_R11_EAC`, `GL_COMPRESSED_SIGNED_R11_EAC`, `GL_COMPRESSED_RG11_EAC`, and `GL_COMPRESSED_SIGNED_RG11_EAC` are available only if the GL version is 4.3 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **internalformat** is not one of the specific compressed internal formats: `GL_COMPRESSED_RED_RGTC1`, `GL_COMPRESSED_SIGNED_RED_RGTC1`, `GL_COMPRESSED_RG_RGTC2`, `GL_COMPRESSED_SIGNED_RG_RGTC2`. `GL_COMPRESSED_RGBA_BPTC_UNORM`, `GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`, `GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`, `GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT`, `GL_COMPRESSED_RGB8_ETC2`, `GL_COMPRESSED_SRGB8_ETC2`, `GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2`, `GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2`, `GL_COMPRESSED_RGBA8_ETC2_EAC`, `GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC`, `GL_COMPRESSED_R11_EAC`, `GL_COMPRESSED_SIGNED_R11_EAC`, `GL_COMPRESSED_RG11_EAC`, or `GL_COMPRESSED_SIGNED_RG11_EAC`.
    * 
    * `GL_INVALID_VALUE` is generated if **imageSize** is not consistent with the format, dimensions, and contents of the specified compressed image data.
    * 
    * `GL_INVALID_VALUE` is generated if **border** is not 0.
    * 
    * `GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * Undefined results, including abnormal program termination, are generated if **data** is not encoded in a manner consistent with the extension specification defining the internal compression format.
    * 
    * @param target Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param internalformat Specifies the format of the compressed image data stored at address **data**.
    * @param width Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
    * @param height Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
    * @param border This value must be 0.
    * @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by **data**.
    * @param data Specifies a pointer to the compressed image data in memory.

    * @see **`glActiveTexture`**, **`glCompressedTexImage1D`**, **`glCompressedTexImage3D`**, **`glCompressedTexSubImage1D`**, **`glCompressedTexSubImage2D`**, **`glCompressedTexSubImage3D`**, **`glCopyTexImage1D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**, **`glTexParameter`**

    **/
    static function compressedTexImage2D(target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, border:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexImage2D(target, level, in_ternalformat, width, height, border, imageSize, data);
    static function compressedTexImage2DARB(target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, border:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexImage2DARB(target, level, in_ternalformat, width, height, border, imageSize, data);
    /**
    * - #### Purpose:
    * specify a three-dimensional texture image in a compressed format
    * ### Description:
    * Texturing allows elements of an image array to be read by shaders.
    * 
    * **glCompressedTexImage3D** loads a previously defined, and retrieved, compressed three-dimensional texture image if **target** is `GL_TEXTURE_3D` (see **`glTexImage3D`**).
    * 
    * If **target** is `GL_TEXTURE_2D_ARRAY`, **data** is treated as an array of compressed 2D textures.
    * 
    * If **target** is `GL_PROXY_TEXTURE_3D` or `GL_PROXY_TEXTURE_2D_ARRAY`, no data is read from **data**, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see **`glGetError`**). To query for an entire mipmap array, use an image array level greater than or equal to 1.
    * 
    * **internalformat** must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. When a texture is loaded with **`glTexImage2D`** using a generic compressed texture format (e.g., `GL_COMPRESSED_RGB`), the GL selects from one of its extensions supporting compressed textures. In order to load the compressed texture image using **glCompressedTexImage3D**, query the compressed texture image's size and format using **`glGetTexLevelParameter`**.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
    * 
    * If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for **`glTexImage1D`**. In the following description, denote by bs, bw, bh, and bd the values of pixel storage modes `GL_UNPACK_COMPRESSED_BLOCK_SIZE`, `GL_UNPACK_COMPRESSED_BLOCK_WIDTH`, `GL_UNPACK_COMPRESSED_BLOCK_HEIGHT`, and `GL_UNPACK_COMPRESSED_BLOCK_DEPTH`, respectively. bs is the compressed block size in bytes; bw, bh, and bd are the compressed block width, height, and depth in pixels.
    * 
    * By default the pixel storage modes `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_IMAGE_HEIGHT` and `GL_UNPACK_SKIP_IMAGES` are ignored for compressed images. To enable `GL_UNPACK_SKIP_PIXELS` and `GL_UNPACK_ROW_LENGTH`, bs and bw must both be non-zero. To also enable `GL_UNPACK_SKIP_ROWS` and `GL_UNPACK_IMAGE_HEIGHT`, bh must be non-zero. To also enable `GL_UNPACK_SKIP_IMAGES`, bd must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.
    * 
    * When selecting a sub-rectangle from a compressed image: the value of `GL_UNPACK_SKIP_PIXELS` must be a multiple of bw; the value of `GL_UNPACK_SKIP_ROWS` must be a multiple of bw; the value of `GL_UNPACK_SKIP_IMAGES` must be a multiple of bw.
    * 
    * **imageSize** must be equal to:
    * 
    * b s &amp;times; width b w &amp;times; height b h &amp;times; depth b d
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **internalformat** is not one of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.
    * 
    * `GL_INVALID_VALUE` is generated if **imageSize** is not consistent with the format, dimensions, and contents of the specified compressed image data.
    * 
    * `GL_INVALID_VALUE` is generated if **border** is not 0.
    * 
    * `GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * Undefined results, including abnormal program termination, are generated if **data** is not encoded in a manner consistent with the extension specification defining the internal compression format.
    * 
    * @param target Specifies the target texture. Must be `GL_TEXTURE_3D`, `GL_PROXY_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_2D_ARRAY`.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param internalformat Specifies the format of the compressed image data stored at address **data**.
    * @param width Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
    * @param height Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
    * @param depth Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
    * @param border This value must be 0.
    * @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by **data**.
    * @param data Specifies a pointer to the compressed image data in memory.

    * @see **`glActiveTexture`**, **`glCompressedTexImage1D`**, **`glCompressedTexImage2D`**, **`glCompressedTexSubImage1D`**, **`glCompressedTexSubImage2D`**, **`glCompressedTexSubImage3D`**, **`glCopyTexImage1D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**, **`glTexParameter`**

    **/
    static function compressedTexImage3D(target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, border:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexImage3D(target, level, in_ternalformat, width, height, depth, border, imageSize, data);
    static function compressedTexImage3DARB(target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, border:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexImage3DARB(target, level, in_ternalformat, width, height, depth, border, imageSize, data);
    static function compressedTexImage3DOES(target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, border:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexImage3DOES(target, level, in_ternalformat, width, height, depth, border, imageSize, data);
    /**
    * - #### Purpose:
    * specify a one-dimensional texture subimage in a compressed
        format
    * ### Description:
    * Texturing allows elements of an image array to be read by shaders.
    * 
    * **glCompressedTexSubImage1D** and **glCompressedTextureSubImage1D** redefine a contiguous subregion of an existing one-dimensional texture image. The texels referenced by **data** replace the portion of the existing texture array with x indices **xoffset** and xoffset + width - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.
    * 
    * **internalformat** must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. The **format** of the compressed texture image is selected by the GL implementation that compressed it (see **`glTexImage1D`**), and should be queried at the time the texture was compressed with **`glGetTexLevelParameter`**.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **internalformat** is not one of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.
    * 
    * `GL_INVALID_VALUE` is generated if **imageSize** is not consistent with the format, dimensions, and contents of the specified compressed image data.
    * 
    * `GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * GL_INVALID_OPERATION is generated by **glCompressedTextureSubImage1D** function if texture is not the name of an existing texture object.
    * 
    * Undefined results, including abnormal program termination, are generated if **data** is not encoded in a manner consistent with the extension specification defining the internal compression format.
    * 
    * @param target Specifies the target, to which the texture is bound, for **glCompressedTexSubImage1D** function. Must be `GL_TEXTURE_1D`.
    * @param texture Specifies the texture object name for **glCompressedTextureSubImage1D** function.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param xoffset Specifies a texel offset in the x direction within the texture array.
    * @param width Specifies the width of the texture subimage.
    * @param format Specifies the format of the compressed image data stored at address **data**.
    * @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by **data**.
    * @param data Specifies a pointer to the compressed image data in memory.

    * @see **`glActiveTexture`**, **`glCompressedTexImage1D`**, **`glCompressedTexImage2D`**, **`glCompressedTexImage3D`**, **`glCompressedTexSubImage2D`**, **`glCompressedTexSubImage3D`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**, **`glTexParameter`**

    **/
    static function compressedTexSubImage1D(target:Int, level:Int, xoffset:Int, width:Int, format:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
    static function compressedTexSubImage1DARB(target:Int, level:Int, xoffset:Int, width:Int, format:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data);
    /**
    * - #### Purpose:
    * specify a two-dimensional texture subimage in a compressed format
    * ### Description:
    * Texturing allows elements of an image array to be read by shaders.
    * 
    * **glCompressedTexSubImage2D** and **glCompressedTextureSubImage2D** redefine a contiguous subregion of an existing two-dimensional texture image. The texels referenced by **data** replace the portion of the existing texture array with x indices **xoffset** and xoffset + width - 1, and the y indices **yoffset** and yoffset + height - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.
    * 
    * **internalformat** must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. The **format** of the compressed texture image is selected by the GL implementation that compressed it (see **`glTexImage2D`**) and should be queried at the time the texture was compressed with **`glGetTexLevelParameter`**.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **internalformat** is of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.
    * 
    * `GL_INVALID_ENUM` is generated by **glCompressedTexSubImage2D** if **target** is `GL_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_RECTANGLE`.
    * 
    * `GL_INVALID_VALUE` is generated if **imageSize** is not consistent with the format, dimensions, and contents of the specified compressed image data.
    * 
    * `GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * `GL_INVALID_OPERATION` is generated by **glCompressedTextureSubImage2D** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_OPERATION` is generated by **glCompressedTextureSubImage2D** if the effective target is `GL_TEXTURE_RECTANGLE`.
    * 
    * Undefined results, including abnormal program termination, are generated if **data** is not encoded in a manner consistent with the extension specification defining the internal compression format.
    * 
    * @param target Specifies the target to which the texture is bound for **glCompressedTexSubImage2D** function. Must be `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.
    * @param texture Specifies the texture object name for **glCompressedTextureSubImage2D** function.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param xoffset Specifies a texel offset in the x direction within the texture array.
    * @param yoffset Specifies a texel offset in the y direction within the texture array.
    * @param width Specifies the width of the texture subimage.
    * @param height Specifies the height of the texture subimage.
    * @param format Specifies the format of the compressed image data stored at address **data**.
    * @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by **data**.
    * @param data Specifies a pointer to the compressed image data in memory.

    * @see **`glActiveTexture`**, **`glCompressedTexImage1D`**, **`glCompressedTexImage2D`**, **`glCompressedTexImage3D`**, **`glCompressedTexSubImage1D`**, **`glCompressedTexSubImage3D`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**, **`glTexParameter`**

    **/
    static function compressedTexSubImage2D(target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    static function compressedTexSubImage2DARB(target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    /**
    * - #### Purpose:
    * specify a three-dimensional texture subimage in a compressed format
    * ### Description:
    * Texturing allows elements of an image array to be read by shaders.
    * 
    * **glCompressedTexSubImage3D** and **glCompressedTextureSubImage3D** redefine a contiguous subregion of an existing three-dimensional texture image. The texels referenced by **data** replace the portion of the existing texture array with x indices **xoffset** and xoffset + width - 1, and the y indices **yoffset** and yoffset + height - 1, and the z indices **zoffset** and zoffset + depth - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.
    * 
    * **internalformat** must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. The **format** of the compressed texture image is selected by the GL implementation that compressed it (see **`glTexImage3D`**) and should be queried at the time the texture was compressed with **`glGetTexLevelParameter`**.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **internalformat** is one of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.
    * 
    * `GL_INVALID_ENUM` is generated by **glCompressedTexSubImage3D** if **target** is not `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.
    * 
    * `GL_INVALID_OPERATION` is generated by **glCompressedTextureSubImage3D** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_VALUE` is generated if **imageSize** is not consistent with the format, dimensions, and contents of the specified compressed image data.
    * 
    * `GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * Undefined results, including abnormal program termination, are generated if **data** is not encoded in a manner consistent with the extension specification defining the internal compression format.
    * 
    * @param target Specifies the target to which the texture is bound for **glCompressedTexSubImage3D** function. Must be `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.
    * @param texture Specifies the texture object name for **glCompressedTextureSubImage3D** function.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param xoffset Specifies a texel offset in the x direction within the texture array.
    * @param yoffset Specifies a texel offset in the y direction within the texture array.
    * @param zoffset Specifies a texel offset in the z direction within the texture array.
    * @param width Specifies the width of the texture subimage.
    * @param height Specifies the height of the texture subimage.
    * @param depth Specifies the depth of the texture subimage.
    * @param format Specifies the format of the compressed image data stored at address **data**.
    * @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by **data**.
    * @param data Specifies a pointer to the compressed image data in memory.

    * @see **`glActiveTexture`**, **`glCompressedTexImage1D`**, **`glCompressedTexImage2D`**, **`glCompressedTexImage3D`**, **`glCompressedTexSubImage1D`**, **`glCompressedTexSubImage2D`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**, **`glTexParameter`**

    **/
    static function compressedTexSubImage3D(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    static function compressedTexSubImage3DARB(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    static function compressedTexSubImage3DOES(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    static function compressedTextureImage1DEXT(texture:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, border:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedTextureImage1DEXT(texture, target, level, in_ternalformat, width, border, imageSize, bits);
    static function compressedTextureImage2DEXT(texture:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, border:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedTextureImage2DEXT(texture, target, level, in_ternalformat, width, height, border, imageSize, bits);
    static function compressedTextureImage3DEXT(texture:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, border:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedTextureImage3DEXT(texture, target, level, in_ternalformat, width, height, depth, border, imageSize, bits);
    static function compressedTextureSubImage1D(texture:Int, level:Int, xoffset:Int, width:Int, format:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data);
    static function compressedTextureSubImage1DEXT(texture:Int, target:Int, level:Int, xoffset:Int, width:Int, format:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits);
    static function compressedTextureSubImage2D(texture:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
    static function compressedTextureSubImage2DEXT(texture:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    static function compressedTextureSubImage3D(texture:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, imageSize:Int, data:DataPointer):Void return ExtensionsNative.compressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    static function compressedTextureSubImage3DEXT(texture:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, imageSize:Int, bits:DataPointer):Void return ExtensionsNative.compressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    static function conservativeRasterParameterfNV(pname:Int, value:Float):Void return ExtensionsNative.conservativeRasterParameterfNV(pname, value);
    static function conservativeRasterParameteriNV(pname:Int, param:Int):Void return ExtensionsNative.conservativeRasterParameteriNV(pname, param);
    static function convolutionFilter1D(target:Int, in_ternalformat:Int, width:Int, format:Int, type:Int, image:DataPointer):Void return ExtensionsNative.convolutionFilter1D(target, in_ternalformat, width, format, type, image);
    static function convolutionFilter1DEXT(target:Int, in_ternalformat:Int, width:Int, format:Int, type:Int, image:DataPointer):Void return ExtensionsNative.convolutionFilter1DEXT(target, in_ternalformat, width, format, type, image);
    static function convolutionFilter2D(target:Int, in_ternalformat:Int, width:Int, height:Int, format:Int, type:Int, image:DataPointer):Void return ExtensionsNative.convolutionFilter2D(target, in_ternalformat, width, height, format, type, image);
    static function convolutionFilter2DEXT(target:Int, in_ternalformat:Int, width:Int, height:Int, format:Int, type:Int, image:DataPointer):Void return ExtensionsNative.convolutionFilter2DEXT(target, in_ternalformat, width, height, format, type, image);
    static function convolutionParameterf(target:Int, pname:Int, params:Float):Void return ExtensionsNative.convolutionParameterf(target, pname, params);
    static function convolutionParameterfEXT(target:Int, pname:Int, params:Float):Void return ExtensionsNative.convolutionParameterfEXT(target, pname, params);
    static function convolutionParameterfv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.convolutionParameterfv(target, pname, params);
    static function convolutionParameterfvEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.convolutionParameterfvEXT(target, pname, params);
    static function convolutionParameteri(target:Int, pname:Int, params:Int):Void return ExtensionsNative.convolutionParameteri(target, pname, params);
    static function convolutionParameteriEXT(target:Int, pname:Int, params:Int):Void return ExtensionsNative.convolutionParameteriEXT(target, pname, params);
    static function convolutionParameteriv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.convolutionParameteriv(target, pname, params);
    static function convolutionParameterivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.convolutionParameterivEXT(target, pname, params);
    static function convolutionParameterxOES(target:Int, pname:Int, param:Int):Void return ExtensionsNative.convolutionParameterxOES(target, pname, param);
    static function convolutionParameterxvOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.convolutionParameterxvOES(target, pname, params);
    /**
    * - #### Purpose:
    * copy all or part of the data store of a buffer object to the data store of another buffer object
    * ### Description:
    * **glCopyBufferSubData** and **glCopyNamedBufferSubData** copy part of the data store attached to a source buffer object to the data store attached to a destination buffer object. The number of basic machine units indicated by **size** is copied from the source at offset **readOffset** to the destination at **writeOffset**. **readOffset**, **writeOffset** and **size** are in terms of basic machine units.
    * 
    * For **glCopyBufferSubData**, **readTarget** and **writeTarget** specify the targets to which the source and destination buffer objects are bound, and must each be one of the buffer binding targets in the following table:
    * 
    * Any of these targets may be used, but the targets `GL_COPY_READ_BUFFER` and `GL_COPY_WRITE_BUFFER` are provided specifically to allow copies between buffers without disturbing other GL state.
    * 
    * **readOffset**, **writeOffset** and **size** must all be greater than or equal to zero. Furthermore, $readOffset+size$ must not exceeed the size of the source buffer object, and $writeOffset+size$ must not exceeed the size of the buffer bound to **writeTarget**. If the source and destination are the same buffer object, then the source and destination ranges must not overlap.
    * 
    * 
    * ### Notes:
    * The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.
    * 
    * The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glCopyBufferSubData** if **readTarget** or **writeTarget** is not one of the buffer binding targets listed above.
    * 
    * `GL_INVALID_OPERATION` is generated by **glCopyBufferSubData** if zero is bound to **readTarget** or **writeTarget**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glCopyNamedBufferSubData** if **readBuffer** or **writeBuffer** is not the name of an existing buffer object.
    * 
    * `GL_INVALID_VALUE` is generated if any of **readOffset**, **writeOffset** or **size** is negative, if $readOffset + size$ is greater than the size of the source buffer object (its value of `GL_BUFFER_SIZE`), or if $writeOffset + size$ is greater than the size of the destination buffer object.
    * 
    * `GL_INVALID_VALUE` is generated if the source and destination are the same buffer object, and the ranges $[readOffset,readOffset+size)$ and $[writeOffset,writeOffset+size)$ overlap.
    * 
    * `GL_INVALID_OPERATION` is generated if either the source or destination buffer object is mapped with **`glMapBufferRange`** or **`glMapBuffer`**, unless they were mapped with the `GL_MAP_PERSISTENT` bit set in the **glMapBufferRange** **access** flags.
    * 
    * @param readTarget Specifies the target to which the source buffer object is bound for **glCopyBufferSubData**
    * @param writeTarget Specifies the target to which the destination buffer object is bound for **glCopyBufferSubData**.
    * @param readBuffer Specifies the name of the source buffer object for **glCopyNamedBufferSubData**.
    * @param writeBuffer Specifies the name of the destination buffer object for **glCopyNamedBufferSubData**.
    * @param readOffset Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read.
    * @param writeOffset Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written.
    * @param size Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object.

    * @see **`glGenBuffers`**, **`glBindBuffer`**, **`glBufferData`**, **`glBufferSubData`**, **`glGetBufferSubData`**, **`glMapBuffer`**, **`glMapBufferRange`**

    **/
    static function copyBufferSubData(readTarget:Int, writeTarget:Int, readOffset:Int, writeOffset:Int, size:Int):Void return ExtensionsNative.copyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
    static function copyBufferSubDataNV(readTarget:Int, writeTarget:Int, readOffset:Int, writeOffset:Int, size:Int):Void return ExtensionsNative.copyBufferSubDataNV(readTarget, writeTarget, readOffset, writeOffset, size);
    static function copyColorSubTable(target:Int, start:Int, x:Int, y:Int, width:Int):Void return ExtensionsNative.copyColorSubTable(target, start, x, y, width);
    static function copyColorSubTableEXT(target:Int, start:Int, x:Int, y:Int, width:Int):Void return ExtensionsNative.copyColorSubTableEXT(target, start, x, y, width);
    static function copyColorTable(target:Int, in_ternalformat:Int, x:Int, y:Int, width:Int):Void return ExtensionsNative.copyColorTable(target, in_ternalformat, x, y, width);
    static function copyColorTableSGI(target:Int, in_ternalformat:Int, x:Int, y:Int, width:Int):Void return ExtensionsNative.copyColorTableSGI(target, in_ternalformat, x, y, width);
    static function copyConvolutionFilter1D(target:Int, in_ternalformat:Int, x:Int, y:Int, width:Int):Void return ExtensionsNative.copyConvolutionFilter1D(target, in_ternalformat, x, y, width);
    static function copyConvolutionFilter1DEXT(target:Int, in_ternalformat:Int, x:Int, y:Int, width:Int):Void return ExtensionsNative.copyConvolutionFilter1DEXT(target, in_ternalformat, x, y, width);
    static function copyConvolutionFilter2D(target:Int, in_ternalformat:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyConvolutionFilter2D(target, in_ternalformat, x, y, width, height);
    static function copyConvolutionFilter2DEXT(target:Int, in_ternalformat:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyConvolutionFilter2DEXT(target, in_ternalformat, x, y, width, height);
    /**
    * - #### Purpose:
    * perform a raw data copy between two images
    * ### Description:
    * **glCopyImageSubData** may be used to copy data from one image (i.e. texture or renderbuffer) to another. **glCopyImageSubData** does not perform general-purpose conversions such as scaling, resizing, blending, color-space, or format conversions. It should be considered to operate in a manner similar to a CPU memcpy. CopyImageSubData can copy between images with different internal formats, provided the formats are compatible.
    * 
    * **glCopyImageSubData** also allows copying between certain types of compressed and uncompressed internal formats. This copy does not perform on-the-fly compression or decompression. When copying from an uncompressed internal format to a compressed internal format, each texel of uncompressed data becomes a single block of compressed data. When copying from a compressed internal format to an uncompressed internal format, a block of compressed data becomes a single texel of uncompressed data. The texel size of the uncompressed format must be the same size the block size of the compressed formats. Thus it is permitted to copy between a 128-bit uncompressed format and a compressed format which uses 8-bit 4x4 blocks, or between a 64-bit uncompressed format and a compressed format which uses 4-bit 4x4 blocks.
    * 
    * The source object is identified by **srcName** and **srcTarget** and the destination object is identified by **dstName** and **dstTarget**. The interpretation of the name depends on the value of the corresponding **target** parameter. If **target** is `GL_RENDERBUFFER`, the name is interpreted as the name of a renderbuffer object. If the target parameter is a texture target, the name is interpreted as a texture object. All non-proxy texture targets are accepted, with the exception of `GL_TEXTURE_BUFFER` and the cubemap face selectors.
    * 
    * **srcLevel** and **dstLevel** identify the source and destination level of detail. For textures, this must be a valid level of detail in the texture object. For renderbuffers, this value must be zero.
    * 
    * **srcX**, **srcY**, and **srcZ** specify the lower left texel coordinates of a **srcWidth**-wide by **srcHeight**-high by **srcDepth**-deep rectangular subregion of the source texel array. Similarly, **dstX**, **dstY** and **dstZ** specify the coordinates of a subregion of the destination texel array. The source and destination subregions must be contained entirely within the specified level of the corresponding image objects.
    * 
    * The dimensions are always specified in texels, even for compressed texture formats. However, it should be noted that if only one of the source and destination textures is compressed then the number of texels touched in the compressed image will be a factor of the block size larger than in the uncompressed image.
    * 
    * Slices of a `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY` `GL_TEXTURE_3D` and faces of `GL_TEXTURE_CUBE_MAP` are all compatible provided they share a compatible internal format, and multiple slices or faces may be copied between these objects with a single call by specifying the starting slice with **srcZ** and **dstZ**, and the number of slices to be copied with **srcDepth**. Cubemap textures always have six faces which are selected by a zero-based face index.
    * 
    * For the purposes of CopyImageSubData, two internal formats are considered compatible if any of the following conditions are met: the formats are the same, the formats are considered compatible according to the compatibility rules used for texture views as defined in section 3.9.X. In particular, if both internal formats are listed in the same entry of Table 3.X.2, they are considered compatible, or one format is compressed and the other is uncompressed and Table 4.X.1 lists the two formats in the same row. If the formats are not compatible, an INVALID_OPERATION error is generated.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if the texel size of the uncompressed image is not equal to the block size of the compressed image.
    * 
    * `GL_INVALID_ENUM` is generated if either target parameter is not `GL_RENDERBUFFER`, a valid non-proxy texture target other than `GL_TEXTURE_BUFFER`, or is one of the cubemap face selectors.
    * 
    * `GL_INVALID_ENUM` is generated if **target** does not match the type of the object.
    * 
    * `GL_INVALID_OPERATION` is generated if either object is a texture and the texture is not complete.
    * 
    * `GL_INVALID_OPERATION` is generated if the source and destination internal formats are not compatible, or if the number of samples do not match.
    * 
    * `GL_INVALID_VALUE` is generated if either name does not correspond to a valid renderbuffer or texture object according to the corresponding target parameter.
    * 
    * `GL_INVALID_VALUE` is generated if the specified level of either the source or destination is not a valid level for the corresponding image.
    * 
    * `GL_INVALID_VALUE` is generated if the dimensions of the either subregion exceeds the boundaries of the corresponding image object, or if the image format is compressed and the dimensions of the subregion fail to meet the alignment constraints of the format.
    * 
    * @param srcName The name of a texture or renderbuffer object from which to copy.
    * @param srcTarget The target representing the namespace of the source name **srcName**.
    * @param srcLevel The mipmap level to read from the source.
    * @param srcX The X coordinate of the left edge of the souce region to copy.
    * @param srcY The Y coordinate of the top edge of the souce region to copy.
    * @param srcZ The Z coordinate of the near edge of the souce region to copy.
    * @param dstName The name of a texture or renderbuffer object to which to copy.
    * @param dstTarget The target representing the namespace of the destination name **dstName**.
    * @param dstX The X coordinate of the left edge of the destination region.
    * @param dstY The Y coordinate of the top edge of the destination region.
    * @param dstZ The Z coordinate of the near edge of the destination region.
    * @param srcWidth The width of the region to be copied.
    * @param srcHeight The height of the region to be copied.
    * @param srcDepth The depth of the region to be copied.

    * @see **`glDispatchComputeIndirect`**.

    **/
    static function copyImageSubData(srcName:Int, srcTarget:Int, srcLevel:Int, srcX:Int, srcY:Int, srcZ:Int, dstName:Int, dstTarget:Int, dstLevel:Int, dstX:Int, dstY:Int, dstZ:Int, srcWidth:Int, srcHeight:Int, srcDepth:Int):Void return ExtensionsNative.copyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    static function copyImageSubDataEXT(srcName:Int, srcTarget:Int, srcLevel:Int, srcX:Int, srcY:Int, srcZ:Int, dstName:Int, dstTarget:Int, dstLevel:Int, dstX:Int, dstY:Int, dstZ:Int, srcWidth:Int, srcHeight:Int, srcDepth:Int):Void return ExtensionsNative.copyImageSubDataEXT(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    static function copyImageSubDataNV(srcName:Int, srcTarget:Int, srcLevel:Int, srcX:Int, srcY:Int, srcZ:Int, dstName:Int, dstTarget:Int, dstLevel:Int, dstX:Int, dstY:Int, dstZ:Int, width:Int, height:Int, depth:Int):Void return ExtensionsNative.copyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    static function copyImageSubDataOES(srcName:Int, srcTarget:Int, srcLevel:Int, srcX:Int, srcY:Int, srcZ:Int, dstName:Int, dstTarget:Int, dstLevel:Int, dstX:Int, dstY:Int, dstZ:Int, srcWidth:Int, srcHeight:Int, srcDepth:Int):Void return ExtensionsNative.copyImageSubDataOES(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    static function copyMultiTexImage1DEXT(texunit:Int, target:Int, level:Int, in_ternalformat:Int, x:Int, y:Int, width:Int, border:Int):Void return ExtensionsNative.copyMultiTexImage1DEXT(texunit, target, level, in_ternalformat, x, y, width, border);
    static function copyMultiTexImage2DEXT(texunit:Int, target:Int, level:Int, in_ternalformat:Int, x:Int, y:Int, width:Int, height:Int, border:Int):Void return ExtensionsNative.copyMultiTexImage2DEXT(texunit, target, level, in_ternalformat, x, y, width, height, border);
    static function copyMultiTexSubImage1DEXT(texunit:Int, target:Int, level:Int, xoffset:Int, x:Int, y:Int, width:Int):Void return ExtensionsNative.copyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);
    static function copyMultiTexSubImage2DEXT(texunit:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);
    static function copyMultiTexSubImage3DEXT(texunit:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    static function copyNamedBufferSubData(readBuffer:Int, writeBuffer:Int, readOffset:Int, writeOffset:Int, size:Int):Void return ExtensionsNative.copyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
    static function copyPathNV(resultPath:Int, srcPath:Int):Void return ExtensionsNative.copyPathNV(resultPath, srcPath);
    static function copyPixels(x:Int, y:Int, width:Int, height:Int, type:Int):Void return ExtensionsNative.copyPixels(x, y, width, height, type);
    /**
    * - #### Purpose:
    * copy pixels into a 1D texture image
    * ### Description:
    * **glCopyTexImage1D** defines a one-dimensional texture image with pixels from the current `GL_READ_BUFFER`.
    * 
    * The screen-aligned pixel row with left corner at x y and with a length of width defines the texture array at the mipmap level specified by **level**. **internalformat** specifies the internal format of the texture array.
    * 
    * The pixels in the row are processed exactly as if **`glReadPixels`** had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array.
    * 
    * Pixel ordering is such that lower x screen coordinates correspond to lower texture coordinates.
    * 
    * If any of the pixels within the specified row of the current `GL_READ_BUFFER` are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined.
    * 
    * **glCopyTexImage1D** defines a one-dimensional texture image with pixels from the current `GL_READ_BUFFER`.
    * 
    * When **internalformat** is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the **glPixelMap** function can be used to accomplish the conversion.
    * 
    * 
    * ### Notes:
    * 1, 2, 3, and 4 are not accepted values for **internalformat**.
    * 
    * An image with 0 width indicates a NULL texture.
    * 
    * `GL_STENCIL_INDEX8` is accepted for **internalformat** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not one of the allowable values.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` may be generated if **level** is greater than log 2 &amp;it; max, where max is the returned value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **internalformat** is not an allowable value.
    * 
    * `GL_INVALID_VALUE` is generated if **width** is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **border** is not 0.
    * 
    * `GL_INVALID_OPERATION` is generated if **internalformat** is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32` and there is no depth buffer.
    * 
    * @param target Specifies the target texture. Must be `GL_TEXTURE_1D`.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param internalformat Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, `GL_COMPRESSED_SRGB_ALPHA`. `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_STENCIL_INDEX8`, `GL_RED`, `GL_RG`, `GL_RGB`, `GL_R3_G3_B2`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`.
    * @param x y Specify the window coordinates of the left corner of the row of pixels to be copied.
    * @param width Specifies the width of the texture image. The height of the texture image is 1.
    * @param border Must be 0.

    * @see **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glPixelStore`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexParameter`**

    **/
    static function copyTexImage1D(target:Int, level:Int, in_ternalformat:Int, x:Int, y:Int, width:Int, border:Int):Void return ExtensionsNative.copyTexImage1D(target, level, in_ternalformat, x, y, width, border);
    static function copyTexImage1DEXT(target:Int, level:Int, in_ternalformat:Int, x:Int, y:Int, width:Int, border:Int):Void return ExtensionsNative.copyTexImage1DEXT(target, level, in_ternalformat, x, y, width, border);
    /**
    * - #### Purpose:
    * copy pixels into a 2D texture image
    * ### Description:
    * **glCopyTexImage2D** defines a two-dimensional texture image, or cube-map texture image with pixels from the current `GL_READ_BUFFER`.
    * 
    * The screen-aligned pixel rectangle with lower left corner at (**x**, **y**) and with a width of width and a height of height defines the texture array at the mipmap level specified by **level**. **internalformat** specifies the internal format of the texture array.
    * 
    * The pixels in the rectangle are processed exactly as if **`glReadPixels`** had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array.
    * 
    * Pixel ordering is such that lower x and y screen coordinates correspond to lower s and t texture coordinates.
    * 
    * If any of the pixels within the specified rectangle of the current `GL_READ_BUFFER` are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined.
    * 
    * When **internalformat** is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the **glPixelMap** function can be used to accomplish the conversion.
    * 
    * 
    * ### Notes:
    * 1, 2, 3, and 4 are not accepted values for **internalformat**.
    * 
    * An image with height or width of 0 indicates a NULL texture.
    * 
    * `GL_STENCIL_INDEX8` is accepted for **internalformat** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` may be generated if **level** is greater than log 2 &amp;it; max, where max is the returned value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **width** is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **border** is not 0.
    * 
    * `GL_INVALID_VALUE` is generated if **internalformat** is not an accepted format.
    * 
    * `GL_INVALID_OPERATION` is generated if **internalformat** is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32` and there is no depth buffer.
    * 
    * @param target Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param internalformat Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, `GL_COMPRESSED_SRGB_ALPHA`. `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_STENCIL_INDEX8`, `GL_RED`, `GL_RG`, `GL_RGB`, `GL_R3_G3_B2`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`.
    * @param x y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
    * @param width Specifies the width of the texture image.
    * @param height Specifies the height of the texture image.
    * @param border Must be 0.

    * @see **`glCopyTexImage1D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glPixelStore`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexParameter`**

    **/
    static function copyTexImage2D(target:Int, level:Int, in_ternalformat:Int, x:Int, y:Int, width:Int, height:Int, border:Int):Void return ExtensionsNative.copyTexImage2D(target, level, in_ternalformat, x, y, width, height, border);
    static function copyTexImage2DEXT(target:Int, level:Int, in_ternalformat:Int, x:Int, y:Int, width:Int, height:Int, border:Int):Void return ExtensionsNative.copyTexImage2DEXT(target, level, in_ternalformat, x, y, width, height, border);
    /**
    * - #### Purpose:
    * copy a one-dimensional texture subimage
    * ### Description:
    * **glCopyTexSubImage1D** and **glCopyTextureSubImage1D** replace a portion of a one-dimensional texture image with pixels from the current `GL_READ_BUFFER` (rather than from main memory, as is the case for **`glTexSubImage1D`**). For **glCopyTexSubImage1D**, the texture object that is bound to **target** will be used for the process. For **glCopyTextureSubImage1D**, **texture** tells which texture object should be used for the purpose of the call.
    * 
    * The screen-aligned pixel row with left corner at (**x**,\ **y**), and with length **width** replaces the portion of the texture array with x indices **xoffset** throughxoffset + width - 1, inclusive. The destination in the texture array may not include any texels outside the texture array as it was originally specified.
    * 
    * The pixels in the row are processed exactly as if **`glReadPixels`** had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array.
    * 
    * It is not an error to specify a subtexture with zero width, but such a specification has no effect. If any of the pixels within the specified row of the current `GL_READ_BUFFER` are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.
    * 
    * No change is made to the internalformat or width parameters of the specified texture array or to texel values outside the specified subregion.
    * 
    * 
    * ### Notes:
    * The **`glPixelStore`** mode affects texture images.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glCopyTexSubImage1D** if **target** is not `GL_TEXTURE_1D`.
    * 
    * `GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the object bound to `GL_READ_FRAMEBUFFER_BINDING` is not framebuffer complete.
    * 
    * `GL_INVALID_OPERATION` is generated by **glCopyTextureSubImage1D** if **texture** is not the name of an existing texture object, or if the effective target of **texture** is not `GL_TEXTURE_1D`.
    * 
    * `GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous **`glTexImage1D`**, **`glCopyTexImage1D`**, or **`glTexStorage1D`** operation.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` may be generated if log sub 2(max): --> level &gt; log 2 &amp;af; max, where max is the returned value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if xoffset &lt; 0, or (w-b): --> xoffset + width &gt; w, where w is the `GL_TEXTURE_WIDTH` of the texture image being modified.
    * 
    * `GL_INVALID_OPERATION` is generated if:
    * 
    * the read buffer is `GL_NONE`, or the value of `GL_READ_FRAMEBUFFER_BINDING` is non-zero, and: the read buffer selects an attachment that has no image attached, or the effective value of `GL_SAMPLE_BUFFERS` for the read framebuffer is one.
    * 
    * 
    * 
    * @param target Specifies the target to which the texture object is bound for **glCopyTexSubImage1D** function. Must be `GL_TEXTURE_1D`.
    * @param texture Specifies the texture object name for **glCopyTextureSubImage1D** function.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param xoffset Specifies the texel offset within the texture array.
    * @param x y Specify the window coordinates of the left corner of the row of pixels to be copied.
    * @param width Specifies the width of the texture subimage.

    * @see **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glReadBuffer`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexParameter`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**

    **/
    static function copyTexSubImage1D(target:Int, level:Int, xoffset:Int, x:Int, y:Int, width:Int):Void return ExtensionsNative.copyTexSubImage1D(target, level, xoffset, x, y, width);
    static function copyTexSubImage1DEXT(target:Int, level:Int, xoffset:Int, x:Int, y:Int, width:Int):Void return ExtensionsNative.copyTexSubImage1DEXT(target, level, xoffset, x, y, width);
    /**
    * - #### Purpose:
    * copy a two-dimensional texture subimage
    * ### Description:
    * **glCopyTexSubImage2D** and **glCopyTextureSubImage2D** replace a rectangular portion of a two-dimensional texture image, cube-map texture image, rectangular image, or a linear portion of a number of slices of a one-dimensional array texture with pixels from the current `GL_READ_BUFFER` (rather than from main memory, as is the case for **`glTexSubImage2D`**).
    * 
    * The screen-aligned pixel rectangle with lower left corner at x y and with width **width** and height **height** replaces the portion of the texture array with x indices **xoffset** through xoffset + width - 1, inclusive, and y indices **yoffset** through yoffset + height - 1, inclusive, at the mipmap level specified by **level**.
    * 
    * The pixels in the rectangle are processed exactly as if **`glReadPixels`** had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range $[0,1]$ and then converted to the texture's internal format for storage in the texel array.
    * 
    * The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.
    * 
    * When **target** is `GL_TEXTURE_1D_ARRAY` then the y coordinate and height are treated as the start slice and number of slices to modify, respectively.
    * 
    * If any of the pixels within the specified rectangle of the current `GL_READ_BUFFER` are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.
    * 
    * No change is made to the internalformat, width or height parameters of the specified texture array, or to texel values outside the specified subregion.
    * 
    * 
    * ### Notes:
    * **`glPixelStore`** modes affect texture images.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_TEXTURE_1D_ARRAY` or `GL_RECTANGLE`.
    * 
    * `GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the object bound to `GL_READ_FRAMEBUFFER_BINDING` is not framebuffer complete.
    * 
    * `GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous **`glTexImage2D`**, **`glTexStorage2D`** or **`glCopyTexImage2D`** operation.
    * 
    * `GL_INVALID_OPERATION` is generated by **glCopyTextureSubImage2D** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_OPERATION` is generated by **glCopyTextureSubImage2D** if the effective target of texture does not correspond to one of the texture targets supported by the function.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` is generated if the effective target is `GL_TEXTURE_RECTANGLE` and **level** is not zero.
    * 
    * `GL_INVALID_VALUE` may be generated if log sub 2(max): --> level &gt; log 2 &amp;af; max, where max is the returned value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if xoffset &lt; 0, (w - b): --> xoffset + width &gt; w, yoffset &lt; 0, or (h - b): --> yoffset + height &gt; h, where w is the `GL_TEXTURE_WIDTH` and h is the `GL_TEXTURE_HEIGHT` of the texture image being modified.
    * 
    * `GL_INVALID_OPERATION` is generated if:
    * 
    * the read buffer is `GL_NONE`, or the value of `GL_READ_FRAMEBUFFER_BINDING` is non-zero, and: the read buffer selects an attachment that has no image attached, or the effective value of `GL_SAMPLE_BUFFERS` for the read framebuffer is one.
    * 
    * @param target Specifies the target to which the texture object is bound for **glCopyTexSubImage2D** function. Must be `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_RECTANGLE`.
    * @param texture Specifies the texture object name for **glCopyTextureSubImage2D** function.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param xoffset Specifies a texel offset in the x direction within the texture array.
    * @param yoffset Specifies a texel offset in the y direction within the texture array.
    * @param x y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
    * @param width Specifies the width of the texture subimage.
    * @param height Specifies the height of the texture subimage.

    * @see **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glReadBuffer`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexParameter`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**

    **/
    static function copyTexSubImage2D(target:Int, level:Int, xoffset:Int, yoffset:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    static function copyTexSubImage2DEXT(target:Int, level:Int, xoffset:Int, yoffset:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
    /**
    * - #### Purpose:
    * copy a three-dimensional texture subimage
    * ### Description:
    * **glCopyTexSubImage3D** and **glCopyTextureSubImage3D** functions replace a rectangular portion of a three-dimensional or two-dimensional array texture image with pixels from the current `GL_READ_BUFFER` (rather than from main memory, as is the case for **`glTexSubImage3D`**).
    * 
    * The screen-aligned pixel rectangle with lower left corner at (**x**, **y**) and with width **width** and height **height** replaces the portion of the texture array with x indices **xoffset** through xoffset + width - 1, inclusive, and y indices **yoffset** through yoffset + height - 1, inclusive, at z index **zoffset** and at the mipmap level specified by **level**.
    * 
    * The pixels in the rectangle are processed exactly as if **`glReadPixels`** had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array.
    * 
    * The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.
    * 
    * If any of the pixels within the specified rectangle of the current `GL_READ_BUFFER` are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.
    * 
    * No change is made to the internalformat, width, height, depth, or border parameters of the specified texture array or to texel values outside the specified subregion.
    * 
    * 
    * ### Notes:
    * **`glPixelStore`** modes affect texture images.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glCopyTexSubImage3D** if **target** is not `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.
    * 
    * `GL_INVALID_OPERATION` is generated by **glCopyTextureSubImage3D** if the effective target is not `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY` or `GL_TEXTURE_CUBE_MAP`.
    * 
    * `GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the object bound to `GL_READ_FRAMEBUFFER_BINDING` is not framebuffer complete.
    * 
    * `GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous **`glTexImage3D`** or **`glTexStorage3D`** operation.
    * 
    * `GL_INVALID_OPERATION` is generated by **glCopyTextureSubImage3D** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` may be generated if log sub 2(max): --> level &gt; log 2 &amp;af; max, where max is the returned value of `GL_MAX_3D_TEXTURE_SIZE` if **target** is `GL_TEXTURE_3D` or the returned value of `GL_MAX_ARRAY_TEXTURE_LAYERS` if **target** is `GL_TEXTURE_2D_ARRAY`.
    * 
    * `GL_INVALID_VALUE` is generated if xoffset &lt; 0, (w - b): --> xoffset + width &gt; w, yoffset &lt; 0, (h - b): --> yoffset + height &gt; h, zoffset &lt; 0, or (d - b): --> zoffset + 1 &gt; d, where w is the `GL_TEXTURE_WIDTH`, h is the `GL_TEXTURE_HEIGHT`, d is the `GL_TEXTURE_DEPTH` and of the texture image being modified. Note that w, h, and d include twice the border width.
    * 
    * `GL_INVALID_OPERATION` is generated if: the read buffer is `GL_NONE`, or the value of `GL_READ_FRAMEBUFFER_BINDING` is non-zero, and: the read buffer selects an attachment that has no image attached, or the effective value of `GL_SAMPLE_BUFFERS` for the read framebuffer is one.
    * 
    * @param target Specifies the target to which the texture object is bound for **glCopyTexSubImage3D** function. Must be `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.
    * @param texture Specifies the texture object name for **glCopyTextureSubImage3D** function.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param xoffset Specifies a texel offset in the x direction within the texture array.
    * @param yoffset Specifies a texel offset in the y direction within the texture array.
    * @param zoffset Specifies a texel offset in the z direction within the texture array.
    * @param x y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
    * @param width Specifies the width of the texture subimage.
    * @param height Specifies the height of the texture subimage.

    * @see **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glPixelStore`**, **`glReadBuffer`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexParameter`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**

    **/
    static function copyTexSubImage3D(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    static function copyTexSubImage3DEXT(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    static function copyTexSubImage3DOES(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    static function copyTextureImage1DEXT(texture:Int, target:Int, level:Int, in_ternalformat:Int, x:Int, y:Int, width:Int, border:Int):Void return ExtensionsNative.copyTextureImage1DEXT(texture, target, level, in_ternalformat, x, y, width, border);
    static function copyTextureImage2DEXT(texture:Int, target:Int, level:Int, in_ternalformat:Int, x:Int, y:Int, width:Int, height:Int, border:Int):Void return ExtensionsNative.copyTextureImage2DEXT(texture, target, level, in_ternalformat, x, y, width, height, border);
    static function copyTextureLevelsAPPLE(destin_ationTexture:Int, sourceTexture:Int, sourceBaseLevel:Int, sourceLevelCount:Int):Void return ExtensionsNative.copyTextureLevelsAPPLE(destin_ationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
    static function copyTextureSubImage1D(texture:Int, level:Int, xoffset:Int, x:Int, y:Int, width:Int):Void return ExtensionsNative.copyTextureSubImage1D(texture, level, xoffset, x, y, width);
    static function copyTextureSubImage1DEXT(texture:Int, target:Int, level:Int, xoffset:Int, x:Int, y:Int, width:Int):Void return ExtensionsNative.copyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width);
    static function copyTextureSubImage2D(texture:Int, level:Int, xoffset:Int, yoffset:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);
    static function copyTextureSubImage2DEXT(texture:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height);
    static function copyTextureSubImage3D(texture:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
    static function copyTextureSubImage3DEXT(texture:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.copyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    static function coverFillPathInstancedNV(numPaths:Int, pathNameType:Int, paths:DataPointer, pathBase:Int, coverMode:Int, transformType:Int, transformValues:DataPointer):Void return ExtensionsNative.coverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    static function coverFillPathNV(path:Int, coverMode:Int):Void return ExtensionsNative.coverFillPathNV(path, coverMode);
    static function coverStrokePathInstancedNV(numPaths:Int, pathNameType:Int, paths:DataPointer, pathBase:Int, coverMode:Int, transformType:Int, transformValues:DataPointer):Void return ExtensionsNative.coverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    static function coverStrokePathNV(path:Int, coverMode:Int):Void return ExtensionsNative.coverStrokePathNV(path, coverMode);
    static function coverageMaskNV(mask:Bool):Void return ExtensionsNative.coverageMaskNV(mask);
    static function coverageModulationNV(components:Int):Void return ExtensionsNative.coverageModulationNV(components);
    static function coverageModulationTableNV(n:Int, v:DataPointer):Void return ExtensionsNative.coverageModulationTableNV(n, v);
    static function coverageOperationNV(operation:Int):Void return ExtensionsNative.coverageOperationNV(operation);
    /**
    * - #### Purpose:
    * create buffer objects
    * ### Description:
    * **glCreateBuffers** returns **n** previously unused buffer names in **buffers**, each representing a new buffer object initialized as if it had been bound to an unspecified target.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of buffer objects to create.
    * @param buffers Specifies an array in which names of the new buffer objects are stored.

    * @see **`glGenBuffers`**, **`glBindBufferBase`**, **`glBindBufferRange`**, **`glMapBuffer`**, **`glUnmapBuffer`**, **`glDeleteBuffers`**, **`glGet`**, **`glIsBuffer`**

    **/
    static function createBuffers(n:Int, buffers:DataPointer):Void return ExtensionsNative.createBuffers(n, buffers);
    static function createCommandListsNV(n:Int, lists:DataPointer):Void return ExtensionsNative.createCommandListsNV(n, lists);
    /**
    * - #### Purpose:
    * create framebuffer objects
    * ### Description:
    * **glCreateFramebuffers** returns **n** previously unused framebuffer names in **framebuffers**, each representing a new framebuffer object initialized to the default state.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Number of framebuffer objects to create.
    * @param framebuffers Specifies an array in which names of the new framebuffer objects are stored.

    * @see **`glGenFramebuffers`**, **`glBindFramebuffer`**, **`glFramebufferRenderbuffer`**, **`glFramebufferTexture`**, **glFramebufferTexture1D**, **glFramebufferTexture2D**, **glFramebufferTexture3D**, **`glFramebufferTextureLayer`**, **`glDeleteFramebuffers`**, **`glIsFramebuffer`**

    **/
    static function createFramebuffers(n:Int, framebuffers:DataPointer):Void return ExtensionsNative.createFramebuffers(n, framebuffers);
    static function createMemoryObjectsEXT(n:Int, memoryObjects:DataPointer):Void return ExtensionsNative.createMemoryObjectsEXT(n, memoryObjects);
    static function createPerfQueryINTEL(queryId:Int, queryHandle:DataPointer):Void return ExtensionsNative.createPerfQueryINTEL(queryId, queryHandle);
    /**
    * - #### Purpose:
    * Creates a program object
    * ### Description:
    * **glCreateProgram** creates an empty program object and returns a non-zero value by which it can be referenced. A program object is an object to which shader objects can be attached. This provides a mechanism to specify the shader objects that will be linked to create a program. It also provides a means for checking the compatibility of the shaders that will be used to create a program (for instance, checking the compatibility between a vertex shader and a fragment shader). When no longer needed as part of a program object, shader objects can be detached.
    * 
    * One or more executables are created in a program object by successfully attaching shader objects to it with **`glAttachShader`**, successfully compiling the shader objects with **`glCompileShader`**, and successfully linking the program object with **`glLinkProgram`**. These executables are made part of current state when **`glUseProgram`** is called. Program objects can be deleted by calling **`glDeleteProgram`**. The memory associated with the program object will be deleted when it is no longer part of current rendering state for any context.
    * 
    * 
    * ### Notes:
    * Like buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.
    * 
    * Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.
    * 
    * 
    * ### Errors:
    * This function returns 0 if an error occurs creating the program object.
    * 
    * * @see **`glAttachShader`**, **`glBindAttribLocation`**, **`glCreateShader`**, **`glDeleteProgram`**, **`glDetachShader`**, **`glLinkProgram`**, **`glUniform`**, **`glUseProgram`**, **`glValidateProgram`**

    **/
    static function createProgram():Int return ExtensionsNative.createProgram();
    static function createProgramObjectARB():Int return ExtensionsNative.createProgramObjectARB();
    /**
    * - #### Purpose:
    * create program pipeline objects
    * ### Description:
    * **glCreateProgramPipelines** returns **n** previously unused program pipeline names in **pipelines**, each representing a new program pipeline object initialized to the default state.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Number of program pipeline objects to create.
    * @param pipelines Specifies an array in which names of the new program pipeline objects are stored.

    * @see **`glBindProgramPipeline`**, **`glCreateShader`**, **`glCreateProgram`**, **`glCompileShader`**, **`glLinkProgram`**, **`glGenProgramPipelines`**, **`glDeleteProgramPipelines`**, **`glIsProgramPipeline`**

    **/
    static function createProgramPipelines(n:Int, pipelin_es:DataPointer):Void return ExtensionsNative.createProgramPipelines(n, pipelin_es);
    static function createProgressFenceNVX():Int return ExtensionsNative.createProgressFenceNVX();
    /**
    * - #### Purpose:
    * create query objects
    * ### Description:
    * **glCreateQueries** returns **n** previously unused query object names in **ids**, each representing a new query object with the specified **target**.
    * 
    * **target** may be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_TIME_ELAPSED`, `GL_TIMESTAMP`, `GL_PRIMITIVES_GENERATED` or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param target Specifies the target of each created query object.
    * @param n Number of query objects to create.
    * @param ids Specifies an array in which names of the new query objects are stored.

    * @see **`glBeginQuery`**, **`glBeginQueryIndexed`**, **`glDeleteQueries`**, **glEndQuery**, **`glGenQueries`**, **`glGetQueryObject`**, **`glGetQueryiv`**, **`glIsQuery`**

    **/
    static function createQueries(target:Int, n:Int, ids:DataPointer):Void return ExtensionsNative.createQueries(target, n, ids);
    /**
    * - #### Purpose:
    * create renderbuffer objects
    * ### Description:
    * **glCreateRenderbuffers** returns **n** previously unused renderbuffer object names in **renderbuffers**, each representing a new renderbuffer object initialized to the default state.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Number of renderbuffer objects to create.
    * @param renderbuffers Specifies an array in which names of the new renderbuffer objects are stored.

    * @see **`glBindRenderbuffer`**, **`glDeleteRenderbuffers`**, **`glGenRenderbuffers`**, **`glIsRenderbuffer`**, **`glRenderbufferStorage`**, **`glRenderbufferStorageMultisample`**

    **/
    static function createRenderbuffers(n:Int, renderbuffers:DataPointer):Void return ExtensionsNative.createRenderbuffers(n, renderbuffers);
    /**
    * - #### Purpose:
    * create sampler objects
    * ### Description:
    * **glCreateSamplers** returns **n** previously unused sampler names in **samplers**, each representing a new sampler object initialized to the default state.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Number of sampler objects to create.
    * @param samplers Specifies an array in which names of the new sampler objects are stored.

    * @see **`glBindSampler`**, **`glBindTexture`**, **`glDeleteSamplers`**, **`glDeleteTextures`**, **`glGenSamplers`**, **`glGenTextures`**, **`glGet`**, **`glGetSamplerParameter`**, **`glSamplerParameter`**

    **/
    static function createSamplers(n:Int, samplers:DataPointer):Void return ExtensionsNative.createSamplers(n, samplers);
    static function createSemaphoresNV(n:Int, semaphores:DataPointer):Void return ExtensionsNative.createSemaphoresNV(n, semaphores);
    /**
    * - #### Purpose:
    * Creates a shader object
    * ### Description:
    * **glCreateShader** creates an empty shader object and returns a non-zero value by which it can be referenced. A shader object is used to maintain the source code strings that define a shader. **shaderType** indicates the type of shader to be created. Five types of shader are supported. A shader of type `GL_COMPUTE_SHADER` is a shader that is intended to run on the programmable compute processor. A shader of type `GL_VERTEX_SHADER` is a shader that is intended to run on the programmable vertex processor. A shader of type `GL_TESS_CONTROL_SHADER` is a shader that is intended to run on the programmable tessellation processor in the control stage. A shader of type `GL_TESS_EVALUATION_SHADER` is a shader that is intended to run on the programmable tessellation processor in the evaluation stage. A shader of type `GL_GEOMETRY_SHADER` is a shader that is intended to run on the programmable geometry processor. A shader of type `GL_FRAGMENT_SHADER` is a shader that is intended to run on the programmable fragment processor.
    * 
    * When created, a shader object's `GL_SHADER_TYPE` parameter is set to either `GL_COMPUTE_SHADER`, `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`, depending on the value of **shaderType**.
    * 
    * 
    * ### Notes:
    * Like buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.
    * 
    * Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.
    * 
    * `GL_COMPUTE_SHADER` is available only if the GL version is 4.3 or higher.
    * 
    * 
    * ### Errors:
    * This function returns 0 if an error occurs creating the shader object.
    * 
    * `GL_INVALID_ENUM` is generated if **shaderType** is not an accepted value.
    * 
    * @param shaderType Specifies the type of shader to be created. Must be one of `GL_COMPUTE_SHADER`, `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER`, or `GL_FRAGMENT_SHADER`.

    * @see **`glAttachShader`**, **`glCompileShader`**, **`glDeleteShader`**, **`glDetachShader`**, **`glShaderSource`**

    **/
    static function createShader(type:Int):Int return ExtensionsNative.createShader(type);
    static function createShaderObjectARB(shaderType:Int):Int return ExtensionsNative.createShaderObjectARB(shaderType);
    static function createShaderProgramEXT(type:Int, strin_g:String):Int return ExtensionsNative.createShaderProgramEXT(type, strin_g);
    static function createShaderProgramv(type:Int, count:Int, strin_gs:String):Int return ExtensionsNative.createShaderProgramv(type, count, strin_gs);
    static function createShaderProgramvEXT(type:Int, count:Int, strin_gs:String):Int return ExtensionsNative.createShaderProgramvEXT(type, count, strin_gs);
    static function createStatesNV(n:Int, states:DataPointer):Void return ExtensionsNative.createStatesNV(n, states);
    static function createSyncFromCLeventARB(context:DataPointer, event:DataPointer, flags:Int):DataPointer return ExtensionsNative.createSyncFromCLeventARB(context, event, flags);
    /**
    * - #### Purpose:
    * create texture objects
    * ### Description:
    * **glCreateTextures** returns **n** previously unused texture names in **textures**, each representing a new texture object of the dimensionality and type specified by **target** and initialized to the default values for that texture type.
    * 
    * **target** must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not one of the allowable values.
    * 
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param target Specifies the effective texture target of each created texture.
    * @param n Number of texture objects to create.
    * @param textures Specifies an array in which names of the new texture objects are stored.

    * @see **`glBindTexture`**, **`glDeleteTextures`**, **`glGenTextures`**, **`glGet`**, **`glGetTexParameter`**, **`glIsTexture`**, **`glTexBuffer`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage2DMultisample`**, **`glTexImage3D`**, **`glTexImage3DMultisample`**, **`glTexParameter`**

    **/
    static function createTextures(target:Int, n:Int, textures:DataPointer):Void return ExtensionsNative.createTextures(target, n, textures);
    /**
    * - #### Purpose:
    * create transform feedback objects
    * ### Description:
    * **glCreateTransformFeedbacks** returns **n** previously unused transform feedback object names in **ids**, each representing a new transform feedback object initialized to the default state.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Number of transform feedback objects to create.
    * @param ids Specifies an array in which names of the new transform feedback objects are stored.

    * @see **`glBeginTransformFeedback`**, **`glBindTransformFeedback`**, **`glDeleteTransformFeedbacks`**, **glEndTransformFeedback**, **`glGenTransformFeedbacks`**, **`glIsTransformFeedback`**, **`glPauseTransformFeedback`**, **`glResumeTransformFeedback`**

    **/
    static function createTransformFeedbacks(n:Int, ids:DataPointer):Void return ExtensionsNative.createTransformFeedbacks(n, ids);
    /**
    * - #### Purpose:
    * create vertex array objects
    * ### Description:
    * **glCreateVertexArrays** returns **n** previously unused vertex array object names in **arrays**, each representing a new vertex array object initialized to the default state.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Number of vertex array objects to create.
    * @param arrays Specifies an array in which names of the new vertex array objects are stored.

    * @see **`glBindVertexArray`**, **`glDeleteVertexArrays`** **`glEnableVertexAttribArray`** **`glGenVertexArrays`**, **`glIsVertexArray`**, **`glVertexAttribPointer`**

    **/
    static function createVertexArrays(n:Int, arrays:DataPointer):Void return ExtensionsNative.createVertexArrays(n, arrays);
    /**
    * - #### Purpose:
    * specify whether front- or back-facing facets can be culled
    * ### Description:
    * **glCullFace** specifies whether front- or back-facing facets are culled (as specified by mode) when facet culling is enabled. Facet culling is initially disabled. To enable and disable facet culling, call the **`glEnable`** and **glDisable** commands with the argument `GL_CULL_FACE`. Facets include triangles, quadrilaterals, polygons, and rectangles.
    * 
    * **`glFrontFace`** specifies which of the clockwise and counterclockwise facets are front-facing and back-facing. See **`glFrontFace`**.
    * 
    * 
    * ### Notes:
    * If **mode** is `GL_FRONT_AND_BACK`, no facets are drawn, but other primitives such as points and lines are drawn.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * @param mode Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_BACK`.

    * @see **`glEnable`**, **`glFrontFace`**

    **/
    static function cullFace(mode:Int):Void return ExtensionsNative.cullFace(mode);
    static function cullParameterdvEXT(pname:Int, params:DataPointer):Void return ExtensionsNative.cullParameterdvEXT(pname, params);
    static function cullParameterfvEXT(pname:Int, params:DataPointer):Void return ExtensionsNative.cullParameterfvEXT(pname, params);
    static function currentPaletteMatrixARB(in_dex:Int):Void return ExtensionsNative.currentPaletteMatrixARB(in_dex);
    static function currentPaletteMatrixOES(matrixpalettein_dex:Int):Void return ExtensionsNative.currentPaletteMatrixOES(matrixpalettein_dex);
    /**
    * - #### Purpose:
    * specify a callback to receive debugging messages from the GL
    * ### Description:
    * **glDebugMessageCallback** sets the current debug output callback function to the function whose address is given in **callback**. The callback function should have the following prototype (in C), or be otherwise compatible with such a prototype:
    * 
    * This function is defined to have the same calling convention as the GL API functions. In most cases this is defined as APIENTRY, although it will vary depending on platform, language and compiler.
    * 
    * Each time a debug message is generated the debug callback function will be invoked with **source**, **type**, **id**, and **severity** associated with the message, and **length** set to the length of debug message whose character string is in the array pointed to by **message**. **userParam** will be set to the value passed in the **userParam** parameter to the most recent call to **glDebugMessageCallback**.
    * 
    * 
    * ### Notes:
    * When the GL is in use remotely, the server may not be able to call functions in the client's address space. In such cases, the callback function may not be invoked and the user should retrieve debug messages from the context's debug message log by calling **`glGetDebugMessageLog`**.
    * 
    * 
    * ### Errors:
    * @param callback The address of a callback function that will be called when a debug message is generated.
    * @param userParam A user supplied pointer that will be passed on each invocation of **callback**.

    * @see **`glDebugMessageControl`**, **`glDebugMessageInsert`**, **`glGetDebugMessageLog`**.

    **/
    static function debugMessageCallback(callback:Dynamic, userParam:DataPointer):Void return ExtensionsNative.debugMessageCallback(callback, userParam);
    static function debugMessageCallbackAMD(callback:Dynamic, userParam:DataPointer):Void return ExtensionsNative.debugMessageCallbackAMD(callback, userParam);
    static function debugMessageCallbackARB(callback:Dynamic, userParam:DataPointer):Void return ExtensionsNative.debugMessageCallbackARB(callback, userParam);
    static function debugMessageCallbackKHR(callback:Dynamic, userParam:DataPointer):Void return ExtensionsNative.debugMessageCallbackKHR(callback, userParam);
    /**
    * - #### Purpose:
    * control the reporting of debug messages in a debug context
    * ### Description:
    * **glDebugMessageControl** controls the reporting of debug messages generated by a debug context. The parameters **source**, **type** and **severity** form a filter to select messages from the pool of potential messages generated by the GL.
    * 
    * **source** may be `GL_DEBUG_SOURCE_API`, `GL_DEBUG_SOURCE_WINDOW_SYSTEM_`, `GL_DEBUG_SOURCE_SHADER_COMPILER`, `GL_DEBUG_SOURCE_THIRD_PARTY`, `GL_DEBUG_SOURCE_APPLICATION`, `GL_DEBUG_SOURCE_OTHER` to select messages generated by usage of the GL API, the window system, the shader compiler, third party tools or libraries, explicitly by the application or by some other source, respectively. It may also take the value `GL_DONT_CARE`. If **source** is not `GL_DONT_CARE` then only messages whose source matches **source** will be referenced.
    * 
    * **type** may be one of `GL_DEBUG_TYPE_ERROR`, `GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR`, `GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR`, `GL_DEBUG_TYPE_PORTABILITY`, `GL_DEBUG_TYPE_PERFORMANCE`, `GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, or `GL_DEBUG_TYPE_OTHER` to indicate the type of messages describing GL errors, attempted use of deprecated features, triggering of undefined behavior, portability issues, performance notifications, markers, group push and pop events, and other types of messages, respectively. It may also take the value `GL_DONT_CARE`. If **type** is not `GL_DONT_CARE` then only messages whose type matches **type** will be referenced.
    * 
    * **severity** may be one of `GL_DEBUG_SEVERITY_LOW`, `GL_DEBUG_SEVERITY_MEDIUM`, or `GL_DEBUG_SEVERITY_HIGH` to select messages of low, medium or high severity messages or to `GL_DEBUG_SEVERITY_NOTIFICATION` for notifications. It may also take the value `GL_DONT_CARE`. If **severity** is not `GL_DONT_CARE` then only messages whose severity matches **severity** will be referenced.
    * 
    * **ids** contains a list of **count** message identifiers to select specific messages from the pool of available messages. If **count** is zero then the value of **ids** is ignored. Otherwise, only messages appearing in this list are selected. In this case, **source** and **type** may not be `GL_DONT_CARE` and **severity** must be `GL_DONT_CARE`.
    * 
    * If **enabled** is `GL_TRUE` then messages that match the filter formed by **source**, **type**, **severity** and **ids** are enabled. Otherwise, those messages are disabled.
    * 
    * 
    * ### Notes:
    * Although debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug context may produce no messages at all.
    * 
    * `GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, and `GL_DEBUG_SEVERITY_NOTIFICATION` are available only if the GL version is 4.3 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **count** is negative.
    * 
    * `GL_INVALID_ENUM` is generated if any of **source**, **type** or **severity** is not one of the accepted interface types.
    * 
    * `GL_INVALID_OPERATION` is generated if **count** is non-zero and either **source** or **type** is `GL_DONT_CARE` or if **severity** is not `GL_DONT_CARE`.
    * 
    * @param source The source of debug messages to enable or disable.
    * @param type The type of debug messages to enable or disable.
    * @param severity The severity of debug messages to enable or disable.
    * @param count The length of the array **ids**.
    * @param ids The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
    * @param enabled A Boolean flag determining whether the selected messages should be enabled or disabled.

    * @see **`glDebugMessageInsert`**, **`glDebugMessageCallback`**, **`glGetDebugMessageLog`**.

    **/
    static function debugMessageControl(source:Int, type:Int, severity:Int, count:Int, ids:DataPointer, enabled:Bool):Void return ExtensionsNative.debugMessageControl(source, type, severity, count, ids, enabled);
    static function debugMessageControlARB(source:Int, type:Int, severity:Int, count:Int, ids:DataPointer, enabled:Bool):Void return ExtensionsNative.debugMessageControlARB(source, type, severity, count, ids, enabled);
    static function debugMessageControlKHR(source:Int, type:Int, severity:Int, count:Int, ids:DataPointer, enabled:Bool):Void return ExtensionsNative.debugMessageControlKHR(source, type, severity, count, ids, enabled);
    static function debugMessageEnableAMD(category:Int, severity:Int, count:Int, ids:DataPointer, enabled:Bool):Void return ExtensionsNative.debugMessageEnableAMD(category, severity, count, ids, enabled);
    /**
    * - #### Purpose:
    * inject an application-supplied message into the debug message queue
    * ### Description:
    * **glDebugMessageInsert** inserts a user-supplied message into the debug output queue. **source** specifies the source that will be used to classify the message and must be `GL_DEBUG_SOURCE_APPLICATION` or `GL_DEBUG_SOURCE_THIRD_PARTY`. All other sources are reserved for use by the GL implementation. **type** indicates the type of the message to be inserted and may be one of `GL_DEBUG_TYPE_ERROR`, `GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR`, `GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR`, `GL_DEBUG_TYPE_PORTABILITY`, `GL_DEBUG_TYPE_PERFORMANCE`, `GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, or `GL_DEBUG_TYPE_OTHER`. **severity** indicates the severity of the message and may be `GL_DEBUG_SEVERITY_LOW`, `GL_DEBUG_SEVERITY_MEDIUM`, `GL_DEBUG_SEVERITY_HIGH` or `GL_DEBUG_SEVERITY_NOTIFICATION`. **id** is available for application defined use and may be any value. This value will be recorded and used to identify the message.
    * 
    * **length** contains a count of the characters in the character array whose address is given in **message**. If **length** is negative then **message** is treated as a null-terminated string. The length of the message, whether specified explicitly or implicitly, must be less than or equal to the implementation defined constant `GL_MAX_DEBUG_MESSAGE_LENGTH`.
    * 
    * 
    * ### Notes:
    * `GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, and `GL_DEBUG_SEVERITY_NOTIFICATION` are available only if the GL version is 4.3 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if any of **source**, **type** or **severity** is not one of the accepted interface types.
    * 
    * `GL_INVALID_VALUE` is generated if the length of the message is greater than the value of `GL_MAX_DEBUG_MESSAGE_LENGTH`.
    * 
    * @param source The source of the debug message to insert.
    * @param type The type of the debug message insert.
    * @param id The user-supplied identifier of the message to insert.
    * @param severity The severity of the debug messages to insert.
    * @param length The length string contained in the character array whose address is given by **message**.
    * @param message The address of a character array containing the message to insert.

    * @see **`glDebugMessageControl`**, **`glDebugMessageCallback`**, **`glGetDebugMessageLog`**.

    **/
    static function debugMessageInsert(source:Int, type:Int, id:Int, severity:Int, length:Int, buf:String):Void return ExtensionsNative.debugMessageInsert(source, type, id, severity, length, buf);
    static function debugMessageInsertAMD(category:Int, severity:Int, id:Int, length:Int, buf:String):Void return ExtensionsNative.debugMessageInsertAMD(category, severity, id, length, buf);
    static function debugMessageInsertARB(source:Int, type:Int, id:Int, severity:Int, length:Int, buf:String):Void return ExtensionsNative.debugMessageInsertARB(source, type, id, severity, length, buf);
    static function debugMessageInsertKHR(source:Int, type:Int, id:Int, severity:Int, length:Int, buf:String):Void return ExtensionsNative.debugMessageInsertKHR(source, type, id, severity, length, buf);
    static function deformSGIX(mask:Int):Void return ExtensionsNative.deformSGIX(mask);
    static function deformationMap3dSGIX(target:Int, u1:DataPointer, u2:DataPointer, ustride:Int, uorder:Int, v1:DataPointer, v2:DataPointer, vstride:Int, vorder:Int, w1:DataPointer, w2:DataPointer, wstride:Int, worder:Int, poin_ts:DataPointer):Void return ExtensionsNative.deformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, poin_ts);
    static function deformationMap3fSGIX(target:Int, u1:Float, u2:Float, ustride:Int, uorder:Int, v1:Float, v2:Float, vstride:Int, vorder:Int, w1:Float, w2:Float, wstride:Int, worder:Int, poin_ts:DataPointer):Void return ExtensionsNative.deformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, poin_ts);
    static function deleteAsyncMarkersSGIX(marker:Int, range:Int):Void return ExtensionsNative.deleteAsyncMarkersSGIX(marker, range);
    /**
    * - #### Purpose:
    * delete named buffer objects
    * ### Description:
    * **glDeleteBuffers** deletes **n** buffer objects named by the elements of the array **buffers**. After a buffer object is deleted, it has no contents, and its name is free for reuse (for example by **`glGenBuffers`**). If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any buffer object).
    * 
    * **glDeleteBuffers** silently ignores 0's and names that do not correspond to existing buffer objects.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of buffer objects to be deleted.
    * @param buffers Specifies an array of buffer objects to be deleted.

    * @see **`glBindBuffer`**, **`glGenBuffers`**, **`glGet`**

    **/
    static function deleteBuffers(n:Int, buffers:DataPointer):Void return ExtensionsNative.deleteBuffers(n, buffers);
    static function deleteBuffersARB(n:Int, buffers:DataPointer):Void return ExtensionsNative.deleteBuffersARB(n, buffers);
    static function deleteCommandListsNV(n:Int, lists:DataPointer):Void return ExtensionsNative.deleteCommandListsNV(n, lists);
    static function deleteFencesAPPLE(n:Int, fences:DataPointer):Void return ExtensionsNative.deleteFencesAPPLE(n, fences);
    static function deleteFencesNV(n:Int, fences:DataPointer):Void return ExtensionsNative.deleteFencesNV(n, fences);
    static function deleteFragmentShaderATI(id:Int):Void return ExtensionsNative.deleteFragmentShaderATI(id);
    /**
    * - #### Purpose:
    * delete framebuffer objects
    * ### Description:
    * **glDeleteFramebuffers** deletes the **n** framebuffer objects whose names are stored in the array addressed by **framebuffers**. The name zero is reserved by the GL and is silently ignored, should it occur in **framebuffers**, as are other unused names. Once a framebuffer object is deleted, its name is again unused and it has no attachments. If a framebuffer that is currently bound to one or more of the targets `GL_DRAW_FRAMEBUFFER` or `GL_READ_FRAMEBUFFER` is deleted, it is as though **`glBindFramebuffer`** had been executed with the corresponding **target** and **framebuffer** zero.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of framebuffer objects to be deleted.
    * @param framebuffers A pointer to an array containing **n** framebuffer objects to be deleted.

    * @see **`glGenFramebuffers`**, **`glBindFramebuffer`**, **`glCheckFramebufferStatus`**

    **/
    static function deleteFramebuffers(n:Int, framebuffers:DataPointer):Void return ExtensionsNative.deleteFramebuffers(n, framebuffers);
    static function deleteFramebuffersEXT(n:Int, framebuffers:DataPointer):Void return ExtensionsNative.deleteFramebuffersEXT(n, framebuffers);
    static function deleteFramebuffersOES(n:Int, framebuffers:DataPointer):Void return ExtensionsNative.deleteFramebuffersOES(n, framebuffers);
    static function deleteLists(list:Int, range:Int):Void return ExtensionsNative.deleteLists(list, range);
    static function deleteMemoryObjectsEXT(n:Int, memoryObjects:DataPointer):Void return ExtensionsNative.deleteMemoryObjectsEXT(n, memoryObjects);
    static function deleteNamedStringARB(namelen:Int, name:String):Void return ExtensionsNative.deleteNamedStringARB(namelen, name);
    static function deleteNamesAMD(identifier:Int, num:Int, names:DataPointer):Void return ExtensionsNative.deleteNamesAMD(identifier, num, names);
    static function deleteObjectARB(obj:Int):Void return ExtensionsNative.deleteObjectARB(obj);
    static function deleteOcclusionQueriesNV(n:Int, ids:DataPointer):Void return ExtensionsNative.deleteOcclusionQueriesNV(n, ids);
    static function deletePathsNV(path:Int, range:Int):Void return ExtensionsNative.deletePathsNV(path, range);
    static function deletePerfMonitorsAMD(n:Int, monitors:DataPointer):Void return ExtensionsNative.deletePerfMonitorsAMD(n, monitors);
    static function deletePerfQueryINTEL(queryHandle:Int):Void return ExtensionsNative.deletePerfQueryINTEL(queryHandle);
    /**
    * - #### Purpose:
    * Deletes a program object
    * ### Description:
    * **glDeleteProgram** frees the memory and invalidates the name associated with the program object specified by **program.** This command effectively undoes the effects of a call to **`glCreateProgram`**.
    * 
    * If a program object is in use as part of current rendering state, it will be flagged for deletion, but it will not be deleted until it is no longer part of current state for any rendering context. If a program object to be deleted has shader objects attached to it, those shader objects will be automatically detached but not deleted unless they have already been flagged for deletion by a previous call to **`glDeleteShader`**. A value of 0 for **program** will be silently ignored.
    * 
    * To determine whether a program object has been flagged for deletion, call **`glGetProgram`** with arguments **program** and `GL_DELETE_STATUS`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not a value generated by OpenGL.
    * 
    * @param program Specifies the program object to be deleted.

    * @see **`glCreateShader`**, **`glDetachShader`**, **`glUseProgram`**

    **/
    static function deleteProgram(program:Int):Void return ExtensionsNative.deleteProgram(program);
    /**
    * - #### Purpose:
    * delete program pipeline objects
    * ### Description:
    * **glDeleteProgramPipelines** deletes the **n** program pipeline objects whose names are stored in the array **pipelines**. Unused names in **pipelines** are ignored, as is the name zero. After a program pipeline object is deleted, its name is again unused and it has no contents. If program pipeline object that is currently bound is deleted, the binding for that object reverts to zero and no program pipeline object becomes current.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param n Specifies the number of program pipeline objects to delete.
    * @param pipelines Specifies an array of names of program pipeline objects to delete.

    * @see **`glGenProgramPipelines`**, **`glBindProgramPipeline`**, **`glIsProgramPipeline`**, **`glUseProgramStages`**, **`glUseProgram`**

    **/
    static function deleteProgramPipelines(n:Int, pipelin_es:DataPointer):Void return ExtensionsNative.deleteProgramPipelines(n, pipelin_es);
    static function deleteProgramPipelinesEXT(n:Int, pipelin_es:DataPointer):Void return ExtensionsNative.deleteProgramPipelinesEXT(n, pipelin_es);
    static function deleteProgramsARB(n:Int, programs:DataPointer):Void return ExtensionsNative.deleteProgramsARB(n, programs);
    static function deleteProgramsNV(n:Int, programs:DataPointer):Void return ExtensionsNative.deleteProgramsNV(n, programs);
    /**
    * - #### Purpose:
    * delete named query objects
    * ### Description:
    * **glDeleteQueries** deletes **n** query objects named by the elements of the array **ids**. After a query object is deleted, it has no contents, and its name is free for reuse (for example by **`glGenQueries`**).
    * 
    * **glDeleteQueries** silently ignores 0's and names that do not correspond to existing query objects.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of query objects to be deleted.
    * @param ids Specifies an array of query objects to be deleted.

    * @see **`glBeginQuery`**, **glEndQuery**, **`glGenQueries`**, **`glGetQueryiv`**, **`glGetQueryObject`**

    **/
    static function deleteQueries(n:Int, ids:DataPointer):Void return ExtensionsNative.deleteQueries(n, ids);
    static function deleteQueriesARB(n:Int, ids:DataPointer):Void return ExtensionsNative.deleteQueriesARB(n, ids);
    static function deleteQueriesEXT(n:Int, ids:DataPointer):Void return ExtensionsNative.deleteQueriesEXT(n, ids);
    static function deleteQueryResourceTagNV(n:Int, tagIds:DataPointer):Void return ExtensionsNative.deleteQueryResourceTagNV(n, tagIds);
    /**
    * - #### Purpose:
    * delete renderbuffer objects
    * ### Description:
    * **glDeleteRenderbuffers** deletes the **n** renderbuffer objects whose names are stored in the array addressed by **renderbuffers**. The name zero is reserved by the GL and is silently ignored, should it occur in **renderbuffers**, as are other unused names. Once a renderbuffer object is deleted, its name is again unused and it has no contents. If a renderbuffer that is currently bound to the target `GL_RENDERBUFFER` is deleted, it is as though **`glBindRenderbuffer`** had been executed with a **target** of `GL_RENDERBUFFER` and a **name** of zero.
    * 
    * If a renderbuffer object is attached to one or more attachment points in the currently bound framebuffer, then it as if **`glFramebufferRenderbuffer`** had been called, with a **renderbuffer** of zero for each attachment point to which this image was attached in the currently bound framebuffer. In other words, this renderbuffer object is first detached from all attachment ponits in the currently bound framebuffer. Note that the renderbuffer image is specifically not detached from any non-bound framebuffers.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of renderbuffer objects to be deleted.
    * @param renderbuffers A pointer to an array containing **n** renderbuffer objects to be deleted.

    * @see **`glGenRenderbuffers`**, **`glFramebufferRenderbuffer`**, **`glRenderbufferStorage`**, **`glRenderbufferStorageMultisample`**

    **/
    static function deleteRenderbuffers(n:Int, renderbuffers:DataPointer):Void return ExtensionsNative.deleteRenderbuffers(n, renderbuffers);
    static function deleteRenderbuffersEXT(n:Int, renderbuffers:DataPointer):Void return ExtensionsNative.deleteRenderbuffersEXT(n, renderbuffers);
    static function deleteRenderbuffersOES(n:Int, renderbuffers:DataPointer):Void return ExtensionsNative.deleteRenderbuffersOES(n, renderbuffers);
    /**
    * - #### Purpose:
    * delete named sampler objects
    * ### Description:
    * **glDeleteSamplers** deletes **n** sampler objects named by the elements of the array **samplers**. After a sampler object is deleted, its name is again unused. If a sampler object that is currently bound to a sampler unit is deleted, it is as though **`glBindSampler`** is called with unit set to the unit the sampler is bound to and sampler zero. Unused names in samplers are silently ignored, as is the reserved name zero.
    * 
    * 
    * ### Notes:
    * **glDeleteSamplers** is available only if the GL version is 3.3 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of sampler objects to be deleted.
    * @param samplers Specifies an array of sampler objects to be deleted.

    * @see **`glGenSamplers`**, **`glBindSampler`**, **`glDeleteSamplers`**, **`glIsSampler`**

    **/
    static function deleteSamplers(count:Int, samplers:DataPointer):Void return ExtensionsNative.deleteSamplers(count, samplers);
    static function deleteSemaphoresEXT(n:Int, semaphores:DataPointer):Void return ExtensionsNative.deleteSemaphoresEXT(n, semaphores);
    /**
    * - #### Purpose:
    * Deletes a shader object
    * ### Description:
    * **glDeleteShader** frees the memory and invalidates the name associated with the shader object specified by **shader**. This command effectively undoes the effects of a call to **`glCreateShader`**.
    * 
    * If a shader object to be deleted is attached to a program object, it will be flagged for deletion, but it will not be deleted until it is no longer attached to any program object, for any rendering context (i.e., it must be detached from wherever it was attached before it will be deleted). A value of 0 for **shader** will be silently ignored.
    * 
    * To determine whether an object has been flagged for deletion, call **`glGetShader`** with arguments **shader** and `GL_DELETE_STATUS`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **shader** is not a value generated by OpenGL.
    * 
    * @param shader Specifies the shader object to be deleted.

    * @see **`glCreateProgram`**, **`glCreateShader`**, **`glDetachShader`**, **`glUseProgram`**

    **/
    static function deleteShader(shader:Int):Void return ExtensionsNative.deleteShader(shader);
    static function deleteStatesNV(n:Int, states:DataPointer):Void return ExtensionsNative.deleteStatesNV(n, states);
    /**
    * - #### Purpose:
    * delete a sync object
    * ### Description:
    * **glDeleteSync** deletes the sync object specified by **sync**. If the fence command corresponding to the specified sync object has completed, or if no **`glWaitSync`** or **`glClientWaitSync`** commands are blocking on **sync**, the object is deleted immediately. Otherwise, **sync** is flagged for deletion and will be deleted when it is no longer associated with any fence command and is no longer blocking any **`glWaitSync`** or **`glClientWaitSync`** command. In either case, after **glDeleteSync** returns, the name **sync** is invalid and can no longer be used to refer to the sync object.
    * 
    * **glDeleteSync** will silently ignore a **sync** value of zero.
    * 
    * 
    * ### Notes:
    * **glSync** is only supported if the GL version is 3.2 or greater, or if the ARB_sync extension is supported.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **sync** is neither zero or the name of a sync object.
    * 
    * @param sync The sync object to be deleted.

    * @see **`glFenceSync`**, **`glWaitSync`**, **`glClientWaitSync`**

    **/
    static function deleteSync(sync:DataPointer):Void return ExtensionsNative.deleteSync(sync);
    static function deleteSyncAPPLE(sync:DataPointer):Void return ExtensionsNative.deleteSyncAPPLE(sync);
    /**
    * - #### Purpose:
    * delete named textures
    * ### Description:
    * **glDeleteTextures** deletes **n** textures named by the elements of the array **textures**. After a texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for example by **`glGenTextures`**). If a texture that is currently bound is deleted, the binding reverts to 0 (the default texture).
    * 
    * **glDeleteTextures** silently ignores 0's and names that do not correspond to existing textures.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of textures to be deleted.
    * @param textures Specifies an array of textures to be deleted.

    * @see **`glBindTexture`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glGenTextures`**, **`glGet`**, **`glGetTexParameter`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexParameter`**

    **/
    static function deleteTextures(n:Int, textures:DataPointer):Void return ExtensionsNative.deleteTextures(n, textures);
    static function deleteTexturesEXT(n:Int, textures:DataPointer):Void return ExtensionsNative.deleteTexturesEXT(n, textures);
    /**
    * - #### Purpose:
    * delete transform feedback objects
    * ### Description:
    * **glDeleteTransformFeedbacks** deletes the **n** transform feedback objects whose names are stored in the array **ids**. Unused names in **ids** are ignored, as is the name zero. After a transform feedback object is deleted, its name is again unused and it has no contents. If an active transform feedback object is deleted, its name immediately becomes unused, but the underlying object is not deleted until it is no longer active.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param n Specifies the number of transform feedback objects to delete.
    * @param ids Specifies an array of names of transform feedback objects to delete.

    * @see **`glGenTransformFeedbacks`**, **`glBindTransformFeedback`**, **`glIsTransformFeedback`**, **`glBeginTransformFeedback`**, **`glPauseTransformFeedback`**, **`glResumeTransformFeedback`**, **glEndTransformFeedback**

    **/
    static function deleteTransformFeedbacks(n:Int, ids:DataPointer):Void return ExtensionsNative.deleteTransformFeedbacks(n, ids);
    static function deleteTransformFeedbacksNV(n:Int, ids:DataPointer):Void return ExtensionsNative.deleteTransformFeedbacksNV(n, ids);
    /**
    * - #### Purpose:
    * delete vertex array objects
    * ### Description:
    * **glDeleteVertexArrays** deletes **n** vertex array objects whose names are stored in the array addressed by **arrays**. Once a vertex array object is deleted it has no contents and its name is again unused. If a vertex array object that is currently bound is deleted, the binding for that object reverts to zero and the default vertex array becomes current. Unused names in **arrays** are silently ignored, as is the value zero.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of vertex array objects to be deleted.
    * @param arrays Specifies the address of an array containing the **n** names of the objects to be deleted.

    * @see **`glGenVertexArrays`**, **`glIsVertexArray`**, **`glBindVertexArray`**

    **/
    static function deleteVertexArrays(n:Int, arrays:DataPointer):Void return ExtensionsNative.deleteVertexArrays(n, arrays);
    static function deleteVertexArraysAPPLE(n:Int, arrays:DataPointer):Void return ExtensionsNative.deleteVertexArraysAPPLE(n, arrays);
    static function deleteVertexArraysOES(n:Int, arrays:DataPointer):Void return ExtensionsNative.deleteVertexArraysOES(n, arrays);
    static function deleteVertexShaderEXT(id:Int):Void return ExtensionsNative.deleteVertexShaderEXT(id);
    static function depthBoundsEXT(zmin_:DataPointer, zmax:DataPointer):Void return ExtensionsNative.depthBoundsEXT(zmin_, zmax);
    static function depthBoundsdNV(zmin_:DataPointer, zmax:DataPointer):Void return ExtensionsNative.depthBoundsdNV(zmin_, zmax);
    /**
    * - #### Purpose:
    * specify the value used for depth buffer comparisons
    * ### Description:
    * **glDepthFunc** specifies the function used to compare each incoming pixel depth value with the depth value present in the depth buffer. The comparison is performed only if depth testing is enabled. (See **`glEnable`** and **glDisable** of `GL_DEPTH_TEST`.)
    * 
    * **func** specifies the conditions under which the pixel will be drawn. The comparison functions are as follows:
    * 
    * *``GL_NEVER``* Never passes.
    * 
    * *``GL_LESS``* Passes if the incoming depth value is less than the stored depth value.
    * 
    * *``GL_EQUAL``* Passes if the incoming depth value is equal to the stored depth value.
    * 
    * *``GL_LEQUAL``* Passes if the incoming depth value is less than or equal to the stored depth value.
    * 
    * *``GL_GREATER``* Passes if the incoming depth value is greater than the stored depth value.
    * 
    * *``GL_NOTEQUAL``* Passes if the incoming depth value is not equal to the stored depth value.
    * 
    * *``GL_GEQUAL``* Passes if the incoming depth value is greater than or equal to the stored depth value.
    * 
    * *``GL_ALWAYS``* Always passes.
    * 
    * The initial value of **func** is `GL_LESS`. Initially, depth testing is disabled. If depth testing is disabled or if no depth buffer exists, it is as if the depth test always passes.
    * 
    * 
    * ### Notes:
    * Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test should be enabled and set to `GL_ALWAYS`.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **func** is not an accepted value.
    * 
    * @param func Specifies the depth comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_LESS`.

    * @see **`glDepthRange`**, **`glEnable`**, **`glPolygonOffset`**

    **/
    static function depthFunc(func:Int):Void return ExtensionsNative.depthFunc(func);
    /**
    * - #### Purpose:
    * enable or disable writing into the depth buffer
    * ### Description:
    * **glDepthMask** specifies whether the depth buffer is enabled for writing. If **flag** is `GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
    * 
    * 
    * ### Notes:
    * Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test should be enabled and set to `GL_ALWAYS` (see **`glDepthFunc`**).
    * 
    * 
    * ### Errors:
    * @param flag Specifies whether the depth buffer is enabled for writing. If **flag** is `GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.

    * @see **`glColorMask`**, **`glDepthFunc`**, **`glDepthRange`**, **`glStencilMask`**

    **/
    static function depthMask(flag:Bool):Void return ExtensionsNative.depthMask(flag);
    /**
    * - #### Purpose:
    * specify mapping of depth values from normalized device coordinates to window coordinates
    * ### Description:
    * After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. **glDepthRange** specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). Thus, the values accepted by **glDepthRange** are both clamped to this range before they are accepted.
    * 
    * The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
    * 
    * 
    * ### Notes:
    * It is not necessary that **nearVal** be less than **farVal**. Reverse mappings such as nearVal = 1, and farVal = 0 are acceptable.
    * 
    * The type of the **nearVal** and **farVal** parameters was changed from GLclampf to GLfloat for **glDepthRangef** and from GLclampd to GLdouble for **glDepthRange**. This change is transparent to user code and is described in detail on the **`removedTypes`** page.
    * 
    * 
    * ### Errors:
    * @param nearVal Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
    * @param farVal Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.

    * @see **`glDepthFunc`**, **`glPolygonOffset`**, **`glViewport`**, **`removedTypes`**

    **/
    static function depthRange(n:DataPointer, f:DataPointer):Void return ExtensionsNative.depthRange(n, f);
    static function depthRangeArraydvNV(first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.depthRangeArraydvNV(first, count, v);
    static function depthRangeArrayfvNV(first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.depthRangeArrayfvNV(first, count, v);
    static function depthRangeArrayfvOES(first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.depthRangeArrayfvOES(first, count, v);
    static function depthRangeArrayv(first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.depthRangeArrayv(first, count, v);
    /**
    * - #### Purpose:
    * specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
    * ### Description:
    * After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. Each viewport has an independent depth range specified as a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). **glDepthRangeIndexed** specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates for a specified viewport. Thus, the values accepted by **glDepthRangeIndexed** are both clamped to this range before they are accepted.
    * 
    * The **index** parameter specifies the index of first viewport whose depth range to modify and must be less than the value of `GL_MAX_VIEWPORTS`. **nearVal** and **farVal** specify near and far values of the depth range for the specified viewport, respectively.
    * 
    * The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
    * 
    * 
    * ### Notes:
    * It is not necessary that the near plane distance be less than the far plane distance. Reverse mappings such as nearVal = 1, and farVal = 0 are acceptable.
    * 
    * The type of the **nearVal** and **farVal** parameters was changed from GLclampd to GLdouble. This change is transparent to user code and is described in detail on the **`removedTypes`** page.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the value of `GL_MAX_VIEWPORTS`.
    * 
    * @param index Specifies the index of the viewport whose depth range to update.
    * @param nearVal Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
    * @param farVal Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.

    * @see **`glDepthFunc`**, **`glDepthRange`**, **`glDepthRangeArray`**, **`glPolygonOffset`**, **`glViewportArray`**, **`glViewport`**, **`removedTypes`**

    **/
    static function depthRangeIndexed(in_dex:Int, n:DataPointer, f:DataPointer):Void return ExtensionsNative.depthRangeIndexed(in_dex, n, f);
    static function depthRangeIndexeddNV(in_dex:Int, n:DataPointer, f:DataPointer):Void return ExtensionsNative.depthRangeIndexeddNV(in_dex, n, f);
    static function depthRangeIndexedfNV(in_dex:Int, n:Float, f:Float):Void return ExtensionsNative.depthRangeIndexedfNV(in_dex, n, f);
    static function depthRangeIndexedfOES(in_dex:Int, n:Float, f:Float):Void return ExtensionsNative.depthRangeIndexedfOES(in_dex, n, f);
    static function depthRangedNV(zNear:DataPointer, zFar:DataPointer):Void return ExtensionsNative.depthRangedNV(zNear, zFar);
    static function depthRangef(n:Float, f:Float):Void return ExtensionsNative.depthRangef(n, f);
    static function depthRangefOES(n:Float, f:Float):Void return ExtensionsNative.depthRangefOES(n, f);
    static function depthRangex(n:Int, f:Int):Void return ExtensionsNative.depthRangex(n, f);
    static function depthRangexOES(n:Int, f:Int):Void return ExtensionsNative.depthRangexOES(n, f);
    static function detachObjectARB(contain_erObj:Int, attachedObj:Int):Void return ExtensionsNative.detachObjectARB(contain_erObj, attachedObj);
    /**
    * - #### Purpose:
    * Detaches a shader object from a program object to which it is attached
    * ### Description:
    * **glDetachShader** detaches the shader object specified by **shader** from the program object specified by **program**. This command can be used to undo the effect of the command **`glAttachShader`**.
    * 
    * If **shader** has already been flagged for deletion by a call to **`glDeleteShader`** and it is not attached to any other program object, it will be deleted after it has been detached.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if either **program** or **shader** is a value that was not generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **shader** is not a shader object.
    * 
    * `GL_INVALID_OPERATION` is generated if **shader** is not attached to **program**.
    * 
    * @param program Specifies the program object from which to detach the shader object.
    * @param shader Specifies the shader object to be detached.

    * @see **`glAttachShader`**

    **/
    static function detachShader(program:Int, shader:Int):Void return ExtensionsNative.detachShader(program, shader);
    static function detailTexFuncSGIS(target:Int, n:Int, poin_ts:DataPointer):Void return ExtensionsNative.detailTexFuncSGIS(target, n, poin_ts);
    static function disable(cap:Int):Void return ExtensionsNative.disable(cap);
    static function disableClientState(array:Int):Void return ExtensionsNative.disableClientState(array);
    static function disableClientStateIndexedEXT(array:Int, in_dex:Int):Void return ExtensionsNative.disableClientStateIndexedEXT(array, in_dex);
    static function disableClientStateiEXT(array:Int, in_dex:Int):Void return ExtensionsNative.disableClientStateiEXT(array, in_dex);
    static function disableDriverControlQCOM(driverControl:Int):Void return ExtensionsNative.disableDriverControlQCOM(driverControl);
    static function disableIndexedEXT(target:Int, in_dex:Int):Void return ExtensionsNative.disableIndexedEXT(target, in_dex);
    static function disableVariantClientStateEXT(id:Int):Void return ExtensionsNative.disableVariantClientStateEXT(id);
    static function disableVertexArrayAttrib(vaobj:Int, in_dex:Int):Void return ExtensionsNative.disableVertexArrayAttrib(vaobj, in_dex);
    static function disableVertexArrayAttribEXT(vaobj:Int, in_dex:Int):Void return ExtensionsNative.disableVertexArrayAttribEXT(vaobj, in_dex);
    static function disableVertexArrayEXT(vaobj:Int, array:Int):Void return ExtensionsNative.disableVertexArrayEXT(vaobj, array);
    static function disableVertexAttribAPPLE(in_dex:Int, pname:Int):Void return ExtensionsNative.disableVertexAttribAPPLE(in_dex, pname);
    static function disableVertexAttribArray(in_dex:Int):Void return ExtensionsNative.disableVertexAttribArray(in_dex);
    static function disableVertexAttribArrayARB(in_dex:Int):Void return ExtensionsNative.disableVertexAttribArrayARB(in_dex);
    static function disablei(target:Int, in_dex:Int):Void return ExtensionsNative.disablei(target, in_dex);
    static function disableiEXT(target:Int, in_dex:Int):Void return ExtensionsNative.disableiEXT(target, in_dex);
    static function disableiNV(target:Int, in_dex:Int):Void return ExtensionsNative.disableiNV(target, in_dex);
    static function disableiOES(target:Int, in_dex:Int):Void return ExtensionsNative.disableiOES(target, in_dex);
    static function discardFramebufferEXT(target:Int, numAttachments:Int, attachments:DataPointer):Void return ExtensionsNative.discardFramebufferEXT(target, numAttachments, attachments);
    /**
    * - #### Purpose:
    * launch one or more compute work groups
    * ### Description:
    * **glDispatchCompute** launches one or more compute work groups. Each work group is processed by the active program object for the compute shader stage. While the individual shader invocations within a work group are executed as a unit, work groups are executed completely independently and in unspecified order. **num_groups_x**, **num_groups_y** and **num_groups_z** specify the number of local work groups that will be dispatched in the X, Y and Z dimensions, respectively.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if there is no active program for the compute shader stage.
    * 
    * `GL_INVALID_VALUE` is generated if any of **num_groups_x**, **num_groups_y**, or **num_groups_z** is greater than or equal to the maximum work-group count for the corresponding dimension.
    * 
    * @param num_groups_x The number of work groups to be launched in the X dimension.
    * @param num_groups_y The number of work groups to be launched in the Y dimension.
    * @param num_groups_z The number of work groups to be launched in the Z dimension.

    * @see **`glDispatchComputeIndirect`**.

    **/
    static function dispatchCompute(num_groups_x:Int, num_groups_y:Int, num_groups_z:Int):Void return ExtensionsNative.dispatchCompute(num_groups_x, num_groups_y, num_groups_z);
    static function dispatchComputeGroupSizeARB(num_groups_x:Int, num_groups_y:Int, num_groups_z:Int, group_size_x:Int, group_size_y:Int, group_size_z:Int):Void return ExtensionsNative.dispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
    /**
    * - #### Purpose:
    * launch one or more compute work groups using parameters stored in a buffer
    * ### Description:
    * **glDispatchComputeIndirect** launches one or more compute work groups using parameters stored in the buffer object currently bound to the `GL_DISPATCH_INDIRECT_BUFFER` target. Each work group is processed by the active program object for the compute shader stage. While the individual shader invocations within a work group are executed as a unit, work groups are executed completely independently and in unspecified order. **indirect** contains the offset into the data store of the buffer object bound to the `GL_DISPATCH_INDIRECT_BUFFER` target at which the parameters are stored.
    * 
    * The parameters addressed by **indirect** are packed a structure, which takes the form (in C): typedef struct { uint num_groups_x; uint num_groups_y; uint num_groups_z; } DispatchIndirectCommand;
    * 
    * A call to **glDispatchComputeIndirect** is equivalent, assuming no errors are generated, to: cmd = (const DispatchIndirectCommand *)indirect; glDispatchCompute(cmd-&gt;num_groups_x, cmd-&gt;num_groups_y, cmd-&gt;num_groups_z);
    * 
    * Unlike **`glDispatchCompute`**, no error is generated if any of the num_groups_x, num_groups_y or num_groups_z members of the DispatchIndirectCommand is larger than the value of `GL_MAX_COMPUTE_WORK_GROUP_COUNT` for the corresponding dimension. In such circumstances, behavior is undefined and may lead to application termination.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if there is no active program for the compute shader stage.
    * 
    * `GL_INVALID_VALUE` is generated if **indirect** is less than zero or not a multiple of four.
    * 
    * `GL_INVALID_OPERATION` is generated if no buffer is bound to the `GL_DISPATCH_INDIRECT_BUFFER` target or if the command would source data beyond the end of the buffer object's data store.
    * 
    * @param indirect The offset into the buffer object currently bound to the `GL_DISPATCH_INDIRECT_BUFFER` buffer target at which the dispatch parameters are stored.

    * @see **`glDispatchCompute`**.

    **/
    static function dispatchComputeIndirect(in_direct:Int):Void return ExtensionsNative.dispatchComputeIndirect(in_direct);
    /**
    * - #### Purpose:
    * render primitives from array data
    * ### Description:
    * **glDrawArrays** specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to **glDrawArrays**.
    * 
    * When **glDrawArrays** is called, it uses **count** sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element **first**. **mode** specifies what kind of primitives are constructed and how the array elements construct those primitives.
    * 
    * Vertex attributes that are modified by **glDrawArrays** have an unspecified value after **glDrawArrays** returns. Attributes that aren't modified remain well defined.
    * 
    * 
    * ### Notes:
    * `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **count** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param first Specifies the starting index in the enabled arrays.
    * @param count Specifies the number of indices to be rendered.

    * @see **`glDrawArraysInstanced`**, **`glDrawElements`**, **`glDrawRangeElements`**,

    **/
    static function drawArrays(mode:Int, first:Int, count:Int):Void return ExtensionsNative.drawArrays(mode, first, count);
    static function drawArraysEXT(mode:Int, first:Int, count:Int):Void return ExtensionsNative.drawArraysEXT(mode, first, count);
    /**
    * - #### Purpose:
    * render primitives from array data, taking parameters from memory
    * ### Description:
    * **glDrawArraysIndirect** specifies multiple geometric primitives with very few subroutine calls. **glDrawArraysIndirect** behaves similarly to **`glDrawArraysInstancedBaseInstance`**, execept that the parameters to **`glDrawArraysInstancedBaseInstance`** are stored in memory at the address given by **indirect**.
    * 
    * The parameters addressed by **indirect** are packed into a structure that takes the form (in C): typedef struct { uint count; uint instanceCount; uint first; uint baseInstance; } DrawArraysIndirectCommand; const DrawArraysIndirectCommand *cmd = (const DrawArraysIndirectCommand *)indirect; glDrawArraysInstancedBaseInstance(mode, cmd-&gt;first, cmd-&gt;count, cmd-&gt;instanceCount, cmd-&gt;baseInstance);
    * 
    * If a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to **glDrawArraysIndirect**, **indirect** is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory.
    * 
    * In contrast to **`glDrawArraysInstancedBaseInstance`**, the first member of the parameter structure is unsigned, and out-of-range indices do not generate an error.
    * 
    * Vertex attributes that are modified by **glDrawArraysIndirect** have an unspecified value after **glDrawArraysIndirect** returns. Attributes that aren't modified remain well defined.
    * 
    * 
    * ### Notes:
    * The **baseInstance** member of the **DrawArraysIndirectCommand** structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **mode** is `GL_PATCHES` and no tessellation control shader is active.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.
    * @param indirect Specifies the address of a structure containing the draw parameters.

    * @see **`glDrawArrays`**, **`glDrawArraysInstanced`**, **`glDrawElements`**, **`glDrawRangeElements`**,

    **/
    static function drawArraysIndirect(mode:Int, in_direct:DataPointer):Void return ExtensionsNative.drawArraysIndirect(mode, in_direct);
    /**
    * - #### Purpose:
    * draw multiple instances of a range of elements
    * ### Description:
    * **glDrawArraysInstanced** behaves identically to **`glDrawArrays`** except that **instancecount** instances of the range of elements are executed and the value of the internal counter **instanceID** advances for each iteration. **instanceID** is an internal 32-bit integer counter that may be read by a vertex shader as `gl_InstanceID`.
    * 
    * **glDrawArraysInstanced** has the same effect as: if ( mode or count is invalid ) generate appropriate error else { for (int i = 0; i &lt; instancecount ; i++) { instanceID = i; glDrawArrays(mode, first, count); } instanceID = 0; }
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not one of the accepted values.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_VALUE` is generated if **count** or **instancecount** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES` `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param first Specifies the starting index in the enabled arrays.
    * @param count Specifies the number of indices to be rendered.
    * @param instancecount Specifies the number of instances of the specified range of indices to be rendered.

    * @see **`glDrawArrays`**, **`glDrawElementsInstanced`**

    **/
    static function drawArraysInstanced(mode:Int, first:Int, count:Int, in_stancecount:Int):Void return ExtensionsNative.drawArraysInstanced(mode, first, count, in_stancecount);
    static function drawArraysInstancedANGLE(mode:Int, first:Int, count:Int, primcount:Int):Void return ExtensionsNative.drawArraysInstancedANGLE(mode, first, count, primcount);
    static function drawArraysInstancedARB(mode:Int, first:Int, count:Int, primcount:Int):Void return ExtensionsNative.drawArraysInstancedARB(mode, first, count, primcount);
    /**
    * - #### Purpose:
    * draw multiple instances of a range of elements with offset applied to instanced attributes
    * ### Description:
    * **glDrawArraysInstancedBaseInstance** behaves identically to **`glDrawArrays`** except that **instancecount** instances of the range of elements are executed and the value of the internal counter **instanceID** advances for each iteration. **instanceID** is an internal 32-bit integer counter that may be read by a vertex shader as `gl_InstanceID`.
    * 
    * **glDrawArraysInstancedBaseInstance** has the same effect as: if ( mode or count is invalid ) generate appropriate error else { for (int i = 0; i &lt; instancecount ; i++) { instanceID = i; glDrawArrays(mode, first, count); } instanceID = 0; }
    * 
    * Specific vertex attributes may be classified as instanced through the use of **`glVertexAttribDivisor`**. Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as: gl _ InstanceID divisor &amp;plus; baseInstance. Note that **baseinstance** does not affect the shader-visible value of `gl_InstanceID`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not one of the accepted values.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_VALUE` is generated if **count** or **instancecount** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES` `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param first Specifies the starting index in the enabled arrays.
    * @param count Specifies the number of indices to be rendered.
    * @param instancecount Specifies the number of instances of the specified range of indices to be rendered.
    * @param baseinstance Specifies the base instance for use in fetching instanced vertex attributes.

    * @see **`glDrawArrays`**, **`glDrawElementsInstanced`**

    **/
    static function drawArraysInstancedBaseInstance(mode:Int, first:Int, count:Int, in_stancecount:Int, basein_stance:Int):Void return ExtensionsNative.drawArraysInstancedBaseInstance(mode, first, count, in_stancecount, basein_stance);
    static function drawArraysInstancedBaseInstanceEXT(mode:Int, first:Int, count:Int, in_stancecount:Int, basein_stance:Int):Void return ExtensionsNative.drawArraysInstancedBaseInstanceEXT(mode, first, count, in_stancecount, basein_stance);
    static function drawArraysInstancedEXT(mode:Int, start:Int, count:Int, primcount:Int):Void return ExtensionsNative.drawArraysInstancedEXT(mode, start, count, primcount);
    static function drawArraysInstancedNV(mode:Int, first:Int, count:Int, primcount:Int):Void return ExtensionsNative.drawArraysInstancedNV(mode, first, count, primcount);
    /**
    * - #### Purpose:
    * specify which color buffers are to be drawn into
    * ### Description:
    * When colors are written to the frame buffer, they are written into the color buffers specified by **glDrawBuffer**. One of the following values can be used for default framebuffer:
    * 
    * *``GL_NONE``* No color buffers are written.
    * 
    * *``GL_FRONT_LEFT``* Only the front left color buffer is written.
    * 
    * *``GL_FRONT_RIGHT``* Only the front right color buffer is written.
    * 
    * *``GL_BACK_LEFT``* Only the back left color buffer is written.
    * 
    * *``GL_BACK_RIGHT``* Only the back right color buffer is written.
    * 
    * *``GL_FRONT``* Only the front left and front right color buffers are written. If there is no front right color buffer, only the front left color buffer is written.
    * 
    * *``GL_BACK``* Only the back left and back right color buffers are written. If there is no back right color buffer, only the back left color buffer is written.
    * 
    * *``GL_LEFT``* Only the front left and back left color buffers are written. If there is no back left color buffer, only the front left color buffer is written.
    * 
    * *``GL_RIGHT``* Only the front right and back right color buffers are written. If there is no back right color buffer, only the front right color buffer is written.
    * 
    * *``GL_FRONT_AND_BACK``* All the front and back color buffers (front left, front right, back left, back right) are written. If there are no back color buffers, only the front left and front right color buffers are written. If there are no right color buffers, only the front left and back left color buffers are written. If there are no right or back color buffers, only the front left color buffer is written.
    * 
    * If more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently for each color buffer and can produce different results in each buffer.
    * 
    * Monoscopic contexts include only left buffers, and stereoscopic contexts include both left and right buffers. Likewise, single-buffered contexts include only front buffers, and double-buffered contexts include both front and back buffers. The context is selected at GL initialization.
    * 
    * For framebuffer objects, `GL_COLOR_ATTACHMENT$m$` and `GL_NONE` enums are accepted, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`. glDrawBuffer will set the draw buffer for fragment colors other than zero to `GL_NONE`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` error is generated by **glNamedFramebufferDrawBuffer** if **framebuffer** is not zero or the name of an existing framebuffer object.
    * 
    * `GL_INVALID_ENUM` is generated if **buf** is not an accepted value.
    * 
    * `GL_INVALID_OPERATION` is generated if the default framebuffer is affected and none of the buffers indicated by **buf** exists.
    * 
    * `GL_INVALID_OPERATION` is generated if a framebuffer object is affected and **buf** is not equal to `GL_NONE` or `GL_COLOR_ATTACHMENT$m$`, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`.
    * 
    * @param framebuffer Specifies the name of the framebuffer object for **glNamedFramebufferDrawBuffer** function. Must be zero or the name of a framebuffer object.
    * @param buf For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants `GL_NONE`, `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_FRONT` for single-buffered contexts, and `GL_BACK` for double-buffered contexts. For framebuffer objects, `GL_COLOR_ATTACHMENT$m$` and `GL_NONE` enums are accepted, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`.

    * @see **`glBlendFunc`**, **`glColorMask`**, **`glDrawBuffers`**, **`glLogicOp`**, **`glReadBuffer`**

    **/
    static function drawBuffer(buf:Int):Void return ExtensionsNative.drawBuffer(buf);
    /**
    * - #### Purpose:
    * Specifies a list of color buffers to be drawn
        into
    * ### Description:
    * **glDrawBuffers** and **glNamedFramebufferDrawBuffers** define an array of buffers into which outputs from the fragment shader data will be written. If a fragment shader writes a value to one or more user defined output variables, then the value of each variable will be written into the buffer specified at a location within **bufs** corresponding to the location assigned to that user defined output. The draw buffer used for user defined outputs assigned to locations greater than or equal to **n** is implicitly set to `GL_NONE` and any data written to such an output is discarded.
    * 
    * For **glDrawBuffers**, the framebuffer object that is bound to the `GL_DRAW_FRAMEBUFFER` binding will be used. For **glNamedFramebufferDrawBuffers**, **framebuffer** is the name of the framebuffer object. If **framebuffer** is zero, then the default framebuffer is affected.
    * 
    * The symbolic constants contained in **bufs** may be any of the following:
    * 
    * *``GL_NONE``* The fragment shader output value is not written into any color buffer.
    * 
    * *``GL_FRONT_LEFT``* The fragment shader output value is written into the front left color buffer.
    * 
    * *``GL_FRONT_RIGHT``* The fragment shader output value is written into the front right color buffer.
    * 
    * *``GL_BACK_LEFT``* The fragment shader output value is written into the back left color buffer.
    * 
    * *``GL_BACK_RIGHT``* The fragment shader output value is written into the back right color buffer.
    * 
    * *``GL_COLOR_ATTACHMENT`n`* The fragment shader output value is written into the nth color attachment of the current framebuffer. n may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS`.
    * 
    * Except for `GL_NONE`, the preceding symbolic constants may not appear more than once in **bufs**. The maximum number of draw buffers supported is implementation dependent and can be queried by calling **`glGet`** with the argument `GL_MAX_DRAW_BUFFERS`.
    * 
    * 
    * ### Notes:
    * The symbolic constants `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and `GL_FRONT_AND_BACK` are not allowed in the **bufs** array since they may refer to multiple buffers.
    * 
    * If a fragment shader does not write to a user defined output variable, the values of the fragment colors following shader execution are undefined. For each fragment generated in this situation, a different value may be written into each of the buffers specified by **bufs**.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` error is generated by **glNamedFramebufferDrawBuffers** if **framebuffer** is not zero or the name of an existing framebuffer object.
    * 
    * `GL_INVALID_ENUM` is generated if one of the values in **bufs** is not an accepted value.
    * 
    * `GL_INVALID_ENUM` is generated if the API call refers to the default framebuffer and one or more of the values in **bufs** is one of the `GL_COLOR_ATTACHMENT`n tokens.
    * 
    * `GL_INVALID_ENUM` is generated if the API call refers to a framebuffer object and one or more of the values in **bufs** is anything other than `GL_NONE` or one of the `GL_COLOR_ATTACHMENT`n tokens.
    * 
    * `GL_INVALID_ENUM` is generated if **n** is less than 0.
    * 
    * `GL_INVALID_OPERATION` is generated if a symbolic constant other than `GL_NONE` appears more than once in **bufs**.
    * 
    * `GL_INVALID_OPERATION` is generated if any of the entries in **bufs** (other than `GL_NONE` ) indicates a color buffer that does not exist in the current GL context.
    * 
    * `GL_INVALID_OPERATION` is generated if any value in **bufs** is `GL_BACK`, and **n** is not one.
    * 
    * `GL_INVALID_VALUE` is generated if **n** is greater than `GL_MAX_DRAW_BUFFERS`.
    * 
    * @param framebuffer Specifies the name of the framebuffer object for **glNamedFramebufferDrawBuffers**.
    * @param n Specifies the number of buffers in **bufs**.
    * @param bufs Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.

    * @see **`glBlendFunc`**, **`glColorMask`**, **`glDrawBuffers`**, **`glLogicOp`**, **`glReadBuffer`**

    **/
    static function drawBuffers(n:Int, bufs:DataPointer):Void return ExtensionsNative.drawBuffers(n, bufs);
    static function drawBuffersARB(n:Int, bufs:DataPointer):Void return ExtensionsNative.drawBuffersARB(n, bufs);
    static function drawBuffersATI(n:Int, bufs:DataPointer):Void return ExtensionsNative.drawBuffersATI(n, bufs);
    static function drawBuffersEXT(n:Int, bufs:DataPointer):Void return ExtensionsNative.drawBuffersEXT(n, bufs);
    static function drawBuffersIndexedEXT(n:Int, location:DataPointer, in_dices:DataPointer):Void return ExtensionsNative.drawBuffersIndexedEXT(n, location, in_dices);
    static function drawBuffersNV(n:Int, bufs:DataPointer):Void return ExtensionsNative.drawBuffersNV(n, bufs);
    static function drawCommandsAddressNV(primitiveMode:Int, in_directs:DataPointer, sizes:DataPointer, count:Int):Void return ExtensionsNative.drawCommandsAddressNV(primitiveMode, in_directs, sizes, count);
    static function drawCommandsNV(primitiveMode:Int, buffer:Int, in_directs:DataPointer, sizes:DataPointer, count:Int):Void return ExtensionsNative.drawCommandsNV(primitiveMode, buffer, in_directs, sizes, count);
    static function drawCommandsStatesAddressNV(in_directs:DataPointer, sizes:DataPointer, states:DataPointer, fbos:DataPointer, count:Int):Void return ExtensionsNative.drawCommandsStatesAddressNV(in_directs, sizes, states, fbos, count);
    static function drawCommandsStatesNV(buffer:Int, in_directs:DataPointer, sizes:DataPointer, states:DataPointer, fbos:DataPointer, count:Int):Void return ExtensionsNative.drawCommandsStatesNV(buffer, in_directs, sizes, states, fbos, count);
    static function drawElementArrayAPPLE(mode:Int, first:Int, count:Int):Void return ExtensionsNative.drawElementArrayAPPLE(mode, first, count);
    static function drawElementArrayATI(mode:Int, count:Int):Void return ExtensionsNative.drawElementArrayATI(mode, count);
    /**
    * - #### Purpose:
    * render primitives from array data
    * ### Description:
    * **glDrawElements** specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to **glDrawElements**.
    * 
    * When **glDrawElements** is called, it uses **count** sequential elements from an enabled array, starting at **indices** to construct a sequence of geometric primitives. **mode** specifies what kind of primitives are constructed and how the array elements construct these primitives. If more than one array is enabled, each is used.
    * 
    * Vertex attributes that are modified by **glDrawElements** have an unspecified value after **glDrawElements** returns. Attributes that aren't modified maintain their previous values.
    * 
    * 
    * ### Notes:
    * `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **count** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param count Specifies the number of elements to be rendered.
    * @param type Specifies the type of the values in **indices**. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.
    * @param indices Specifies a pointer to the location where the indices are stored.

    * @see **`glDrawArrays`**, **`glDrawElementsInstanced`**, **`glDrawElementsBaseVertex`**, **`glDrawRangeElements`**

    **/
    static function drawElements(mode:Int, count:Int, type:Int, in_dices:DataPointer):Void return ExtensionsNative.drawElements(mode, count, type, in_dices);
    /**
    * - #### Purpose:
    * render primitives from array data with a per-element offset
    * ### Description:
    * **glDrawElementsBaseVertex** behaves identically to **`glDrawElements`** except that the ith element transferred by the corresponding draw call will be taken from element **indices**[i] + **basevertex** of each enabled array. If the resulting value is larger than the maximum value representable by **type**, it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
    * 
    * 
    * ### Notes:
    * **glDrawElementsBaseVertex** is only supported if the GL version is 3.2 or greater, or if the ARB_draw_elements_base_vertex extension is supported.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **count** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param count Specifies the number of elements to be rendered.
    * @param type Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.
    * @param indices Specifies a pointer to the location where the indices are stored.
    * @param basevertex Specifies a constant that should be added to each element of **indices** when chosing elements from the enabled vertex arrays.

    * @see **`glDrawElements`**, **`glDrawRangeElements`**, **`glDrawRangeElementsBaseVertex`**, **`glDrawElementsInstanced`**, **`glDrawElementsInstancedBaseVertex`**

    **/
    static function drawElementsBaseVertex(mode:Int, count:Int, type:Int, in_dices:DataPointer, basevertex:Int):Void return ExtensionsNative.drawElementsBaseVertex(mode, count, type, in_dices, basevertex);
    static function drawElementsBaseVertexEXT(mode:Int, count:Int, type:Int, in_dices:DataPointer, basevertex:Int):Void return ExtensionsNative.drawElementsBaseVertexEXT(mode, count, type, in_dices, basevertex);
    static function drawElementsBaseVertexOES(mode:Int, count:Int, type:Int, in_dices:DataPointer, basevertex:Int):Void return ExtensionsNative.drawElementsBaseVertexOES(mode, count, type, in_dices, basevertex);
    /**
    * - #### Purpose:
    * render indexed primitives from array data, taking parameters from memory
    * ### Description:
    * **glDrawElementsIndirect** specifies multiple indexed geometric primitives with very few subroutine calls. **glDrawElementsIndirect** behaves similarly to **`glDrawElementsInstancedBaseVertexBaseInstance`**, execpt that the parameters to **`glDrawElementsInstancedBaseVertexBaseInstance`** are stored in memory at the address given by **indirect**.
    * 
    * The parameters addressed by **indirect** are packed into a structure that takes the form (in C):
    * 
    * **glDrawElementsIndirect** is equivalent to:
    * 
    * void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect) { const DrawElementsIndirectCommand *cmd = (const DrawElementsIndirectCommand *)indirect; glDrawElementsInstancedBaseVertexBaseInstance(mode, cmd-&gt;count, type, cmd-&gt;firstIndex * size-of-type, cmd-&gt;instanceCount, cmd-&gt;baseVertex, cmd-&gt;baseInstance); }
    * 
    * If a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to **glDrawElementsIndirect**, **indirect** is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory.
    * 
    * Note that indices stored in client memory are not supported. If no buffer is bound to the `GL_ELEMENT_ARRAY_BUFFER` binding, an error will be generated.
    * 
    * The results of the operation are undefined if the reservedMustBeZero member of the parameter structure is non-zero. However, no error is generated in this case.
    * 
    * Vertex attributes that are modified by **glDrawElementsIndirect** have an unspecified value after **glDrawElementsIndirect** returns. Attributes that aren't modified remain well defined.
    * 
    * 
    * ### Notes:
    * The **baseInstance** member of the **DrawElementsIndirectCommand** structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_OPERATION` is generated if zero is bound to the `GL_ELEMENT_ARRAY_BUFFER` binding, or if such a buffer's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **mode** is `GL_PATCHES` and no tessellation control shader is active.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.
    * @param type Specifies the type of data in the buffer bound to the `GL_ELEMENT_ARRAY_BUFFER` binding.
    * @param indirect Specifies the address of a structure containing the draw parameters.

    * @see **`glDrawArrays`**, **`glDrawArraysInstanced`**, **`glDrawArraysIndirect`**, **`glDrawElements`**, **`glDrawRangeElements`**,

    **/
    static function drawElementsIndirect(mode:Int, type:Int, in_direct:DataPointer):Void return ExtensionsNative.drawElementsIndirect(mode, type, in_direct);
    /**
    * - #### Purpose:
    * draw multiple instances of a set of elements
    * ### Description:
    * **glDrawElementsInstanced** behaves identically to **`glDrawElements`** except that **instancecount** instances of the set of elements are executed and the value of the internal counter **instanceID** advances for each iteration. **instanceID** is an internal 32-bit integer counter that may be read by a vertex shader as `gl_InstanceID`.
    * 
    * **glDrawElementsInstanced** has the same effect as: if (mode, count, or type is invalid ) generate appropriate error else { for (int i = 0; i &lt; instancecount ; i++) { instanceID = i; glDrawElements(mode, count, type, indices); } instanceID = 0; }
    * 
    * 
    * ### Notes:
    * **glDrawElementsInstanced** is available only if the GL version is 3.1 or greater.
    * 
    * `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not one of `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, or `GL_TRIANGLES`.
    * 
    * `GL_INVALID_VALUE` is generated if **count** or **instancecount** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param count Specifies the number of elements to be rendered.
    * @param type Specifies the type of the values in **indices**. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.
    * @param indices Specifies a pointer to the location where the indices are stored.
    * @param instancecount Specifies the number of instances of the specified range of indices to be rendered.

    * @see **`glDrawElements`**, **`glDrawArraysInstanced`**

    **/
    static function drawElementsInstanced(mode:Int, count:Int, type:Int, in_dices:DataPointer, in_stancecount:Int):Void return ExtensionsNative.drawElementsInstanced(mode, count, type, in_dices, in_stancecount);
    static function drawElementsInstancedANGLE(mode:Int, count:Int, type:Int, in_dices:DataPointer, primcount:Int):Void return ExtensionsNative.drawElementsInstancedANGLE(mode, count, type, in_dices, primcount);
    static function drawElementsInstancedARB(mode:Int, count:Int, type:Int, in_dices:DataPointer, primcount:Int):Void return ExtensionsNative.drawElementsInstancedARB(mode, count, type, in_dices, primcount);
    /**
    * - #### Purpose:
    * draw multiple instances of a set of elements with offset applied to instanced attributes
    * ### Description:
    * **glDrawElementsInstancedBaseInstance** behaves identically to **`glDrawElements`** except that **instancecount** instances of the set of elements are executed and the value of the internal counter **instanceID** advances for each iteration. **instanceID** is an internal 32-bit integer counter that may be read by a vertex shader as `gl_InstanceID`.
    * 
    * **glDrawElementsInstancedBaseInstance** has the same effect as: if (mode, count, or type is invalid ) generate appropriate error else { for (int i = 0; i &lt; instancecount ; i++) { instanceID = i; glDrawElements(mode, count, type, indices); } instanceID = 0; }
    * 
    * Specific vertex attributes may be classified as instanced through the use of **`glVertexAttribDivisor`**. Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as gl _ InstanceID divisor &amp;plus; baseInstance. Note that **baseinstance** does not affect the shader-visible value of `gl_InstanceID`.
    * 
    * 
    * ### Notes:
    * **glDrawElementsInstancedBaseInstance** is available only if the GL version is 4.2 or greater.
    * 
    * `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not one of `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, or `GL_TRIANGLES`.
    * 
    * `GL_INVALID_VALUE` is generated if **count** or **instancecount** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param count Specifies the number of elements to be rendered.
    * @param type Specifies the type of the values in **indices**. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.
    * @param indices Specifies a pointer to the location where the indices are stored.
    * @param instancecount Specifies the number of instances of the specified range of indices to be rendered.
    * @param baseinstance Specifies the base instance for use in fetching instanced vertex attributes.

    * @see **`glDrawElements`**, **`glDrawArraysInstanced`**

    **/
    static function drawElementsInstancedBaseInstance(mode:Int, count:Int, type:Int, in_dices:DataPointer, in_stancecount:Int, basein_stance:Int):Void return ExtensionsNative.drawElementsInstancedBaseInstance(mode, count, type, in_dices, in_stancecount, basein_stance);
    static function drawElementsInstancedBaseInstanceEXT(mode:Int, count:Int, type:Int, in_dices:DataPointer, in_stancecount:Int, basein_stance:Int):Void return ExtensionsNative.drawElementsInstancedBaseInstanceEXT(mode, count, type, in_dices, in_stancecount, basein_stance);
    /**
    * - #### Purpose:
    * render multiple instances of a set of primitives from array data with a per-element offset
    * ### Description:
    * **glDrawElementsInstancedBaseVertex** behaves identically to **`glDrawElementsInstanced`** except that the ith element transferred by the corresponding draw call will be taken from element **indices**[i] + **basevertex** of each enabled array. If the resulting value is larger than the maximum value representable by **type**, it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
    * 
    * 
    * ### Notes:
    * **glDrawElementsInstancedBaseVertex** is only supported if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **count** or **instancecount** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param count Specifies the number of elements to be rendered.
    * @param type Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.
    * @param indices Specifies a pointer to the location where the indices are stored.
    * @param instancecount Specifies the number of instances of the indexed geometry that should be drawn.
    * @param basevertex Specifies a constant that should be added to each element of **indices** when chosing elements from the enabled vertex arrays.

    * @see **`glDrawElements`**, **`glDrawRangeElements`**, **`glDrawRangeElementsBaseVertex`**, **`glDrawElementsInstanced`**, **`glDrawElementsInstancedBaseVertex`**

    **/
    static function drawElementsInstancedBaseVertex(mode:Int, count:Int, type:Int, in_dices:DataPointer, in_stancecount:Int, basevertex:Int):Void return ExtensionsNative.drawElementsInstancedBaseVertex(mode, count, type, in_dices, in_stancecount, basevertex);
    /**
    * - #### Purpose:
    * render multiple instances of a set of primitives from array data with a per-element offset
    * ### Description:
    * **glDrawElementsInstancedBaseVertexBaseInstance** behaves identically to **`glDrawElementsInstanced`** except that the ith element transferred by the corresponding draw call will be taken from element **indices**[i] + **basevertex** of each enabled array. If the resulting value is larger than the maximum value representable by **type**, it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
    * 
    * Specific vertex attributes may be classified as instanced through the use of **`glVertexAttribDivisor`**. Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as gl _ InstanceID divisor &amp;plus; baseInstance. Note that **baseinstance** does not affect the shader-visible value of `gl_InstanceID`.
    * 
    * 
    * ### Notes:
    * **glDrawElementsInstancedBaseVertex** is only supported if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **count** or **instancecount** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param count Specifies the number of elements to be rendered.
    * @param type Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.
    * @param indices Specifies a pointer to the location where the indices are stored.
    * @param instancecount Specifies the number of instances of the indexed geometry that should be drawn.
    * @param basevertex Specifies a constant that should be added to each element of **indices** when chosing elements from the enabled vertex arrays.
    * @param baseinstance Specifies the base instance for use in fetching instanced vertex attributes.

    * @see **`glDrawElements`**, **`glDrawRangeElements`**, **`glDrawRangeElementsBaseVertex`**, **`glDrawElementsInstanced`**, **`glDrawElementsInstancedBaseVertex`**

    **/
    static function drawElementsInstancedBaseVertexBaseInstance(mode:Int, count:Int, type:Int, in_dices:DataPointer, in_stancecount:Int, basevertex:Int, basein_stance:Int):Void return ExtensionsNative.drawElementsInstancedBaseVertexBaseInstance(mode, count, type, in_dices, in_stancecount, basevertex, basein_stance);
    static function drawElementsInstancedBaseVertexBaseInstanceEXT(mode:Int, count:Int, type:Int, in_dices:DataPointer, in_stancecount:Int, basevertex:Int, basein_stance:Int):Void return ExtensionsNative.drawElementsInstancedBaseVertexBaseInstanceEXT(mode, count, type, in_dices, in_stancecount, basevertex, basein_stance);
    static function drawElementsInstancedBaseVertexEXT(mode:Int, count:Int, type:Int, in_dices:DataPointer, in_stancecount:Int, basevertex:Int):Void return ExtensionsNative.drawElementsInstancedBaseVertexEXT(mode, count, type, in_dices, in_stancecount, basevertex);
    static function drawElementsInstancedBaseVertexOES(mode:Int, count:Int, type:Int, in_dices:DataPointer, in_stancecount:Int, basevertex:Int):Void return ExtensionsNative.drawElementsInstancedBaseVertexOES(mode, count, type, in_dices, in_stancecount, basevertex);
    static function drawElementsInstancedEXT(mode:Int, count:Int, type:Int, in_dices:DataPointer, primcount:Int):Void return ExtensionsNative.drawElementsInstancedEXT(mode, count, type, in_dices, primcount);
    static function drawElementsInstancedNV(mode:Int, count:Int, type:Int, in_dices:DataPointer, primcount:Int):Void return ExtensionsNative.drawElementsInstancedNV(mode, count, type, in_dices, primcount);
    static function drawMeshArraysSUN(mode:Int, first:Int, count:Int, width:Int):Void return ExtensionsNative.drawMeshArraysSUN(mode, first, count, width);
    static function drawMeshTasksNV(first:Int, count:Int):Void return ExtensionsNative.drawMeshTasksNV(first, count);
    static function drawMeshTasksIndirectNV(in_direct:Int):Void return ExtensionsNative.drawMeshTasksIndirectNV(in_direct);
    static function drawPixels(width:Int, height:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.drawPixels(width, height, format, type, pixels);
    static function drawRangeElementArrayAPPLE(mode:Int, start:Int, end:Int, first:Int, count:Int):Void return ExtensionsNative.drawRangeElementArrayAPPLE(mode, start, end, first, count);
    static function drawRangeElementArrayATI(mode:Int, start:Int, end:Int, count:Int):Void return ExtensionsNative.drawRangeElementArrayATI(mode, start, end, count);
    /**
    * - #### Purpose:
    * render primitives from array data
    * ### Description:
    * **glDrawRangeElements** is a restricted form of **`glDrawElements`**. **mode**, and **count** match the corresponding arguments to **`glDrawElements`**, with the additional constraint that all values in the arrays **count** must lie between **start** and **end**, inclusive.
    * 
    * Implementations denote recommended maximum amounts of vertex and index data, which may be queried by calling **`glGet`** with argument `GL_MAX_ELEMENTS_VERTICES` and `GL_MAX_ELEMENTS_INDICES`. If end - start + 1 is greater than the value of `GL_MAX_ELEMENTS_VERTICES`, or if **count** is greater than the value of `GL_MAX_ELEMENTS_INDICES`, then the call may operate at reduced performance. There is no requirement that all vertices in the range start end be referenced. However, the implementation may partially process unused vertices, reducing performance from what could be achieved with an optimal index set.
    * 
    * When **glDrawRangeElements** is called, it uses **count** sequential elements from an enabled array, starting at **start** to construct a sequence of geometric primitives. **mode** specifies what kind of primitives are constructed, and how the array elements construct these primitives. If more than one array is enabled, each is used.
    * 
    * Vertex attributes that are modified by **glDrawRangeElements** have an unspecified value after **glDrawRangeElements** returns. Attributes that aren't modified maintain their previous values.
    * 
    * 
    * ### Notes:
    * `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * It is an error for indices to lie outside the range start end, but implementations may not check for this situation. Such indices cause implementation-dependent behavior.
    * 
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **count** is negative.
    * 
    * `GL_INVALID_VALUE` is generated if end &lt; start.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param start Specifies the minimum array index contained in **indices**.
    * @param end Specifies the maximum array index contained in **indices**.
    * @param count Specifies the number of elements to be rendered.
    * @param type Specifies the type of the values in **indices**. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.
    * @param indices Specifies a pointer to the location where the indices are stored.

    * @see **`glDrawArrays`**, **`glDrawElements`**, **`glDrawElementsBaseVertex`**

    **/
    static function drawRangeElements(mode:Int, start:Int, end:Int, count:Int, type:Int, in_dices:DataPointer):Void return ExtensionsNative.drawRangeElements(mode, start, end, count, type, in_dices);
    /**
    * - #### Purpose:
    * render primitives from array data with a per-element offset
    * ### Description:
    * **glDrawRangeElementsBaseVertex** is a restricted form of **`glDrawElementsBaseVertex`**. **mode**, **count** and **basevertex** match the corresponding arguments to **`glDrawElementsBaseVertex`**, with the additional constraint that all values in the array **indices** must lie between **start** and **end**, inclusive, prior to adding **basevertex**. Index values lying outside the range [**start**, **end**] are treated in the same way as **`glDrawElementsBaseVertex`**. The ith element transferred by the corresponding draw call will be taken from element **indices**[i] + **basevertex** of each enabled array. If the resulting value is larger than the maximum value representable by **type**, it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **count** is negative.
    * 
    * `GL_INVALID_VALUE` is generated if **end** &lt; **start**.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param start Specifies the minimum array index contained in **indices**.
    * @param end Specifies the maximum array index contained in **indices**.
    * @param count Specifies the number of elements to be rendered.
    * @param type Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.
    * @param indices Specifies a pointer to the location where the indices are stored.
    * @param basevertex Specifies a constant that should be added to each element of **indices** when chosing elements from the enabled vertex arrays.

    * @see **`glDrawElements`**, **`glDrawElementsBaseVertex`**, **`glDrawRangeElements`**, **`glDrawElementsInstanced`**, **`glDrawElementsInstancedBaseVertex`**

    **/
    static function drawRangeElementsBaseVertex(mode:Int, start:Int, end:Int, count:Int, type:Int, in_dices:DataPointer, basevertex:Int):Void return ExtensionsNative.drawRangeElementsBaseVertex(mode, start, end, count, type, in_dices, basevertex);
    static function drawRangeElementsBaseVertexEXT(mode:Int, start:Int, end:Int, count:Int, type:Int, in_dices:DataPointer, basevertex:Int):Void return ExtensionsNative.drawRangeElementsBaseVertexEXT(mode, start, end, count, type, in_dices, basevertex);
    static function drawRangeElementsBaseVertexOES(mode:Int, start:Int, end:Int, count:Int, type:Int, in_dices:DataPointer, basevertex:Int):Void return ExtensionsNative.drawRangeElementsBaseVertexOES(mode, start, end, count, type, in_dices, basevertex);
    static function drawRangeElementsEXT(mode:Int, start:Int, end:Int, count:Int, type:Int, in_dices:DataPointer):Void return ExtensionsNative.drawRangeElementsEXT(mode, start, end, count, type, in_dices);
    static function drawTexfOES(x:Float, y:Float, z:Float, width:Float, height:Float):Void return ExtensionsNative.drawTexfOES(x, y, z, width, height);
    static function drawTexfvOES(coords:DataPointer):Void return ExtensionsNative.drawTexfvOES(coords);
    static function drawTexiOES(x:Int, y:Int, z:Int, width:Int, height:Int):Void return ExtensionsNative.drawTexiOES(x, y, z, width, height);
    static function drawTexivOES(coords:DataPointer):Void return ExtensionsNative.drawTexivOES(coords);
    static function drawTexsOES(x:Int, y:Int, z:Int, width:Int, height:Int):Void return ExtensionsNative.drawTexsOES(x, y, z, width, height);
    static function drawTexsvOES(coords:DataPointer):Void return ExtensionsNative.drawTexsvOES(coords);
    static function drawTextureNV(texture:Int, sampler:Int, x0:Float, y0:Float, x1:Float, y1:Float, z:Float, s0:Float, t0:Float, s1:Float, t1:Float):Void return ExtensionsNative.drawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    static function drawTexxOES(x:Int, y:Int, z:Int, width:Int, height:Int):Void return ExtensionsNative.drawTexxOES(x, y, z, width, height);
    static function drawTexxvOES(coords:DataPointer):Void return ExtensionsNative.drawTexxvOES(coords);
    /**
    * - #### Purpose:
    * render primitives using a count derived from a transform feedback object
    * ### Description:
    * **glDrawTransformFeedback** draws primitives of a type specified by **mode** using a count retrieved from the transform feedback specified by **id**. Calling **glDrawTransformFeedback** is equivalent to calling **`glDrawArrays`** with **mode** as specified, **first** set to zero, and **count** set to the number of vertices captured on vertex stream zero the last time transform feedback was active on the transform feedback object named by **id**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **id** is not the name of a transform feedback object.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **mode** is `GL_PATCHES` and no tessellation control shader is active.
    * 
    * `GL_INVALID_OPERATION` is generated if **glEndTransformFeedback** has never been called while the transform feedback object named by **id** was bound.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.
    * @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.

    * @see **`glDrawArrays`**, **`glDrawArraysInstanced`**, **`glDrawElements`**, **`glDrawRangeElements`**, **`glDrawTransformFeedbackStream`**

    **/
    static function drawTransformFeedback(mode:Int, id:Int):Void return ExtensionsNative.drawTransformFeedback(mode, id);
    static function drawTransformFeedbackEXT(mode:Int, id:Int):Void return ExtensionsNative.drawTransformFeedbackEXT(mode, id);
    /**
    * - #### Purpose:
    * render multiple instances of primitives using a count derived from a transform feedback object
    * ### Description:
    * **glDrawTransformFeedbackInstanced** draws multiple copies of a range of primitives of a type specified by **mode** using a count retrieved from the transform feedback stream specified by **stream** of the transform feedback object specified by **id**. Calling **glDrawTransformFeedbackInstanced** is equivalent to calling **`glDrawArraysInstanced`** with **mode** and **instancecount** as specified, **first** set to zero, and **count** set to the number of vertices captured on vertex stream zero the last time transform feedback was active on the transform feedback object named by **id**.
    * 
    * Calling **glDrawTransformFeedbackInstanced** is equivalent to calling **`glDrawTransformFeedbackStreamInstanced`** with **stream** set to zero.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **id** is not the name of a transform feedback object.
    * 
    * `GL_INVALID_VALUE` is generated if **stream** is greater than or equal to the value of `GL_MAX_VERTEX_STREAMS`.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **mode** is `GL_PATCHES` and no tessellation control shader is active.
    * 
    * `GL_INVALID_OPERATION` is generated if **glEndTransformFeedback** has never been called while the transform feedback object named by **id** was bound.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.
    * @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.
    * @param instancecount Specifies the number of instances of the geometry to render.

    * @see **`glDrawArrays`**, **`glDrawArraysInstanced`**, **`glDrawElements`**, **`glDrawRangeElements`**, **`glDrawTransformFeedback`**, **`glDrawTransformFeedbackStreamInstanced`**.

    **/
    static function drawTransformFeedbackInstanced(mode:Int, id:Int, in_stancecount:Int):Void return ExtensionsNative.drawTransformFeedbackInstanced(mode, id, in_stancecount);
    static function drawTransformFeedbackInstancedEXT(mode:Int, id:Int, in_stancecount:Int):Void return ExtensionsNative.drawTransformFeedbackInstancedEXT(mode, id, in_stancecount);
    static function drawTransformFeedbackNV(mode:Int, id:Int):Void return ExtensionsNative.drawTransformFeedbackNV(mode, id);
    /**
    * - #### Purpose:
    * render primitives using a count derived from a specifed stream of a transform feedback object
    * ### Description:
    * **glDrawTransformFeedbackStream** draws primitives of a type specified by **mode** using a count retrieved from the transform feedback stream specified by **stream** of the transform feedback object specified by **id**. Calling **glDrawTransformFeedbackStream** is equivalent to calling **`glDrawArrays`** with **mode** as specified, **first** set to zero, and **count** set to the number of vertices captured on vertex stream **stream** the last time transform feedback was active on the transform feedback object named by **id**.
    * 
    * Calling **`glDrawTransformFeedback`** is equivalent to calling **glDrawTransformFeedbackStream** with **stream** set to zero.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **id** is not the name of a transform feedback object.
    * 
    * `GL_INVALID_VALUE` is generated if **stream** is greater than or equal to the value of `GL_MAX_VERTEX_STREAMS`.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **mode** is `GL_PATCHES` and no tessellation control shader is active.
    * 
    * `GL_INVALID_OPERATION` is generated if **glEndTransformFeedback** has never been called while the transform feedback object named by **id** was bound.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.
    * @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.
    * @param stream Specifies the index of the transform feedback stream from which to retrieve a primitive count.

    * @see **`glDrawArrays`**, **`glDrawArraysInstanced`**, **`glDrawElements`**, **`glDrawRangeElements`**, **`glDrawTransformFeedback`**

    **/
    static function drawTransformFeedbackStream(mode:Int, id:Int, stream:Int):Void return ExtensionsNative.drawTransformFeedbackStream(mode, id, stream);
    /**
    * - #### Purpose:
    * render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object
    * ### Description:
    * **glDrawTransformFeedbackStreamInstanced** draws multiple copies of a range of primitives of a type specified by **mode** using a count retrieved from the transform feedback stream specified by **stream** of the transform feedback object specified by **id**. Calling **glDrawTransformFeedbackStreamInstanced** is equivalent to calling **`glDrawArraysInstanced`** with **mode** and **instancecount** as specified, **first** set to zero, and **count** set to the number of vertices captured on vertex stream **stream** the last time transform feedback was active on the transform feedback object named by **id**.
    * 
    * Calling **`glDrawTransformFeedbackInstanced`** is equivalent to calling **glDrawTransformFeedbackStreamInstanced** with **stream** set to zero.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **id** is not the name of a transform feedback object.
    * 
    * `GL_INVALID_VALUE` is generated if **stream** is greater than or equal to the value of `GL_MAX_VERTEX_STREAMS`.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **mode** is `GL_PATCHES` and no tessellation control shader is active.
    * 
    * `GL_INVALID_OPERATION` is generated if **glEndTransformFeedback** has never been called while the transform feedback object named by **id** was bound.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.
    * @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.
    * @param stream Specifies the index of the transform feedback stream from which to retrieve a primitive count.
    * @param instancecount Specifies the number of instances of the geometry to render.

    * @see **`glDrawArrays`**, **`glDrawArraysInstanced`**, **`glDrawElements`**, **`glDrawRangeElements`**, **`glDrawTransformFeedback`**, **`glDrawTransformFeedbackStream`**.

    **/
    static function drawTransformFeedbackStreamInstanced(mode:Int, id:Int, stream:Int, in_stancecount:Int):Void return ExtensionsNative.drawTransformFeedbackStreamInstanced(mode, id, stream, in_stancecount);
    static function eGLImageTargetRenderbufferStorageOES(target:Int, image:DataPointer):Void return ExtensionsNative.eGLImageTargetRenderbufferStorageOES(target, image);
    static function eGLImageTargetTexStorageEXT(target:Int, image:DataPointer, attrib_list:DataPointer):Void return ExtensionsNative.eGLImageTargetTexStorageEXT(target, image, attrib_list);
    static function eGLImageTargetTexture2DOES(target:Int, image:DataPointer):Void return ExtensionsNative.eGLImageTargetTexture2DOES(target, image);
    static function eGLImageTargetTextureStorageEXT(texture:Int, image:DataPointer, attrib_list:DataPointer):Void return ExtensionsNative.eGLImageTargetTextureStorageEXT(texture, image, attrib_list);
    static function edgeFlag(flag:Bool):Void return ExtensionsNative.edgeFlag(flag);
    static function edgeFlagFormatNV(stride:Int):Void return ExtensionsNative.edgeFlagFormatNV(stride);
    static function edgeFlagPointer(stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.edgeFlagPointer(stride, poin_ter);
    static function edgeFlagPointerEXT(stride:Int, count:Int, poin_ter:DataPointer):Void return ExtensionsNative.edgeFlagPointerEXT(stride, count, poin_ter);
    static function edgeFlagPointerListIBM(stride:Int, poin_ter:DataPointer, ptrstride:Int):Void return ExtensionsNative.edgeFlagPointerListIBM(stride, poin_ter, ptrstride);
    static function edgeFlagv(flag:DataPointer):Void return ExtensionsNative.edgeFlagv(flag);
    static function elementPointerAPPLE(type:Int, poin_ter:DataPointer):Void return ExtensionsNative.elementPointerAPPLE(type, poin_ter);
    static function elementPointerATI(type:Int, poin_ter:DataPointer):Void return ExtensionsNative.elementPointerATI(type, poin_ter);
    /**
    * - #### Purpose:
    * enable or disable server-side GL capabilities
    * ### Description:
    * **glEnable** and **glDisable** enable and disable various capabilities. Use **`glIsEnabled`** or **`glGet`** to determine the current setting of any capability. The initial value for each capability with the exception of `GL_DITHER` and `GL_MULTISAMPLE` is `GL_FALSE`. The initial value for `GL_DITHER` and `GL_MULTISAMPLE` is `GL_TRUE`.
    * 
    * Both **glEnable** and **glDisable** take a single argument, **cap**, which can assume one of the following values:
    * 
    * Some of the GL's capabilities are indexed. **glEnablei** and **glDisablei** enable and disable indexed capabilities.
    * 
    * *``GL_BLEND``* If enabled, blend the computed fragment color values with the values in the color buffers. See **`glBlendFunc`**.
    * 
    * *``GL_CLIP_DISTANCE`i`* If enabled, clip geometry against user-defined half space i.
    * 
    * *``GL_COLOR_LOGIC_OP``* If enabled, apply the currently selected logical operation to the computed fragment color and color buffer values. See **`glLogicOp`**.
    * 
    * *``GL_CULL_FACE``* If enabled, cull polygons based on their winding in window coordinates. See **`glCullFace`**.
    * 
    * *``GL_DEBUG_OUTPUT``* If enabled, debug messages are produced by a debug context. When disabled, the debug message log is silenced. Note that in a non-debug context, very few, if any messages might be produced, even when `GL_DEBUG_OUTPUT` is enabled.
    * 
    * *``GL_DEBUG_OUTPUT_SYNCHRONOUS``* If enabled, debug messages are produced synchronously by a debug context. If disabled, debug messages may be produced asynchronously. In particular, they may be delayed relative to the execution of GL commands, and the debug callback function may be called from a thread other than that in which the commands are executed. See **`glDebugMessageCallback`**.
    * 
    * *``GL_DEPTH_CLAMP``* If enabled, the -wc&amp;le;zc&amp;le;wc plane equation is ignored by view volume clipping (effectively, there is no near or far plane clipping). See **`glDepthRange`**.
    * 
    * *``GL_DEPTH_TEST``* If enabled, do depth comparisons and update the depth buffer. Note that even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. See **`glDepthFunc`** and **`glDepthRange`**.
    * 
    * *``GL_DITHER``* If enabled, dither color components or indices before they are written to the color buffer.
    * 
    * *``GL_FRAMEBUFFER_SRGB``* If enabled and the value of `GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING` for the framebuffer attachment corresponding to the destination buffer is `GL_SRGB`, the R, G, and B destination color values (after conversion from fixed-point to floating-point) are considered to be encoded for the sRGB color space and hence are linearized prior to their use in blending.
    * 
    * *``GL_LINE_SMOOTH``* If enabled, draw lines with correct filtering. Otherwise, draw aliased lines. See **`glLineWidth`**.
    * 
    * *``GL_MULTISAMPLE``* If enabled, use multiple fragment samples in computing the final color of a pixel. See **`glSampleCoverage`**.
    * 
    * *``GL_POLYGON_OFFSET_FILL``* If enabled, and if the polygon is rendered in `GL_FILL` mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See **`glPolygonOffset`**.
    * 
    * *``GL_POLYGON_OFFSET_LINE``* If enabled, and if the polygon is rendered in `GL_LINE` mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See **`glPolygonOffset`**.
    * 
    * *``GL_POLYGON_OFFSET_POINT``* If enabled, an offset is added to depth values of a polygon's fragments before the depth comparison is performed, if the polygon is rendered in `GL_POINT` mode. See **`glPolygonOffset`**.
    * 
    * *``GL_POLYGON_SMOOTH``* If enabled, draw polygons with proper filtering. Otherwise, draw aliased polygons. For correct antialiased polygons, an alpha buffer is needed and the polygons must be sorted front to back.
    * 
    * *``GL_PRIMITIVE_RESTART``* Enables primitive restarting. If enabled, any one of the draw commands which transfers a set of generic attribute array elements to the GL will restart the primitive when the index of the vertex is equal to the primitive restart index. See **`glPrimitiveRestartIndex`**.
    * 
    * *``GL_PRIMITIVE_RESTART_FIXED_INDEX``* Enables primitive restarting with a fixed index. If enabled, any one of the draw commands which transfers a set of generic attribute array elements to the GL will restart the primitive when the index of the vertex is equal to the fixed primitive index for the specified index type. The fixed index is equal to 2n&amp;minus;1 where n is equal to 8 for `GL_UNSIGNED_BYTE`, 16 for `GL_UNSIGNED_SHORT` and 32 for `GL_UNSIGNED_INT`.
    * 
    * *``GL_RASTERIZER_DISCARD``* If enabled, primitives are discarded after the optional transform feedback stage, but before rasterization. Furthermore, when enabled, **`glClear`**, **`glClearBufferData`**, **`glClearBufferSubData`**, **`glClearTexImage`**, and **`glClearTexSubImage`** are ignored.
    * 
    * *``GL_SAMPLE_ALPHA_TO_COVERAGE``* If enabled, compute a temporary coverage value where each bit is determined by the alpha value at the corresponding sample location. The temporary coverage value is then ANDed with the fragment coverage value.
    * 
    * *``GL_SAMPLE_ALPHA_TO_ONE``* If enabled, each sample alpha value is replaced by the maximum representable alpha value.
    * 
    * *``GL_SAMPLE_COVERAGE``* If enabled, the fragment's coverage is ANDed with the temporary coverage value. If `GL_SAMPLE_COVERAGE_INVERT` is set to `GL_TRUE`, invert the coverage value. See **`glSampleCoverage`**.
    * 
    * *``GL_SAMPLE_SHADING``* If enabled, the active fragment shader is run once for each covered sample, or at fraction of this rate as determined by the current value of `GL_MIN_SAMPLE_SHADING_VALUE`. See **`glMinSampleShading`**.
    * 
    * *``GL_SAMPLE_MASK``* If enabled, the sample coverage mask generated for a fragment during rasterization will be ANDed with the value of `GL_SAMPLE_MASK_VALUE` before shading occurs. See **`glSampleMaski`**.
    * 
    * *``GL_SCISSOR_TEST``* If enabled, discard fragments that are outside the scissor rectangle. See **`glScissor`**.
    * 
    * *``GL_STENCIL_TEST``* If enabled, do stencil testing and update the stencil buffer. See **`glStencilFunc`** and **`glStencilOp`**.
    * 
    * *``GL_TEXTURE_CUBE_MAP_SEAMLESS``* If enabled, cubemap textures are sampled such that when linearly sampling from the border between two adjacent faces, texels from both faces are used to generate the final sample value. When disabled, texels from only a single face are used to construct the final sample value.
    * 
    * *``GL_PROGRAM_POINT_SIZE``* If enabled and a vertex or geometry shader is active, then the derived point size is taken from the (potentially clipped) shader builtin `gl_PointSize` and clamped to the implementation-dependent point size range.
    * 
    * 
    * ### Notes:
    * `GL_PRIMITIVE_RESTART` is available only if the GL version is 3.1 or greater.
    * 
    * `GL_TEXTURE_CUBE_MAP_SEAMLESS` is available only if the GL version is 3.2 or greater.
    * 
    * `GL_PRIMITIVE_RESTART_FIXED_INDEX` is available only if the GL version is 4.3 or greater.
    * 
    * `GL_DEBUG_OUTPUT` and `GL_DEBUG_OUTPUT_SYNCHRONOUS` are available only if the GL version is 4.3 or greater.
    * 
    * Any token accepted by **glEnable** or **glDisable** is also accepted by **glEnablei** and **glDisablei**, but if the capability is not indexed, the maximum value that **index** may take is zero.
    * 
    * In general, passing an indexed capability to **glEnable** or **glDisable** will enable or disable that capability for all indices, resepectively.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **cap** is not one of the values listed previously.
    * 
    * `GL_INVALID_VALUE` is generated by **glEnablei** and **glDisablei** if **index** is greater than or equal to the number of indexed capabilities for **cap**.
    * 
    * @param cap Specifies a symbolic constant indicating a GL capability.
    * @param index Specifies the index of the switch to disable (for **glEnablei** and **glDisablei** only).

    * @see **`glActiveTexture`**, **`glBlendFunc`**, **`glCullFace`**, **`glDepthFunc`**, **`glDepthRange`**, **`glGet`**, **`glIsEnabled`**, **`glLineWidth`**, **`glLogicOp`**, **`glPointSize`**, **`glPolygonMode`**, **`glPolygonOffset`**, **`glSampleCoverage`**, **`glScissor`**, **`glStencilFunc`**, **`glStencilOp`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**

    **/
    static function enable(cap:Int):Void return ExtensionsNative.enable(cap);
    static function enableClientState(array:Int):Void return ExtensionsNative.enableClientState(array);
    static function enableClientStateIndexedEXT(array:Int, in_dex:Int):Void return ExtensionsNative.enableClientStateIndexedEXT(array, in_dex);
    static function enableClientStateiEXT(array:Int, in_dex:Int):Void return ExtensionsNative.enableClientStateiEXT(array, in_dex);
    static function enableDriverControlQCOM(driverControl:Int):Void return ExtensionsNative.enableDriverControlQCOM(driverControl);
    static function enableIndexedEXT(target:Int, in_dex:Int):Void return ExtensionsNative.enableIndexedEXT(target, in_dex);
    static function enableVariantClientStateEXT(id:Int):Void return ExtensionsNative.enableVariantClientStateEXT(id);
    static function enableVertexArrayAttrib(vaobj:Int, in_dex:Int):Void return ExtensionsNative.enableVertexArrayAttrib(vaobj, in_dex);
    static function enableVertexArrayAttribEXT(vaobj:Int, in_dex:Int):Void return ExtensionsNative.enableVertexArrayAttribEXT(vaobj, in_dex);
    static function enableVertexArrayEXT(vaobj:Int, array:Int):Void return ExtensionsNative.enableVertexArrayEXT(vaobj, array);
    static function enableVertexAttribAPPLE(in_dex:Int, pname:Int):Void return ExtensionsNative.enableVertexAttribAPPLE(in_dex, pname);
    /**
    * - #### Purpose:
    * Enable or disable a generic vertex attribute
        array
    * ### Description:
    * **glEnableVertexAttribArray** and **glEnableVertexArrayAttrib** enable the generic vertex attribute array specified by **index**. **glEnableVertexAttribArray** uses currently bound vertex array object for the operation, whereas **glEnableVertexArrayAttrib** updates state of the vertex array object with ID **vaobj**.
    * 
    * **glDisableVertexAttribArray** and **glDisableVertexArrayAttrib** disable the generic vertex attribute array specified by **index**. **glDisableVertexAttribArray** uses currently bound vertex array object for the operation, whereas **glDisableVertexArrayAttrib** updates state of the vertex array object with ID **vaobj**.
    * 
    * By default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array commands such as **`glDrawArrays`**, **`glDrawElements`**, **`glDrawRangeElements`**, **`glMultiDrawElements`**, or **`glMultiDrawArrays`**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated by **glEnableVertexAttribArray** and **glDisableVertexAttribArray** if no vertex array object is bound.
    * 
    * `GL_INVALID_OPERATION` is generated by **glEnableVertexArrayAttrib** and **glDisableVertexArrayAttrib** if **vaobj** is not the name of an existing vertex array object.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.
    * 
    * @param vaobj Specifies the name of the vertex array object for **glDisableVertexArrayAttrib** and **glEnableVertexArrayAttrib** functions.
    * @param index Specifies the index of the generic vertex attribute to be enabled or disabled.

    * @see **`glBindAttribLocation`**, **`glDrawArrays`**, **`glDrawElements`**, **`glDrawRangeElements`**, **`glMultiDrawElements`**, **`glVertexAttrib`**, **`glVertexAttribPointer`**

    **/
    static function enableVertexAttribArray(in_dex:Int):Void return ExtensionsNative.enableVertexAttribArray(in_dex);
    static function enableVertexAttribArrayARB(in_dex:Int):Void return ExtensionsNative.enableVertexAttribArrayARB(in_dex);
    static function enablei(target:Int, in_dex:Int):Void return ExtensionsNative.enablei(target, in_dex);
    static function enableiEXT(target:Int, in_dex:Int):Void return ExtensionsNative.enableiEXT(target, in_dex);
    static function enableiNV(target:Int, in_dex:Int):Void return ExtensionsNative.enableiNV(target, in_dex);
    static function enableiOES(target:Int, in_dex:Int):Void return ExtensionsNative.enableiOES(target, in_dex);
    static function end():Void return ExtensionsNative.end();
    static function endConditionalRender():Void return ExtensionsNative.endConditionalRender();
    static function endConditionalRenderNV():Void return ExtensionsNative.endConditionalRenderNV();
    static function endConditionalRenderNVX():Void return ExtensionsNative.endConditionalRenderNVX();
    static function endFragmentShaderATI():Void return ExtensionsNative.endFragmentShaderATI();
    static function endList():Void return ExtensionsNative.endList();
    static function endOcclusionQueryNV():Void return ExtensionsNative.endOcclusionQueryNV();
    static function endPerfMonitorAMD(monitor:Int):Void return ExtensionsNative.endPerfMonitorAMD(monitor);
    static function endPerfQueryINTEL(queryHandle:Int):Void return ExtensionsNative.endPerfQueryINTEL(queryHandle);
    static function endQuery(target:Int):Void return ExtensionsNative.endQuery(target);
    static function endQueryARB(target:Int):Void return ExtensionsNative.endQueryARB(target);
    static function endQueryEXT(target:Int):Void return ExtensionsNative.endQueryEXT(target);
    static function endQueryIndexed(target:Int, in_dex:Int):Void return ExtensionsNative.endQueryIndexed(target, in_dex);
    static function endTilingQCOM(preserveMask:Int):Void return ExtensionsNative.endTilingQCOM(preserveMask);
    static function endTransformFeedback():Void return ExtensionsNative.endTransformFeedback();
    static function endTransformFeedbackEXT():Void return ExtensionsNative.endTransformFeedbackEXT();
    static function endTransformFeedbackNV():Void return ExtensionsNative.endTransformFeedbackNV();
    static function endVertexShaderEXT():Void return ExtensionsNative.endVertexShaderEXT();
    static function endVideoCaptureNV(video_capture_slot:Int):Void return ExtensionsNative.endVideoCaptureNV(video_capture_slot);
    static function evalCoord1d(u:DataPointer):Void return ExtensionsNative.evalCoord1d(u);
    static function evalCoord1dv(u:DataPointer):Void return ExtensionsNative.evalCoord1dv(u);
    static function evalCoord1f(u:Float):Void return ExtensionsNative.evalCoord1f(u);
    static function evalCoord1fv(u:DataPointer):Void return ExtensionsNative.evalCoord1fv(u);
    static function evalCoord1xOES(u:Int):Void return ExtensionsNative.evalCoord1xOES(u);
    static function evalCoord1xvOES(coords:DataPointer):Void return ExtensionsNative.evalCoord1xvOES(coords);
    static function evalCoord2d(u:DataPointer, v:DataPointer):Void return ExtensionsNative.evalCoord2d(u, v);
    static function evalCoord2dv(u:DataPointer):Void return ExtensionsNative.evalCoord2dv(u);
    static function evalCoord2f(u:Float, v:Float):Void return ExtensionsNative.evalCoord2f(u, v);
    static function evalCoord2fv(u:DataPointer):Void return ExtensionsNative.evalCoord2fv(u);
    static function evalCoord2xOES(u:Int, v:Int):Void return ExtensionsNative.evalCoord2xOES(u, v);
    static function evalCoord2xvOES(coords:DataPointer):Void return ExtensionsNative.evalCoord2xvOES(coords);
    static function evalMapsNV(target:Int, mode:Int):Void return ExtensionsNative.evalMapsNV(target, mode);
    static function evalMesh1(mode:Int, i1:Int, i2:Int):Void return ExtensionsNative.evalMesh1(mode, i1, i2);
    static function evalMesh2(mode:Int, i1:Int, i2:Int, j1:Int, j2:Int):Void return ExtensionsNative.evalMesh2(mode, i1, i2, j1, j2);
    static function evalPoint1(i:Int):Void return ExtensionsNative.evalPoint1(i);
    static function evalPoint2(i:Int, j:Int):Void return ExtensionsNative.evalPoint2(i, j);
    static function evaluateDepthValuesARB():Void return ExtensionsNative.evaluateDepthValuesARB();
    static function executeProgramNV(target:Int, id:Int, params:DataPointer):Void return ExtensionsNative.executeProgramNV(target, id, params);
    static function extGetBufferPointervQCOM(target:Int, params:DataPointer):Void return ExtensionsNative.extGetBufferPointervQCOM(target, params);
    static function extGetBuffersQCOM(buffers:DataPointer, maxBuffers:Int, numBuffers:DataPointer):Void return ExtensionsNative.extGetBuffersQCOM(buffers, maxBuffers, numBuffers);
    static function extGetFramebuffersQCOM(framebuffers:DataPointer, maxFramebuffers:Int, numFramebuffers:DataPointer):Void return ExtensionsNative.extGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers);
    static function extGetProgramBinarySourceQCOM(program:Int, shadertype:Int, source:Pointer<Char>, length:DataPointer):Void return ExtensionsNative.extGetProgramBinarySourceQCOM(program, shadertype, source, length);
    static function extGetProgramsQCOM(programs:DataPointer, maxPrograms:Int, numPrograms:DataPointer):Void return ExtensionsNative.extGetProgramsQCOM(programs, maxPrograms, numPrograms);
    static function extGetRenderbuffersQCOM(renderbuffers:DataPointer, maxRenderbuffers:Int, numRenderbuffers:DataPointer):Void return ExtensionsNative.extGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers);
    static function extGetShadersQCOM(shaders:DataPointer, maxShaders:Int, numShaders:DataPointer):Void return ExtensionsNative.extGetShadersQCOM(shaders, maxShaders, numShaders);
    static function extGetTexLevelParameterivQCOM(texture:Int, face:Int, level:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.extGetTexLevelParameterivQCOM(texture, face, level, pname, params);
    static function extGetTexSubImageQCOM(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, type:Int, texels:DataPointer):Void return ExtensionsNative.extGetTexSubImageQCOM(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
    static function extGetTexturesQCOM(textures:DataPointer, maxTextures:Int, numTextures:DataPointer):Void return ExtensionsNative.extGetTexturesQCOM(textures, maxTextures, numTextures);
    static function extIsProgramBinaryQCOM(program:Int):Bool return ExtensionsNative.extIsProgramBinaryQCOM(program);
    static function extTexObjectStateOverrideiQCOM(target:Int, pname:Int, param:Int):Void return ExtensionsNative.extTexObjectStateOverrideiQCOM(target, pname, param);
    static function extractComponentEXT(res:Int, src:Int, num:Int):Void return ExtensionsNative.extractComponentEXT(res, src, num);
    static function feedbackBuffer(size:Int, type:Int, buffer:DataPointer):Void return ExtensionsNative.feedbackBuffer(size, type, buffer);
    static function feedbackBufferxOES(n:Int, type:Int, buffer:DataPointer):Void return ExtensionsNative.feedbackBufferxOES(n, type, buffer);
    /**
    * - #### Purpose:
    * create a new sync object and insert it into the GL command stream
    * ### Description:
    * **glFenceSync** creates a new fence sync object, inserts a fence command into the GL command stream and associates it with that sync object, and returns a non-zero name corresponding to the sync object.
    * 
    * When the specified **condition** of the sync object is satisfied by the fence command, the sync object is signaled by the GL, causing any **`glWaitSync`**, **`glClientWaitSync`** commands blocking in **sync** to unblock. No other state is affected by **glFenceSync** or by the execution of the associated fence command.
    * 
    * **condition** must be `GL_SYNC_GPU_COMMANDS_COMPLETE`. This condition is satisfied by completion of the fence command corresponding to the sync object and all preceding commands in the same command stream. The sync object will not be signaled until all effects from these commands on GL client and server state and the framebuffer are fully realized. Note that completion of the fence command occurs once the state of the corresponding sync object has been changed, but commands waiting on that sync object may not be unblocked until after the fence command completes.
    * 
    * 
    * ### Notes:
    * **glFenceSync** is only supported if the GL version is 3.2 or greater, or if the ARB_sync extension is supported.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **condition** is not `GL_SYNC_GPU_COMMANDS_COMPLETE`.
    * 
    * `GL_INVALID_VALUE` is generated if **flags** is not zero.
    * 
    * Additionally, if **glFenceSync** fails, it will return zero.
    * 
    * @param condition Specifies the condition that must be met to set the sync object's state to signaled. **condition** must be `GL_SYNC_GPU_COMMANDS_COMPLETE`.
    * @param flags Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and **flags** must be zero. **flags** is a placeholder for anticipated future extensions of fence sync object capabilities.

    * @see **`glDeleteSync`**, **`glGetSync`**, **`glWaitSync`**, **`glClientWaitSync`**

    **/
    static function fenceSync(condition:Int, flags:Int):DataPointer return ExtensionsNative.fenceSync(condition, flags);
    static function fenceSyncAPPLE(condition:Int, flags:Int):DataPointer return ExtensionsNative.fenceSyncAPPLE(condition, flags);
    static function finalCombinerInputNV(variable:Int, in_put:Int, mappin_g:Int, componentUsage:Int):Void return ExtensionsNative.finalCombinerInputNV(variable, in_put, mappin_g, componentUsage);
    /**
    * - #### Purpose:
    * block until all GL execution is complete
    * ### Description:
    * **glFinish** does not return until the effects of all previously called GL commands are complete. Such effects include all changes to GL state, all changes to connection state, and all changes to the frame buffer contents.
    * 
    * 
    * ### Notes:
    * **glFinish** requires a round trip to the server.
    * 
    * 
    * ### Errors:
    * * @see **`glFlush`**

    **/
    static function finish():Void return ExtensionsNative.finish();
    static function finishAsyncSGIX(markerp:DataPointer):Int return ExtensionsNative.finishAsyncSGIX(markerp);
    static function finishFenceAPPLE(fence:Int):Void return ExtensionsNative.finishFenceAPPLE(fence);
    static function finishFenceNV(fence:Int):Void return ExtensionsNative.finishFenceNV(fence);
    static function finishObjectAPPLE(object:Int, name:Int):Void return ExtensionsNative.finishObjectAPPLE(object, name);
    static function finishTextureSUNX():Void return ExtensionsNative.finishTextureSUNX();
    /**
    * - #### Purpose:
    * force execution of GL commands in finite time
    * ### Description:
    * Different GL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself. **glFlush** empties all of these buffers, causing all issued commands to be executed as quickly as they are accepted by the actual rendering engine. Though this execution may not be completed in any particular time period, it does complete in finite time.
    * 
    * Because any GL program might be executed over a network, or on an accelerator that buffers commands, all programs should call **glFlush** whenever they count on having all of their previously issued commands completed. For example, call **glFlush** before waiting for user input that depends on the generated image.
    * 
    * 
    * ### Notes:
    * **glFlush** can return at any time. It does not wait until the execution of all previously issued GL commands is complete.
    * 
    * 
    * ### Errors:
    * * @see **`glFinish`**

    **/
    static function flush():Void return ExtensionsNative.flush();
    /**
    * - #### Purpose:
    * indicate modifications to a range of a mapped buffer
    * ### Description:
    * **glFlushMappedBufferRange** indicates that modifications have been made to a range of a mapped buffer object. The buffer object must previously have been mapped with the `GL_MAP_FLUSH_EXPLICIT_BIT` flag.
    * 
    * **offset** and **length** indicate the modified subrange of the mapping, in basic machine units. The specified subrange to flush is relative to the start of the currently mapped range of the buffer. These commands may be called multiple times to indicate distinct subranges of the mapping which require flushing.
    * 
    * If a buffer range is mapped with both `GL_MAP_PERSISTENT_BIT` and `GL_MAP_FLUSH_EXPLICIT_BIT` set, then these commands may be called to ensure that data written by the client into the flushed region becomes visible to the server. Data written to a coherent store will always become visible to the server after an unspecified period of time.
    * 
    * 
    * ### Notes:
    * The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.
    * 
    * The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glFlushMappedBufferRange** if **target** is not one of the buffer binding targets listed above.
    * 
    * `GL_INVALID_OPERATION` is generated by **glFlushMappedBufferRange** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glFlushMappedNamedBufferRange** if **buffer** is not the name of an existing buffer object.
    * 
    * `GL_INVALID_VALUE` is generated if **offset** or **length** is negative, or if **offset** + **length** exceeds the size of the mapping.
    * 
    * `GL_INVALID_OPERATION` is generated if the buffer object is not mapped, or is mapped without the `GL_MAP_FLUSH_EXPLICIT_BIT` flag.
    * 
    * @param target Specifies the target to which the buffer object is bound for **glFlushMappedBufferRange**, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of the buffer object for **glFlushMappedNamedBufferRange**.
    * @param offset Specifies the start of the buffer subrange, in basic machine units.
    * @param length Specifies the length of the buffer subrange, in basic machine units.

    * @see **`glMapBufferRange`**, **`glMapBuffer`**, **`glUnmapBuffer`**

    **/
    static function flushMappedBufferRange(target:Int, offset:Int, length:Int):Void return ExtensionsNative.flushMappedBufferRange(target, offset, length);
    static function flushMappedBufferRangeAPPLE(target:Int, offset:Int, size:Int):Void return ExtensionsNative.flushMappedBufferRangeAPPLE(target, offset, size);
    static function flushMappedBufferRangeEXT(target:Int, offset:Int, length:Int):Void return ExtensionsNative.flushMappedBufferRangeEXT(target, offset, length);
    static function flushMappedNamedBufferRange(buffer:Int, offset:Int, length:Int):Void return ExtensionsNative.flushMappedNamedBufferRange(buffer, offset, length);
    static function flushMappedNamedBufferRangeEXT(buffer:Int, offset:Int, length:Int):Void return ExtensionsNative.flushMappedNamedBufferRangeEXT(buffer, offset, length);
    static function flushPixelDataRangeNV(target:Int):Void return ExtensionsNative.flushPixelDataRangeNV(target);
    static function flushRasterSGIX():Void return ExtensionsNative.flushRasterSGIX();
    static function flushStaticDataIBM(target:Int):Void return ExtensionsNative.flushStaticDataIBM(target);
    static function flushVertexArrayRangeAPPLE(length:Int, poin_ter:DataPointer):Void return ExtensionsNative.flushVertexArrayRangeAPPLE(length, poin_ter);
    static function flushVertexArrayRangeNV():Void return ExtensionsNative.flushVertexArrayRangeNV();
    static function fogCoordFormatNV(type:Int, stride:Int):Void return ExtensionsNative.fogCoordFormatNV(type, stride);
    static function fogCoordPointer(type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.fogCoordPointer(type, stride, poin_ter);
    static function fogCoordPointerEXT(type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.fogCoordPointerEXT(type, stride, poin_ter);
    static function fogCoordPointerListIBM(type:Int, stride:Int, poin_ter:DataPointer, ptrstride:Int):Void return ExtensionsNative.fogCoordPointerListIBM(type, stride, poin_ter, ptrstride);
    static function fogCoordd(coord:DataPointer):Void return ExtensionsNative.fogCoordd(coord);
    static function fogCoorddEXT(coord:DataPointer):Void return ExtensionsNative.fogCoorddEXT(coord);
    static function fogCoorddv(coord:DataPointer):Void return ExtensionsNative.fogCoorddv(coord);
    static function fogCoorddvEXT(coord:DataPointer):Void return ExtensionsNative.fogCoorddvEXT(coord);
    static function fogCoordf(coord:Float):Void return ExtensionsNative.fogCoordf(coord);
    static function fogCoordfEXT(coord:Float):Void return ExtensionsNative.fogCoordfEXT(coord);
    static function fogCoordfv(coord:DataPointer):Void return ExtensionsNative.fogCoordfv(coord);
    static function fogCoordfvEXT(coord:DataPointer):Void return ExtensionsNative.fogCoordfvEXT(coord);
    static function fogCoordhNV(fog:Int):Void return ExtensionsNative.fogCoordhNV(fog);
    static function fogCoordhvNV(fog:DataPointer):Void return ExtensionsNative.fogCoordhvNV(fog);
    static function fogFuncSGIS(n:Int, poin_ts:DataPointer):Void return ExtensionsNative.fogFuncSGIS(n, poin_ts);
    static function fogf(pname:Int, param:Float):Void return ExtensionsNative.fogf(pname, param);
    static function fogfv(pname:Int, params:DataPointer):Void return ExtensionsNative.fogfv(pname, params);
    static function fogi(pname:Int, param:Int):Void return ExtensionsNative.fogi(pname, param);
    static function fogiv(pname:Int, params:DataPointer):Void return ExtensionsNative.fogiv(pname, params);
    static function fogx(pname:Int, param:Int):Void return ExtensionsNative.fogx(pname, param);
    static function fogxOES(pname:Int, param:Int):Void return ExtensionsNative.fogxOES(pname, param);
    static function fogxv(pname:Int, param:DataPointer):Void return ExtensionsNative.fogxv(pname, param);
    static function fogxvOES(pname:Int, param:DataPointer):Void return ExtensionsNative.fogxvOES(pname, param);
    static function fragmentColorMaterialSGIX(face:Int, mode:Int):Void return ExtensionsNative.fragmentColorMaterialSGIX(face, mode);
    static function fragmentCoverageColorNV(color:Int):Void return ExtensionsNative.fragmentCoverageColorNV(color);
    static function fragmentLightModelfSGIX(pname:Int, param:Float):Void return ExtensionsNative.fragmentLightModelfSGIX(pname, param);
    static function fragmentLightModelfvSGIX(pname:Int, params:DataPointer):Void return ExtensionsNative.fragmentLightModelfvSGIX(pname, params);
    static function fragmentLightModeliSGIX(pname:Int, param:Int):Void return ExtensionsNative.fragmentLightModeliSGIX(pname, param);
    static function fragmentLightModelivSGIX(pname:Int, params:DataPointer):Void return ExtensionsNative.fragmentLightModelivSGIX(pname, params);
    static function fragmentLightfSGIX(light:Int, pname:Int, param:Float):Void return ExtensionsNative.fragmentLightfSGIX(light, pname, param);
    static function fragmentLightfvSGIX(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.fragmentLightfvSGIX(light, pname, params);
    static function fragmentLightiSGIX(light:Int, pname:Int, param:Int):Void return ExtensionsNative.fragmentLightiSGIX(light, pname, param);
    static function fragmentLightivSGIX(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.fragmentLightivSGIX(light, pname, params);
    static function fragmentMaterialfSGIX(face:Int, pname:Int, param:Float):Void return ExtensionsNative.fragmentMaterialfSGIX(face, pname, param);
    static function fragmentMaterialfvSGIX(face:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.fragmentMaterialfvSGIX(face, pname, params);
    static function fragmentMaterialiSGIX(face:Int, pname:Int, param:Int):Void return ExtensionsNative.fragmentMaterialiSGIX(face, pname, param);
    static function fragmentMaterialivSGIX(face:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.fragmentMaterialivSGIX(face, pname, params);
    static function frameTerminatorGREMEDY():Void return ExtensionsNative.frameTerminatorGREMEDY();
    static function frameZoomSGIX(factor:Int):Void return ExtensionsNative.frameZoomSGIX(factor);
    static function framebufferDrawBufferEXT(framebuffer:Int, mode:Int):Void return ExtensionsNative.framebufferDrawBufferEXT(framebuffer, mode);
    static function framebufferDrawBuffersEXT(framebuffer:Int, n:Int, bufs:DataPointer):Void return ExtensionsNative.framebufferDrawBuffersEXT(framebuffer, n, bufs);
    static function framebufferFetchBarrierEXT():Void return ExtensionsNative.framebufferFetchBarrierEXT();
    static function framebufferFetchBarrierQCOM():Void return ExtensionsNative.framebufferFetchBarrierQCOM();
    static function framebufferFoveationConfigQCOM(framebuffer:Int, numLayers:Int, focalPoin_tsPerLayer:Int, requestedFeatures:Int, providedFeatures:DataPointer):Void return ExtensionsNative.framebufferFoveationConfigQCOM(framebuffer, numLayers, focalPoin_tsPerLayer, requestedFeatures, providedFeatures);
    static function framebufferFoveationParametersQCOM(framebuffer:Int, layer:Int, focalPoin_t:Int, focalX:Float, focalY:Float, gain_X:Float, gain_Y:Float, foveaArea:Float):Void return ExtensionsNative.framebufferFoveationParametersQCOM(framebuffer, layer, focalPoin_t, focalX, focalY, gain_X, gain_Y, foveaArea);
    /**
    * - #### Purpose:
    * set a named parameter of a framebuffer object
    * ### Description:
    * **glFramebufferParameteri** and **glNamedFramebufferParameteri** modify the value of the parameter named **pname** in the specified framebuffer object. There are no modifiable parameters of the default draw and read framebuffer, so they are not valid targets of these commands.
    * 
    * For **glFramebufferParameteri**, the framebuffer object is that bound to **target**, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.
    * 
    * For **glNamedFramebufferParameteri**, **framebuffer** is the name of the framebuffer object.
    * 
    * **pname** specifies the parameter to be modified. The following values are accepted:
    * 
    * *``GL_FRAMEBUFFER_DEFAULT_WIDTH``* **param** specifies the assumed width for a framebuffer object with no attachments. If a framebuffer has attachments then the width of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_WIDTH` is used for the framebuffer. **param** must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_WIDTH`.
    * 
    * *``GL_FRAMEBUFFER_DEFAULT_HEIGHT``* **param** specifies the assumed height for a framebuffer object with no attachments. If a framebuffer has attachments then the height of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_HEIGHT` is used for the framebuffer. **param** must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_HEIGHT`.
    * 
    * *``GL_FRAMEBUFFER_DEFAULT_LAYERS``* **param** specifies the assumed number of layers for a framebuffer object with no attachments. If a framebuffer has attachments then the layer count of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_LAYERS` is used for the framebuffer. **param** must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_LAYERS`.
    * 
    * *``GL_FRAMEBUFFER_DEFAULT_SAMPLES``* **param** specifies the assumed number of samples in a framebuffer object with no attachments. If a framebuffer has attachments then the sample count of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_SAMPLES` is used for the framebuffer. **param** must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_SAMPLE`.
    * 
    * *``GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS``* **param** specifies whether the framebuffer should assume identical sample locations and the same number of samples for all texels in the virtual image. If **param** is zero, then the implementation may vary the position or the count of samples within the virtual image from pixel to pixel, otherwise it will use the same sample position and count for all pixels in the virtual image.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glFramebufferParameteri** if **target** is not one of the accepted framebuffer targets.
    * 
    * `GL_INVALID_OPERATION` is generated by **glFramebufferParameteri** if the default framebuffer is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glNamedFramebufferParameteri** if **framebuffer** is not the name of an existing framebuffer object.
    * 
    * `GL_INVALID_VALUE` is generated if **pname** is `GL_FRAMEBUFFER_DEFAULT_WIDTH` and **param** is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_WIDTH`.
    * 
    * `GL_INVALID_VALUE` is generated if **pname** is `GL_FRAMEBUFFER_DEFAULT_HEIGHT` and **param** is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_HEIGHT`.
    * 
    * `GL_INVALID_VALUE` is generated if **pname** is `GL_FRAMEBUFFER_DEFAULT_LAYERS` and **param** is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_LAYERS`.
    * 
    * `GL_INVALID_VALUE` is generated if **pname** is `GL_FRAMEBUFFER_DEFAULT_SAMPLES` and **param** is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_SAMPLES`.
    * 
    * @param target Specifies the target to which the framebuffer is bound for **glFramebufferParameteri**.
    * @param framebuffer Specifies the name of the framebuffer object for **glNamedFramebufferParameteri**.
    * @param pname Specifies the framebuffer parameter to be modified.
    * @param param The new value for the parameter named **pname**.

    * @see **`glBindFramebuffer`**, **`glCreateFramebuffers`**, **`glFramebufferRenderbuffer`**, **`glFramebufferTexture`**, **`glGenFramebuffers`**, **`glGetFramebufferParameter`**

    **/
    static function framebufferParameteri(target:Int, pname:Int, param:Int):Void return ExtensionsNative.framebufferParameteri(target, pname, param);
    static function framebufferPixelLocalStorageSizeEXT(target:Int, size:Int):Void return ExtensionsNative.framebufferPixelLocalStorageSizeEXT(target, size);
    static function framebufferReadBufferEXT(framebuffer:Int, mode:Int):Void return ExtensionsNative.framebufferReadBufferEXT(framebuffer, mode);
    /**
    * - #### Purpose:
    * attach a renderbuffer as a logical buffer of a framebuffer object
    * ### Description:
    * **glFramebufferRenderbuffer** and **glNamedFramebufferRenderbuffer** attaches a renderbuffer as one of the logical buffers of the specified framebuffer object. Renderbuffers cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands.
    * 
    * For **glFramebufferRenderbuffer**, the framebuffer object is that bound to **target**, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.
    * 
    * For **glNamedFramebufferRenderbuffer**, **framebuffer** is the name of the framebuffer object.
    * 
    * **renderbuffertarget** must be `GL_RENDERBUFFER`.
    * 
    * **renderbuffer** must be zero or the name of an existing renderbuffer object of type **renderbuffertarget**. If **renderbuffer** is not zero, then the specified renderbuffer will be used as the logical buffer identified by **attachment** of the specified framebuffer object. If **renderbuffer** is zero, then the value of **renderbuffertarget** is ignored.
    * 
    * **attachment** specifies the logical attachment of the framebuffer and must be `GL_COLOR_ATTACHMENT`i, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. i in may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one. Setting **attachment** to the value `GL_DEPTH_STENCIL_ATTACHMENT` is a special case causing both the depth and stencil attachments of the specified framebuffer object to be set to **renderbuffer**, which should have the base internal format `GL_DEPTH_STENCIL`.
    * 
    * The value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` for the specified attachment point is set to `GL_RENDERBUFFER` and the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` is set to **renderbuffer**. All other state values of specified attachment point are set to their default values. No change is made to the state of the renderbuuffer object and any previous attachment to the **attachment** logical buffer of the specified framebuffer object is broken.
    * 
    * If **renderbuffer** is zero, these commands will detach the image, if any, identified by the specified attachment point of the specified framebuffer object. All state values of the attachment point are set to their default values.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glFramebufferRenderbuffer** if **target** is not one of the accepted framebuffer targets.
    * 
    * `GL_INVALID_OPERATION` is generated by **glFramebufferRenderbuffer** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glNamedFramebufferRenderbuffer** if **framebuffer** is not the name of an existing framebuffer object.
    * 
    * `GL_INVALID_ENUM` is generated if **attachment** is not one of the accepted attachment points.
    * 
    * `GL_INVALID_ENUM` is generated if **renderbuffertarget** is not `GL_RENDERBUFFER`.
    * 
    * `GL_INVALID_OPERATION` is generated if **renderbuffertarget** is not zero or the name of an existing renderbuffer object of type `GL_RENDERBUFFER`.
    * 
    * @param target Specifies the target to which the framebuffer is bound for **glFramebufferRenderbuffer**.
    * @param framebuffer Specifies the name of the framebuffer object for **glNamedFramebufferRenderbuffer**.
    * @param attachment Specifies the attachment point of the framebuffer.
    * @param renderbuffertarget Specifies the renderbuffer target. Must be `GL_RENDERBUFFER`.
    * @param renderbuffer Specifies the name of an existing renderbuffer object of type **renderbuffertarget** to attach.

    * @see **`glGenFramebuffers`**, **`glBindFramebuffer`**, **`glGenRenderbuffers`**, **`glFramebufferTexture`**, **glFramebufferTexture1D**, **glFramebufferTexture2D**, **glFramebufferTexture3D**

    **/
    static function framebufferRenderbuffer(target:Int, attachment:Int, renderbuffertarget:Int, renderbuffer:Int):Void return ExtensionsNative.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    static function framebufferRenderbufferEXT(target:Int, attachment:Int, renderbuffertarget:Int, renderbuffer:Int):Void return ExtensionsNative.framebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
    static function framebufferRenderbufferOES(target:Int, attachment:Int, renderbuffertarget:Int, renderbuffer:Int):Void return ExtensionsNative.framebufferRenderbufferOES(target, attachment, renderbuffertarget, renderbuffer);
    static function framebufferSampleLocationsfvARB(target:Int, start:Int, count:Int, v:DataPointer):Void return ExtensionsNative.framebufferSampleLocationsfvARB(target, start, count, v);
    static function framebufferSampleLocationsfvNV(target:Int, start:Int, count:Int, v:DataPointer):Void return ExtensionsNative.framebufferSampleLocationsfvNV(target, start, count, v);
    static function framebufferSamplePositionsfvAMD(target:Int, numsamples:Int, pixelin_dex:Int, values:DataPointer):Void return ExtensionsNative.framebufferSamplePositionsfvAMD(target, numsamples, pixelin_dex, values);
    static function framebufferShadingRateEXT(target:Int, attachment:Int, texture:Int, baseLayer:Int, numLayers:Int, texelWidth:Int, texelHeight:Int):Void return ExtensionsNative.framebufferShadingRateEXT(target, attachment, texture, baseLayer, numLayers, texelWidth, texelHeight);
    /**
    * - #### Purpose:
    * attach a level of a texture object as a logical buffer of a framebuffer object
    * ### Description:
    * These commands attach a selected mipmap level or image of a texture object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands.
    * 
    * For all commands except **glNamedFramebufferTexture**, the framebuffer object is that bound to **target**, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.
    * 
    * For **glNamedFramebufferTexture**, **framebuffer** is the name of the framebuffer object.
    * 
    * **attachment** specifies the logical attachment of the framebuffer and must be `GL_COLOR_ATTACHMENT`i, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. i in `GL_COLOR_ATTACHMENT`i may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one. Attaching a level of a texture to `GL_DEPTH_STENCIL_ATTACHMENT` is equivalent to attaching that level to both the `GL_DEPTH_ATTACHMENT` and the `GL_STENCIL_ATTACHMENT` attachment points simultaneously.
    * 
    * For **glFramebufferTexture1D**, **glFramebufferTexture2D** and **glFramebufferTexture3D**, **textarget** specifies what type of texture is named by **texture**, and for cube map textures, specifies the face that is to be attached. If **texture** is not zero, it must be the name of an existing texture object with effective target **textarget** unless it is a cube map texture, in which case **textarget** must be `GL_TEXTURE_CUBE_MAP_POSITIVE_X` `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.
    * 
    * If **texture** is non-zero, the specified **level** of the texture object named **texture** is attached to the framebuffer attachment point named by **attachment**. For **glFramebufferTexture1D**, **glFramebufferTexture2D**, and **glFramebufferTexture3D**, **texture** must be zero or the name of an existing texture with an effective target of **textarget**, or **texture** must be the name of an existing cube-map texture and **textarget** must be one of `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.
    * 
    * If **textarget** is `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, then **level** must be zero.
    * 
    * If **textarget** is `GL_TEXTURE_3D`, then **level** must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_3D_TEXTURE_SIZE`.
    * 
    * If **textarget** is one of `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, then **level** must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_CUBE_MAP_TEXTURE_SIZE`.
    * 
    * For all other values of **textarget**, **level** must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * **layer** specifies the layer of a 2-dimensional image within a 3-dimensional texture.
    * 
    * For **glFramebufferTexture1D**, if **texture** is not zero, then **textarget** must be `GL_TEXTURE_1D`. For **glFramebufferTexture2D**, if **texture** is not zero, **textarget** must be one of `GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_2D_MULTISAMPLE`. For **glFramebufferTexture3D**, if **texture** is not zero, then **textarget** must be `GL_TEXTURE_3D`.
    * 
    * For **glFramebufferTexture** and **glNamedFramebufferTexture**, if **texture** is the name of a three-dimensional, cube map array, cube map, one- or two-dimensional array, or two-dimensional multisample array texture, the specified texture level is an array of images, and the framebuffer attachment is considered to be layered.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by all commands accepting a **target** parameter if it is not one of the accepted framebuffer targets.
    * 
    * `GL_INVALID_OPERATION` is generated by all commands accepting a **target** parameter if zero is bound to that target.
    * 
    * `GL_INVALID_OPERATION` is generated by **glNamedFramebufferTexture** if **framebuffer** is not the name of an existing framebuffer object.
    * 
    * `GL_INVALID_ENUM` is generated if **attachment** is not one of the accepted attachment points.
    * 
    * `GL_INVALID_VALUE` is generated if **texture** is not zero or the name of an existing texture object.
    * 
    * `GL_INVALID_VALUE` is generated if **texture** is not zero and **level** is not a supported texture level for **texture**.
    * 
    * `GL_INVALID_VALUE` is generated by **glFramebufferTexture3D** if **texture** is not zero and **layer** is larger than the value of `GL_MAX_3D_TEXTURE_SIZE` minus one.
    * 
    * `GL_INVALID_OPERATION` is generated by all commands accepting a **textarget** parameter if **texture** is not zero, and **textarget** and the effective target of **texture** are not compatible.
    * 
    * `GL_INVALID_OPERATION` is generated by if **texture** is a buffer texture.
    * 
    * @param target Specifies the target to which the framebuffer is bound for all commands except **glNamedFramebufferTexture**.
    * @param framebuffer Specifies the name of the framebuffer object for **glNamedFramebufferTexture**.
    * @param attachment Specifies the attachment point of the framebuffer.
    * @param textarget For **glFramebufferTexture1D**, **glFramebufferTexture2D** and **glFramebufferTexture3D**, specifies what type of texture is expected in the **texture** parameter, or for cube map textures, which face is to be attached.
    * @param texture Specifies the name of an existing texture object to attach.
    * @param level Specifies the mipmap level of the texture object to attach.

    * @see **`glGenFramebuffers`**, **`glBindFramebuffer`**, **`glGenRenderbuffers`**, **`glFramebufferTexture`**, **glFramebufferTexture1D**, **glFramebufferTexture2D**, **glFramebufferTexture3D**

    **/
    static function framebufferTexture(target:Int, attachment:Int, texture:Int, level:Int):Void return ExtensionsNative.framebufferTexture(target, attachment, texture, level);
    static function framebufferTexture1D(target:Int, attachment:Int, textarget:Int, texture:Int, level:Int):Void return ExtensionsNative.framebufferTexture1D(target, attachment, textarget, texture, level);
    static function framebufferTexture1DEXT(target:Int, attachment:Int, textarget:Int, texture:Int, level:Int):Void return ExtensionsNative.framebufferTexture1DEXT(target, attachment, textarget, texture, level);
    static function framebufferTexture2D(target:Int, attachment:Int, textarget:Int, texture:Int, level:Int):Void return ExtensionsNative.framebufferTexture2D(target, attachment, textarget, texture, level);
    static function framebufferTexture2DEXT(target:Int, attachment:Int, textarget:Int, texture:Int, level:Int):Void return ExtensionsNative.framebufferTexture2DEXT(target, attachment, textarget, texture, level);
    static function framebufferTexture2DDownsampleIMG(target:Int, attachment:Int, textarget:Int, texture:Int, level:Int, xscale:Int, yscale:Int):Void return ExtensionsNative.framebufferTexture2DDownsampleIMG(target, attachment, textarget, texture, level, xscale, yscale);
    static function framebufferTexture2DMultisampleEXT(target:Int, attachment:Int, textarget:Int, texture:Int, level:Int, samples:Int):Void return ExtensionsNative.framebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples);
    static function framebufferTexture2DMultisampleIMG(target:Int, attachment:Int, textarget:Int, texture:Int, level:Int, samples:Int):Void return ExtensionsNative.framebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples);
    static function framebufferTexture2DOES(target:Int, attachment:Int, textarget:Int, texture:Int, level:Int):Void return ExtensionsNative.framebufferTexture2DOES(target, attachment, textarget, texture, level);
    static function framebufferTexture3D(target:Int, attachment:Int, textarget:Int, texture:Int, level:Int, zoffset:Int):Void return ExtensionsNative.framebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
    static function framebufferTexture3DEXT(target:Int, attachment:Int, textarget:Int, texture:Int, level:Int, zoffset:Int):Void return ExtensionsNative.framebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);
    static function framebufferTexture3DOES(target:Int, attachment:Int, textarget:Int, texture:Int, level:Int, zoffset:Int):Void return ExtensionsNative.framebufferTexture3DOES(target, attachment, textarget, texture, level, zoffset);
    static function framebufferTextureARB(target:Int, attachment:Int, texture:Int, level:Int):Void return ExtensionsNative.framebufferTextureARB(target, attachment, texture, level);
    static function framebufferTextureEXT(target:Int, attachment:Int, texture:Int, level:Int):Void return ExtensionsNative.framebufferTextureEXT(target, attachment, texture, level);
    static function framebufferTextureFaceARB(target:Int, attachment:Int, texture:Int, level:Int, face:Int):Void return ExtensionsNative.framebufferTextureFaceARB(target, attachment, texture, level, face);
    static function framebufferTextureFaceEXT(target:Int, attachment:Int, texture:Int, level:Int, face:Int):Void return ExtensionsNative.framebufferTextureFaceEXT(target, attachment, texture, level, face);
    /**
    * - #### Purpose:
    * attach a single layer of a texture object as a logical buffer of a framebuffer object
    * ### Description:
    * **glFramebufferTextureLayer** and **glNamedFramebufferTextureLayer** attach a single layer of a three-dimensional or array texture object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands.
    * 
    * For **glFramebufferTextureLayer**, the framebuffer object is that bound to **target**, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.
    * 
    * For **glNamedFramebufferTextureLayer**, **framebuffer** is the name of the framebuffer object.
    * 
    * **attachment** specifies the logical attachment of the framebuffer and must be `GL_COLOR_ATTACHMENT`i, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. i in `GL_COLOR_ATTACHMENT`i may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one. Attaching a level of a texture to `GL_DEPTH_STENCIL_ATTACHMENT` is equivalent to attaching that level to both the `GL_DEPTH_ATTACHMENT` and the `GL_STENCIL_ATTACHMENT` attachment points simultaneously.
    * 
    * If **texture** is not zero, it must be the name of a three-dimensional, two-dimensional multisample array, one- or two-dimensional array, or cube map array texture.
    * 
    * If **texture** is a three-dimensional texture, then **level** must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_3D_TEXTURE_SIZE`.
    * 
    * If **texture** is a two-dimensional array texture, then **level** must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * For cube map textures, **layer** is translated into a cube map face according to $$ face = k \bmod 6. $$ For cube map array textures, **layer** is translated into an array layer and face according to $$ layer = \left\lfloor { layer \over 6 } \right\rfloor$$ and $$ face = k \bmod 6. $$
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glFramebufferTexture** if **target** is not one of the accepted framebuffer targets.
    * 
    * `GL_INVALID_OPERATION` is generated by **glFramebufferTexture** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glNamedFramebufferTexture** if **framebuffer** is not the name of an existing framebuffer object.
    * 
    * `GL_INVALID_ENUM` is generated if **attachment** is not one of the accepted attachment points.
    * 
    * `GL_INVALID_OPERATION` is generated if **texture** is not zero and is not the name of an existing three-dimensional, two-dimensional multisample array, one- or two-dimensional array, cube map, or cube map array texture.
    * 
    * `GL_INVALID_VALUE` is generated if **texture** is not zero and **level** is not a supported texture level for **texture**, as described above.
    * 
    * `GL_INVALID_VALUE` is generated if **texture** is not zero and **layer** is larger than the value of `GL_MAX_3D_TEXTURE_SIZE` minus one (for three-dimensional texture objects), or larger than the value of `GL_MAX_ARRAY_TEXTURE_LAYERS` minus one (for array texture objects).
    * 
    * `GL_INVALID_VALUE` is generated if **texture** is not zero and **layer** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated by if **texture** is a buffer texture.
    * 
    * @param target Specifies the target to which the framebuffer is bound for **glFramebufferTextureLayer**.
    * @param framebuffer Specifies the name of the framebuffer object for **glNamedFramebufferTextureLayer**.
    * @param attachment Specifies the attachment point of the framebuffer.
    * @param texture Specifies the name of an existing texture object to attach.
    * @param level Specifies the mipmap level of the texture object to attach.
    * @param layer Specifies the layer of the texture object to attach.

    * @see **`glGenFramebuffers`**, **`glBindFramebuffer`**, **`glGenRenderbuffers`**, **`glFramebufferTexture`**,

    **/
    static function framebufferTextureLayer(target:Int, attachment:Int, texture:Int, level:Int, layer:Int):Void return ExtensionsNative.framebufferTextureLayer(target, attachment, texture, level, layer);
    static function framebufferTextureLayerARB(target:Int, attachment:Int, texture:Int, level:Int, layer:Int):Void return ExtensionsNative.framebufferTextureLayerARB(target, attachment, texture, level, layer);
    static function framebufferTextureLayerEXT(target:Int, attachment:Int, texture:Int, level:Int, layer:Int):Void return ExtensionsNative.framebufferTextureLayerEXT(target, attachment, texture, level, layer);
    static function framebufferTextureLayerDownsampleIMG(target:Int, attachment:Int, texture:Int, level:Int, layer:Int, xscale:Int, yscale:Int):Void return ExtensionsNative.framebufferTextureLayerDownsampleIMG(target, attachment, texture, level, layer, xscale, yscale);
    static function framebufferTextureMultisampleMultiviewOVR(target:Int, attachment:Int, texture:Int, level:Int, samples:Int, baseViewIndex:Int, numViews:Int):Void return ExtensionsNative.framebufferTextureMultisampleMultiviewOVR(target, attachment, texture, level, samples, baseViewIndex, numViews);
    static function framebufferTextureMultiviewOVR(target:Int, attachment:Int, texture:Int, level:Int, baseViewIndex:Int, numViews:Int):Void return ExtensionsNative.framebufferTextureMultiviewOVR(target, attachment, texture, level, baseViewIndex, numViews);
    static function framebufferTextureOES(target:Int, attachment:Int, texture:Int, level:Int):Void return ExtensionsNative.framebufferTextureOES(target, attachment, texture, level);
    static function freeObjectBufferATI(buffer:Int):Void return ExtensionsNative.freeObjectBufferATI(buffer);
    /**
    * - #### Purpose:
    * define front- and back-facing polygons
    * ### Description:
    * In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the image. To enable and disable elimination of back-facing polygons, call **`glEnable`** and **glDisable** with argument `GL_CULL_FACE`.
    * 
    * The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of the polygon. The polygon's winding is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon. **glFrontFace** specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing. Passing `GL_CCW` to **mode** selects counterclockwise polygons as front-facing; `GL_CW` selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken to be front-facing.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * @param mode Specifies the orientation of front-facing polygons. `GL_CW` and `GL_CCW` are accepted. The initial value is `GL_CCW`.

    * @see **`glCullFace`**,

    **/
    static function frontFace(mode:Int):Void return ExtensionsNative.frontFace(mode);
    static function frustum(left:DataPointer, right:DataPointer, bottom:DataPointer, top:DataPointer, zNear:DataPointer, zFar:DataPointer):Void return ExtensionsNative.frustum(left, right, bottom, top, zNear, zFar);
    static function frustumf(l:Float, r:Float, b:Float, t:Float, n:Float, f:Float):Void return ExtensionsNative.frustumf(l, r, b, t, n, f);
    static function frustumfOES(l:Float, r:Float, b:Float, t:Float, n:Float, f:Float):Void return ExtensionsNative.frustumfOES(l, r, b, t, n, f);
    static function frustumx(l:Int, r:Int, b:Int, t:Int, n:Int, f:Int):Void return ExtensionsNative.frustumx(l, r, b, t, n, f);
    static function frustumxOES(l:Int, r:Int, b:Int, t:Int, n:Int, f:Int):Void return ExtensionsNative.frustumxOES(l, r, b, t, n, f);
    static function genAsyncMarkersSGIX(range:Int):Int return ExtensionsNative.genAsyncMarkersSGIX(range);
    /**
    * - #### Purpose:
    * generate buffer object names
    * ### Description:
    * **glGenBuffers** returns **n** buffer object names in **buffers**. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to **glGenBuffers**.
    * 
    * Buffer object names returned by a call to **glGenBuffers** are not returned by subsequent calls, unless they are first deleted with **`glDeleteBuffers`**.
    * 
    * No buffer objects are associated with the returned buffer object names until they are first bound by calling **`glBindBuffer`**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of buffer object names to be generated.
    * @param buffers Specifies an array in which the generated buffer object names are stored.

    * @see **`glBindBuffer`**, **`glDeleteBuffers`**, **`glGet`**

    **/
    static function genBuffers(n:Int, buffers:DataPointer):Void return ExtensionsNative.genBuffers(n, buffers);
    static function genBuffersARB(n:Int, buffers:DataPointer):Void return ExtensionsNative.genBuffersARB(n, buffers);
    static function genFencesAPPLE(n:Int, fences:DataPointer):Void return ExtensionsNative.genFencesAPPLE(n, fences);
    static function genFencesNV(n:Int, fences:DataPointer):Void return ExtensionsNative.genFencesNV(n, fences);
    static function genFragmentShadersATI(range:Int):Int return ExtensionsNative.genFragmentShadersATI(range);
    /**
    * - #### Purpose:
    * generate framebuffer object names
    * ### Description:
    * **glGenFramebuffers** returns **n** framebuffer object names in **ids**. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to **glGenFramebuffers**.
    * 
    * Framebuffer object names returned by a call to **glGenFramebuffers** are not returned by subsequent calls, unless they are first deleted with **`glDeleteFramebuffers`**.
    * 
    * The names returned in **ids** are marked as used, for the purposes of **glGenFramebuffers** only, but they acquire state and type only when they are first bound.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of framebuffer object names to generate.
    * @param ids Specifies an array in which the generated framebuffer object names are stored.

    * @see **`glBindFramebuffer`**, **`glDeleteFramebuffers`**

    **/
    static function genFramebuffers(n:Int, framebuffers:DataPointer):Void return ExtensionsNative.genFramebuffers(n, framebuffers);
    static function genFramebuffersEXT(n:Int, framebuffers:DataPointer):Void return ExtensionsNative.genFramebuffersEXT(n, framebuffers);
    static function genFramebuffersOES(n:Int, framebuffers:DataPointer):Void return ExtensionsNative.genFramebuffersOES(n, framebuffers);
    static function genLists(range:Int):Int return ExtensionsNative.genLists(range);
    static function genNamesAMD(identifier:Int, num:Int, names:DataPointer):Void return ExtensionsNative.genNamesAMD(identifier, num, names);
    static function genOcclusionQueriesNV(n:Int, ids:DataPointer):Void return ExtensionsNative.genOcclusionQueriesNV(n, ids);
    static function genPathsNV(range:Int):Int return ExtensionsNative.genPathsNV(range);
    static function genPerfMonitorsAMD(n:Int, monitors:DataPointer):Void return ExtensionsNative.genPerfMonitorsAMD(n, monitors);
    /**
    * - #### Purpose:
    * reserve program pipeline object names
    * ### Description:
    * **glGenProgramPipelines** returns **n** previously unused program pipeline object names in **pipelines**. These names are marked as used, for the purposes of **glGenProgramPipelines** only, but they acquire program pipeline state only when they are first bound.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param n Specifies the number of program pipeline object names to reserve.
    * @param pipelines Specifies an array of into which the reserved names will be written.

    * @see **`glDeleteProgramPipelines`**, **`glBindProgramPipeline`**, **`glIsProgramPipeline`**, **`glUseProgramStages`**, **`glUseProgram`**

    **/
    static function genProgramPipelines(n:Int, pipelin_es:DataPointer):Void return ExtensionsNative.genProgramPipelines(n, pipelin_es);
    static function genProgramPipelinesEXT(n:Int, pipelin_es:DataPointer):Void return ExtensionsNative.genProgramPipelinesEXT(n, pipelin_es);
    static function genProgramsARB(n:Int, programs:DataPointer):Void return ExtensionsNative.genProgramsARB(n, programs);
    static function genProgramsNV(n:Int, programs:DataPointer):Void return ExtensionsNative.genProgramsNV(n, programs);
    /**
    * - #### Purpose:
    * generate query object names
    * ### Description:
    * **glGenQueries** returns **n** query object names in **ids**. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to **glGenQueries**.
    * 
    * Query object names returned by a call to **glGenQueries** are not returned by subsequent calls, unless they are first deleted with **`glDeleteQueries`**.
    * 
    * No query objects are associated with the returned query object names until they are first used by calling **`glBeginQuery`**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of query object names to be generated.
    * @param ids Specifies an array in which the generated query object names are stored.

    * @see **`glBeginQuery`**, **`glDeleteQueries`**, **glEndQuery**

    **/
    static function genQueries(n:Int, ids:DataPointer):Void return ExtensionsNative.genQueries(n, ids);
    static function genQueriesARB(n:Int, ids:DataPointer):Void return ExtensionsNative.genQueriesARB(n, ids);
    static function genQueriesEXT(n:Int, ids:DataPointer):Void return ExtensionsNative.genQueriesEXT(n, ids);
    static function genQueryResourceTagNV(n:Int, tagIds:DataPointer):Void return ExtensionsNative.genQueryResourceTagNV(n, tagIds);
    /**
    * - #### Purpose:
    * generate renderbuffer object names
    * ### Description:
    * **glGenRenderbuffers** returns **n** renderbuffer object names in **renderbuffers**. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to **glGenRenderbuffers**.
    * 
    * Renderbuffer object names returned by a call to **glGenRenderbuffers** are not returned by subsequent calls, unless they are first deleted with **`glDeleteRenderbuffers`**.
    * 
    * The names returned in **renderbuffers** are marked as used, for the purposes of **glGenRenderbuffers** only, but they acquire state and type only when they are first bound.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of renderbuffer object names to generate.
    * @param renderbuffers Specifies an array in which the generated renderbuffer object names are stored.

    * @see **`glFramebufferRenderbuffer`**, **`glDeleteRenderbuffers`**

    **/
    static function genRenderbuffers(n:Int, renderbuffers:DataPointer):Void return ExtensionsNative.genRenderbuffers(n, renderbuffers);
    static function genRenderbuffersEXT(n:Int, renderbuffers:DataPointer):Void return ExtensionsNative.genRenderbuffersEXT(n, renderbuffers);
    static function genRenderbuffersOES(n:Int, renderbuffers:DataPointer):Void return ExtensionsNative.genRenderbuffersOES(n, renderbuffers);
    /**
    * - #### Purpose:
    * generate sampler object names
    * ### Description:
    * **glGenSamplers** returns **n** sampler object names in **samplers**. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to **glGenSamplers**.
    * 
    * Sampler object names returned by a call to **glGenSamplers** are not returned by subsequent calls, unless they are first deleted with **`glDeleteSamplers`**.
    * 
    * The names returned in **samplers** are marked as used, for the purposes of **glGenSamplers** only, but they acquire state and type only when they are first bound.
    * 
    * 
    * ### Notes:
    * **glGenSamplers** is available only if the GL version is 3.3 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of sampler object names to generate.
    * @param samplers Specifies an array in which the generated sampler object names are stored.

    * @see **`glBindSampler`**, **`glIsSampler`**, **`glDeleteSamplers`**

    **/
    static function genSamplers(count:Int, samplers:DataPointer):Void return ExtensionsNative.genSamplers(count, samplers);
    static function genSemaphoresEXT(n:Int, semaphores:DataPointer):Void return ExtensionsNative.genSemaphoresEXT(n, semaphores);
    static function genSymbolsEXT(datatype:Int, storagetype:Int, range:Int, components:Int):Int return ExtensionsNative.genSymbolsEXT(datatype, storagetype, range, components);
    /**
    * - #### Purpose:
    * generate texture names
    * ### Description:
    * **glGenTextures** returns **n** texture names in **textures**. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to **glGenTextures**.
    * 
    * The generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound (see **`glBindTexture`**).
    * 
    * Texture names returned by a call to **glGenTextures** are not returned by subsequent calls, unless they are first deleted with **`glDeleteTextures`**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of texture names to be generated.
    * @param textures Specifies an array in which the generated texture names are stored.

    * @see **`glBindTexture`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glDeleteTextures`**, **`glGet`**, **`glGetTexParameter`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexParameter`**

    **/
    static function genTextures(n:Int, textures:DataPointer):Void return ExtensionsNative.genTextures(n, textures);
    static function genTexturesEXT(n:Int, textures:DataPointer):Void return ExtensionsNative.genTexturesEXT(n, textures);
    /**
    * - #### Purpose:
    * reserve transform feedback object names
    * ### Description:
    * **glGenTransformFeedbacks** returns **n** previously unused transform feedback object names in **ids**. These names are marked as used, for the purposes of **glGenTransformFeedbacks** only, but they acquire transform feedback state only when they are first bound.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param n Specifies the number of transform feedback object names to reserve.
    * @param ids Specifies an array of into which the reserved names will be written.

    * @see **`glDeleteTransformFeedbacks`**, **`glBindTransformFeedback`**, **`glIsTransformFeedback`**, **`glBeginTransformFeedback`**, **`glPauseTransformFeedback`**, **`glResumeTransformFeedback`**, **glEndTransformFeedback**

    **/
    static function genTransformFeedbacks(n:Int, ids:DataPointer):Void return ExtensionsNative.genTransformFeedbacks(n, ids);
    static function genTransformFeedbacksNV(n:Int, ids:DataPointer):Void return ExtensionsNative.genTransformFeedbacksNV(n, ids);
    /**
    * - #### Purpose:
    * generate vertex array object names
    * ### Description:
    * **glGenVertexArrays** returns **n** vertex array object names in **arrays**. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to **glGenVertexArrays**.
    * 
    * Vertex array object names returned by a call to **glGenVertexArrays** are not returned by subsequent calls, unless they are first deleted with **`glDeleteVertexArrays`**.
    * 
    * The names returned in **arrays** are marked as used, for the purposes of **glGenVertexArrays** only, but they acquire state and type only when they are first bound.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **n** is negative.
    * 
    * @param n Specifies the number of vertex array object names to generate.
    * @param arrays Specifies an array in which the generated vertex array object names are stored.

    * @see **`glBindVertexArray`**, **`glDeleteVertexArrays`**

    **/
    static function genVertexArrays(n:Int, arrays:DataPointer):Void return ExtensionsNative.genVertexArrays(n, arrays);
    static function genVertexArraysAPPLE(n:Int, arrays:DataPointer):Void return ExtensionsNative.genVertexArraysAPPLE(n, arrays);
    static function genVertexArraysOES(n:Int, arrays:DataPointer):Void return ExtensionsNative.genVertexArraysOES(n, arrays);
    static function genVertexShadersEXT(range:Int):Int return ExtensionsNative.genVertexShadersEXT(range);
    /**
    * - #### Purpose:
    * generate mipmaps for a specified texture object
    * ### Description:
    * **glGenerateMipmap** and **glGenerateTextureMipmap** generates mipmaps for the specified texture object. For **glGenerateMipmap**, the texture object that is bound to **target**. For **glGenerateTextureMipmap**, **texture** is the name of the texture object.
    * 
    * For cube map and cube map array textures, the texture object must be cube complete or cube array complete respectively.
    * 
    * Mipmap generation replaces texel image levels $level_{base} + 1$ through $q$ with images derived from the $level_{base}$ image, regardless of their previous contents. All other mimap images, including the $level_{base}$ image, are left unchanged by this computation.
    * 
    * The internal formats of the derived mipmap images all match those of the $level_{base}$ image. The contents of the derived images are computed by repeated, filtered reduction of the $level_{base}$ image. For one- and two-dimensional array and cube map array textures, each layer is filtered independently.
    * 
    * 
    * ### Notes:
    * Cube map array textures are accepted only if the GL version is 4.0 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glGenerateMipmap** if **target** is not one of the accepted texture targets.
    * 
    * `GL_INVALID_OPERATION` is generated by **glGenerateTextureMipmap** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_OPERATION` is generated if **target** is `GL_TEXTURE_CUBE_MAP` or `GL_TEXTURE_CUBE_MAP_ARRAY`, and the specified texture object is not cube complete or cube array complete, respectively.
    * 
    * @param target Specifies the target to which the texture object is bound for **glGenerateMipmap**. Must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.
    * @param texture Specifies the texture object name for **glGenerateTextureMipmap**.

    * @see **`glTexImage2D`**, **`glBindTexture`**, **`glGenTextures`**

    **/
    static function generateMipmap(target:Int):Void return ExtensionsNative.generateMipmap(target);
    static function generateMipmapEXT(target:Int):Void return ExtensionsNative.generateMipmapEXT(target);
    static function generateMipmapOES(target:Int):Void return ExtensionsNative.generateMipmapOES(target);
    static function generateMultiTexMipmapEXT(texunit:Int, target:Int):Void return ExtensionsNative.generateMultiTexMipmapEXT(texunit, target);
    static function generateTextureMipmap(texture:Int):Void return ExtensionsNative.generateTextureMipmap(texture);
    static function generateTextureMipmapEXT(texture:Int, target:Int):Void return ExtensionsNative.generateTextureMipmapEXT(texture, target);
    /**
    * - #### Purpose:
    * retrieve information about the set of active atomic counter buffers for a program
    * ### Description:
    * **glGetActiveAtomicCounterBufferiv** retrieves information about the set of active atomic counter buffers for a program object. **program** is the name of a program object for which the command **`glLinkProgram`** has been issued in the past. It is not necessary for **program** to have been linked successfully. The link may have failed because the number of active atomic counters exceeded the limits.
    * 
    * **bufferIndex** specifies the index of an active atomic counter buffer and must be in the range zero to the value of `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS` minus one. The value of `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS` for **program** indicates the number of active atomic counter buffer and can be queried with **`glGetProgram`**.
    * 
    * If no error occurs, the parameter(s) specified by **pname** are returned in **params**. If an error is generated, the contents of **params** are not modified.
    * 
    * If **pname** is `GL_ATOMIC_COUNTER_BUFFER_BINDING`, then the index of the counter buffer binding point associated with the active atomic counter buffer **bufferIndex** for **program** is returned.
    * 
    * If **pname** is `GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE`, then the implementation-dependent minimum total buffer object size, in baseic machine units, required to hold all active atomic counters in the atomic counter binding point identified by **bufferIndex** is returned.
    * 
    * If **pname** is `GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS`, then the number of active atomic counters for the atomic counter buffer identified by **bufferIndex** is returned.
    * 
    * If **pname** is `GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES`, then a list of the active atomic counter indices for the atomic counter buffer identified by **bufferIndex** is returned. The number of elements that will be written into **params** is the value of `GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS` for **bufferIndex**.
    * 
    * If **pname** is `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER`, `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER`, `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER`, `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER`, `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER`, `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER` then a boolean value indicating whether the atomic counter buffer identified by **bufferIndex** is referenced by the vertex, tessellation control, tessellation evaluation, geometry, fragment or compute processing stages of **program**, respectively, is returned.
    * 
    * 
    * ### Notes:
    * **glGetActiveAtomicCounterBufferiv** is available only if the GL version is 4.2 or higher.
    * 
    * `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER` is available only of the GL version is 4.3 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not the name of a program object for which **`glLinkProgram`** has been called in the past.
    * 
    * `GL_INVALID_VALUE` is generated if **bufferIndex** is greater than or equal to the value of `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS` for **program**.
    * 
    * `GL_INVALID_ENUM` is generated if **pname** is not one of the accepted tokens.
    * 
    * @param program The name of a program object from which to retrieve information.
    * @param bufferIndex Specifies index of an active atomic counter buffer.
    * @param pname Specifies which parameter of the atomic counter buffer to retrieve.
    * @param params Specifies the address of a variable into which to write the retrieved information.

    * @see **`glGetProgram`**, **`glGetActiveSubroutineUniform`**, **`glGetActiveSubroutineUniformName`**, **`glGetUniformLocation`**

    **/
    static function getActiveAtomicCounterBufferiv(program:Int, bufferIndex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getActiveAtomicCounterBufferiv(program, bufferIndex, pname, params);
    /**
    * - #### Purpose:
    * Returns information about an active attribute variable for the specified program object
    * ### Description:
    * **glGetActiveAttrib** returns information about an active attribute variable in the program object specified by **program**. The number of active attributes can be obtained by calling **`glGetProgram`** with the value `GL_ACTIVE_ATTRIBUTES`. A value of 0 for **index** selects the first active attribute variable. Permissible values for **index** range from zero to the number of active attribute variables minus one.
    * 
    * A vertex shader may use either built-in attribute variables, user-defined attribute variables, or both. Built-in attribute variables have a prefix of "gl_" and reference conventional OpenGL vertex attribtes (e.g., **gl_Vertex**, **gl_Normal**, etc., see the OpenGL Shading Language specification for a complete list.) User-defined attribute variables have arbitrary names and obtain their values through numbered generic vertex attributes. An attribute variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, **program** should have previously been the target of a call to **`glLinkProgram`**, but it is not necessary for it to have been linked successfully.
    * 
    * The size of the character buffer required to store the longest attribute variable name in **program** can be obtained by calling **`glGetProgram`** with the value `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`. This value should be used to allocate a buffer of sufficient size to store the returned attribute name. The size of this character buffer is passed in **bufSize**, and a pointer to this character buffer is passed in **name**.
    * 
    * **glGetActiveAttrib** returns the name of the attribute variable indicated by **index**, storing it in the character buffer specified by **name**. The string returned will be null terminated. The actual number of characters written into this buffer is returned in **length**, and this count does not include the null termination character. If the length of the returned string is not required, a value of `NULL` can be passed in the **length** argument.
    * 
    * The **type** argument specifies a pointer to a variable into which the attribute variable's data type will be written. The symbolic constants `GL_FLOAT`, `GL_FLOAT_VEC2`, `GL_FLOAT_VEC3`, `GL_FLOAT_VEC4`, `GL_FLOAT_MAT2`, `GL_FLOAT_MAT3`, `GL_FLOAT_MAT4`, `GL_FLOAT_MAT2x3`, `GL_FLOAT_MAT2x4`, `GL_FLOAT_MAT3x2`, `GL_FLOAT_MAT3x4`, `GL_FLOAT_MAT4x2`, `GL_FLOAT_MAT4x3`, `GL_INT`, `GL_INT_VEC2`, `GL_INT_VEC3`, `GL_INT_VEC4`, `GL_UNSIGNED_INT`, `GL_UNSIGNED_INT_VEC2`, `GL_UNSIGNED_INT_VEC3`, `GL_UNSIGNED_INT_VEC4`, `GL_DOUBLE`, `GL_DOUBLE_VEC2`, `GL_DOUBLE_VEC3`, `GL_DOUBLE_VEC4`, `GL_DOUBLE_MAT2`, `GL_DOUBLE_MAT3`, `GL_DOUBLE_MAT4`, `GL_DOUBLE_MAT2x3`, `GL_DOUBLE_MAT2x4`, `GL_DOUBLE_MAT3x2`, `GL_DOUBLE_MAT3x4`, `GL_DOUBLE_MAT4x2`, or `GL_DOUBLE_MAT4x3` may be returned. The **size** argument will return the size of the attribute, in units of the type returned in **type**.
    * 
    * The list of active attribute variables may include both built-in attribute variables (which begin with the prefix "gl_") as well as user-defined attribute variable names.
    * 
    * This function will return as much information as it can about the specified active attribute variable. If no information is available, **length** will be 0, and **name** will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values **length**, **size**, **type**, and **name** will be unmodified.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the number of active attribute variables in **program**.
    * 
    * `GL_INVALID_VALUE` is generated if **bufSize** is less than 0.
    * 
    * @param program Specifies the program object to be queried.
    * @param index Specifies the index of the attribute variable to be queried.
    * @param bufSize Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by **name**.
    * @param length Returns the number of characters actually written by OpenGL in the string indicated by **name** (excluding the null terminator) if a value other than `NULL` is passed.
    * @param size Returns the size of the attribute variable.
    * @param type Returns the data type of the attribute variable.
    * @param name Returns a null terminated string containing the name of the attribute variable.

    * @see **`glBindAttribLocation`**, **`glLinkProgram`**, **`glVertexAttrib`**, **`glVertexAttribPointer`**

    **/
    static function getActiveAttrib(program:Int, in_dex:Int, bufSize:Int, length:DataPointer, size:DataPointer, type:DataPointer, name:Pointer<Char>):Void return ExtensionsNative.getActiveAttrib(program, in_dex, bufSize, length, size, type, name);
    static function getActiveAttribARB(programObj:Int, in_dex:Int, maxLength:Int, length:DataPointer, size:DataPointer, type:DataPointer, name:Pointer<Char>):Void return ExtensionsNative.getActiveAttribARB(programObj, in_dex, maxLength, length, size, type, name);
    /**
    * - #### Purpose:
    * query the name of an active shader subroutine
    * ### Description:
    * **glGetActiveSubroutineName** queries the name of an active shader subroutine uniform from the program object given in **program**. **index** specifies the index of the shader subroutine uniform within the shader stage given by **stage**, and must between zero and the value of `GL_ACTIVE_SUBROUTINES` minus one for the shader stage.
    * 
    * The name of the selected subroutine is returned as a null-terminated string in **name**. The actual number of characters written into **name**, not including the null-terminator, is returned in **length**. If **length** is `NULL`, no length is returned. The maximum number of characters that may be written into **name**, including the null-terminator, is given in **bufSize**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the value of `GL_ACTIVE_SUBROUTINES`.
    * 
    * `GL_INVALID_VALUE` is generated if **program** is not the name of an existing program object.
    * 
    * @param program Specifies the name of the program containing the subroutine.
    * @param shadertype Specifies the shader stage from which to query the subroutine name.
    * @param index Specifies the index of the shader subroutine uniform.
    * @param bufSize Specifies the size of the buffer whose address is given in **name**.
    * @param length Specifies the address of a variable which is to receive the length of the shader subroutine uniform name.
    * @param name Specifies the address of an array into which the name of the shader subroutine uniform will be written.

    * @see **`glGetSubroutineIndex`**, **`glGetActiveSubroutineUniform`**, **`glGetProgramStage`**

    **/
    static function getActiveSubroutineName(program:Int, shadertype:Int, in_dex:Int, bufSize:Int, length:DataPointer, name:Pointer<Char>):Void return ExtensionsNative.getActiveSubroutineName(program, shadertype, in_dex, bufSize, length, name);
    /**
    * - #### Purpose:
    * query the name of an active shader subroutine uniform
    * ### Description:
    * **glGetActiveSubroutineUniformName** retrieves the name of an active shader subroutine uniform. **program** contains the name of the program containing the uniform. **shadertype** specifies the stage for which the uniform location, given by **index**, is valid. **index** must be between zero and the value of `GL_ACTIVE_SUBROUTINE_UNIFORMS` minus one for the shader stage.
    * 
    * The uniform name is returned as a null-terminated string in **name**. The actual number of characters written into **name**, excluding the null terminator is returned in **length**. If **length** is `NULL`, no length is returned. The maximum number of characters that may be written into **name**, including the null terminator, is specified by **bufSize**. The length of the longest subroutine uniform name in **program** and **shadertype** is given by the value of `GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`, which can be queried with **`glGetProgramStage`**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **shadertype** or **pname** is not one of the accepted values.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the value of `GL_ACTIVE_SUBROUTINE_UNIFORMS`.
    * 
    * `GL_INVALID_VALUE` is generated if **program** is not the name of an existing program object.
    * 
    * @param program Specifies the name of the program containing the subroutine.
    * @param shadertype Specifies the shader stage from which to query for the subroutine parameter. **shadertype** must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.
    * @param index Specifies the index of the shader subroutine uniform.
    * @param bufSize Specifies the size of the buffer whose address is given in **name**.
    * @param length Specifies the address of a variable into which is written the number of characters copied into **name**.
    * @param name Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform.

    * @see **`glGetSubroutineIndex`**, **`glGetActiveSubroutineUniform`**, **`glGetProgramStage`**

    **/
    static function getActiveSubroutineUniformName(program:Int, shadertype:Int, in_dex:Int, bufSize:Int, length:DataPointer, name:Pointer<Char>):Void return ExtensionsNative.getActiveSubroutineUniformName(program, shadertype, in_dex, bufSize, length, name);
    static function getActiveSubroutineUniformiv(program:Int, shadertype:Int, in_dex:Int, pname:Int, values:DataPointer):Void return ExtensionsNative.getActiveSubroutineUniformiv(program, shadertype, in_dex, pname, values);
    /**
    * - #### Purpose:
    * Returns information about an active uniform variable for the specified program object
    * ### Description:
    * **glGetActiveUniform** returns information about an active uniform variable in the program object specified by **program**. The number of active uniform variables can be obtained by calling **`glGetProgram`** with the value `GL_ACTIVE_UNIFORMS`. A value of 0 for **index** selects the first active uniform variable. Permissible values for **index** range from zero to the number of active uniform variables minus one.
    * 
    * Shaders may use either built-in uniform variables, user-defined uniform variables, or both. Built-in uniform variables have a prefix of "gl_" and reference existing OpenGL state or values derived from such state (e.g., **gl_DepthRangeParameters**, see the OpenGL Shading Language specification for a complete list.) User-defined uniform variables have arbitrary names and obtain their values from the application through calls to **`glUniform`**. A uniform variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, **program** should have previously been the target of a call to **`glLinkProgram`**, but it is not necessary for it to have been linked successfully.
    * 
    * The size of the character buffer required to store the longest uniform variable name in **program** can be obtained by calling **`glGetProgram`** with the value `GL_ACTIVE_UNIFORM_MAX_LENGTH`. This value should be used to allocate a buffer of sufficient size to store the returned uniform variable name. The size of this character buffer is passed in **bufSize**, and a pointer to this character buffer is passed in **name.**
    * 
    * **glGetActiveUniform** returns the name of the uniform variable indicated by **index**, storing it in the character buffer specified by **name**. The string returned will be null terminated. The actual number of characters written into this buffer is returned in **length**, and this count does not include the null termination character. If the length of the returned string is not required, a value of `NULL` can be passed in the **length** argument.
    * 
    * The **type** argument will return a pointer to the uniform variable's data type. The symbolic constants returned for uniform types are shown in the table below. Returned Symbolic Contant Shader Uniform Type `GL_FLOAT` `float` `GL_FLOAT_VEC2` `vec2` `GL_FLOAT_VEC3` `vec3` `GL_FLOAT_VEC4` `vec4` `GL_DOUBLE` `double` `GL_DOUBLE_VEC2` `dvec2` `GL_DOUBLE_VEC3` `dvec3` `GL_DOUBLE_VEC4` `dvec4` `GL_INT` `int` `GL_INT_VEC2` `ivec2` `GL_INT_VEC3` `ivec3` `GL_INT_VEC4` `ivec4` `GL_UNSIGNED_INT` `unsigned int` `GL_UNSIGNED_INT_VEC2` `uvec2` `GL_UNSIGNED_INT_VEC3` `uvec3` `GL_UNSIGNED_INT_VEC4` `uvec4` `GL_BOOL` `bool` `GL_BOOL_VEC2` `bvec2` `GL_BOOL_VEC3` `bvec3` `GL_BOOL_VEC4` `bvec4` `GL_FLOAT_MAT2` `mat2` `GL_FLOAT_MAT3` `mat3` `GL_FLOAT_MAT4` `mat4` `GL_FLOAT_MAT2x3` `mat2x3` `GL_FLOAT_MAT2x4` `mat2x4` `GL_FLOAT_MAT3x2` `mat3x2` `GL_FLOAT_MAT3x4` `mat3x4` `GL_FLOAT_MAT4x2` `mat4x2` `GL_FLOAT_MAT4x3` `mat4x3` `GL_DOUBLE_MAT2` `dmat2` `GL_DOUBLE_MAT3` `dmat3` `GL_DOUBLE_MAT4` `dmat4` `GL_DOUBLE_MAT2x3` `dmat2x3` `GL_DOUBLE_MAT2x4` `dmat2x4` `GL_DOUBLE_MAT3x2` `dmat3x2` `GL_DOUBLE_MAT3x4` `dmat3x4` `GL_DOUBLE_MAT4x2` `dmat4x2` `GL_DOUBLE_MAT4x3` `dmat4x3` `GL_SAMPLER_1D` `sampler1D` `GL_SAMPLER_2D` `sampler2D` `GL_SAMPLER_3D` `sampler3D` `GL_SAMPLER_CUBE` `samplerCube` `GL_SAMPLER_1D_SHADOW` `sampler1DShadow` `GL_SAMPLER_2D_SHADOW` `sampler2DShadow` `GL_SAMPLER_1D_ARRAY` `sampler1DArray` `GL_SAMPLER_2D_ARRAY` `sampler2DArray` `GL_SAMPLER_1D_ARRAY_SHADOW` `sampler1DArrayShadow` `GL_SAMPLER_2D_ARRAY_SHADOW` `sampler2DArrayShadow` `GL_SAMPLER_2D_MULTISAMPLE` `sampler2DMS` `GL_SAMPLER_2D_MULTISAMPLE_ARRAY` `sampler2DMSArray` `GL_SAMPLER_CUBE_SHADOW` `samplerCubeShadow` `GL_SAMPLER_BUFFER` `samplerBuffer` `GL_SAMPLER_2D_RECT` `sampler2DRect` `GL_SAMPLER_2D_RECT_SHADOW` `sampler2DRectShadow` `GL_INT_SAMPLER_1D` `isampler1D` `GL_INT_SAMPLER_2D` `isampler2D` `GL_INT_SAMPLER_3D` `isampler3D` `GL_INT_SAMPLER_CUBE` `isamplerCube` `GL_INT_SAMPLER_1D_ARRAY` `isampler1DArray` `GL_INT_SAMPLER_2D_ARRAY` `isampler2DArray` `GL_INT_SAMPLER_2D_MULTISAMPLE` `isampler2DMS` `GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY` `isampler2DMSArray` `GL_INT_SAMPLER_BUFFER` `isamplerBuffer` `GL_INT_SAMPLER_2D_RECT` `isampler2DRect` `GL_UNSIGNED_INT_SAMPLER_1D` `usampler1D` `GL_UNSIGNED_INT_SAMPLER_2D` `usampler2D` `GL_UNSIGNED_INT_SAMPLER_3D` `usampler3D` `GL_UNSIGNED_INT_SAMPLER_CUBE` `usamplerCube` `GL_UNSIGNED_INT_SAMPLER_1D_ARRAY` `usampler2DArray` `GL_UNSIGNED_INT_SAMPLER_2D_ARRAY` `usampler2DArray` `GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE` `usampler2DMS` `GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY` `usampler2DMSArray` `GL_UNSIGNED_INT_SAMPLER_BUFFER` `usamplerBuffer` `GL_UNSIGNED_INT_SAMPLER_2D_RECT` `usampler2DRect` `GL_IMAGE_1D` `image1D` `GL_IMAGE_2D` `image2D` `GL_IMAGE_3D` `image3D` `GL_IMAGE_2D_RECT` `image2DRect` `GL_IMAGE_CUBE` `imageCube` `GL_IMAGE_BUFFER` `imageBuffer` `GL_IMAGE_1D_ARRAY` `image1DArray` `GL_IMAGE_2D_ARRAY` `image2DArray` `GL_IMAGE_2D_MULTISAMPLE` `image2DMS` `GL_IMAGE_2D_MULTISAMPLE_ARRAY` `image2DMSArray` `GL_INT_IMAGE_1D` `iimage1D` `GL_INT_IMAGE_2D` `iimage2D` `GL_INT_IMAGE_3D` `iimage3D` `GL_INT_IMAGE_2D_RECT` `iimage2DRect` `GL_INT_IMAGE_CUBE` `iimageCube` `GL_INT_IMAGE_BUFFER` `iimageBuffer` `GL_INT_IMAGE_1D_ARRAY` `iimage1DArray` `GL_INT_IMAGE_2D_ARRAY` `iimage2DArray` `GL_INT_IMAGE_2D_MULTISAMPLE` `iimage2DMS` `GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY` `iimage2DMSArray` `GL_UNSIGNED_INT_IMAGE_1D` `uimage1D` `GL_UNSIGNED_INT_IMAGE_2D` `uimage2D` `GL_UNSIGNED_INT_IMAGE_3D` `uimage3D` `GL_UNSIGNED_INT_IMAGE_2D_RECT` `uimage2DRect` `GL_UNSIGNED_INT_IMAGE_CUBE` `uimageCube` `GL_UNSIGNED_INT_IMAGE_BUFFER` `uimageBuffer` `GL_UNSIGNED_INT_IMAGE_1D_ARRAY` `uimage1DArray` `GL_UNSIGNED_INT_IMAGE_2D_ARRAY` `uimage2DArray` `GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE` `uimage2DMS` `GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY` `uimage2DMSArray` `GL_UNSIGNED_INT_ATOMIC_COUNTER` `atomic_uint`
    * 
    * If one or more elements of an array are active, the name of the array is returned in **name**, the type is returned in **type**, and the **size** parameter returns the highest array element index used, plus one, as determined by the compiler and/or linker. Only one active uniform variable will be reported for a uniform array.
    * 
    * Uniform variables that are declared as structures or arrays of structures will not be returned directly by this function. Instead, each of these uniform variables will be reduced to its fundamental components containing the "." and "[]" operators such that each of the names is valid as an argument to **`glGetUniformLocation`**. Each of these reduced uniform variables is counted as one active uniform variable and is assigned an index. A valid name cannot be a structure, an array of structures, or a subcomponent of a vector or matrix.
    * 
    * The size of the uniform variable will be returned in **size**. Uniform variables other than arrays will have a size of 1. Structures and arrays of structures will be reduced as described earlier, such that each of the names returned will be a data type in the earlier list. If this reduction results in an array, the size returned will be as described for uniform arrays; otherwise, the size returned will be 1.
    * 
    * The list of active uniform variables may include both built-in uniform variables (which begin with the prefix "gl_") as well as user-defined uniform variable names.
    * 
    * This function will return as much information as it can about the specified active uniform variable. If no information is available, **length** will be 0, and **name** will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values **length**, **size**, **type**, and **name** will be unmodified.
    * 
    * 
    * ### Notes:
    * The double types, `GL_DOUBLE`, `GL_DOUBLE_VEC2`, `GL_DOUBLE_VEC3`, `GL_DOUBLE_VEC4`, `GL_DOUBLE_MAT2`, `GL_DOUBLE_MAT3`, `GL_DOUBLE_MAT4`, `GL_DOUBLE_MAT2x3`, `GL_DOUBLE_MAT2x4`, `GL_DOUBLE_MAT3x2`, `GL_DOUBLE_MAT3x4`, `GL_DOUBLE_MAT4x2`, and `GL_DOUBLE_MAT4x3` are only available if the GL version is 4.1 or higher.
    * 
    * The image types, `GL_IMAGE_1D`, `GL_IMAGE_2D`, `GL_IMAGE_3D`, `GL_IMAGE_2D_RECT`, `GL_IMAGE_CUBE`, `GL_IMAGE_BUFFER`, `GL_IMAGE_1D_ARRAY`, `GL_IMAGE_2D_ARRAY`, `GL_IMAGE_2D_MULTISAMPLE`, `GL_IMAGE_2D_MULTISAMPLE_ARRAY`, `GL_INT_IMAGE_1D`, `GL_INT_IMAGE_2D`, `GL_INT_IMAGE_3D`, `GL_INT_IMAGE_2D_RECT`, `GL_INT_IMAGE_CUBE`, `GL_INT_IMAGE_BUFFER`, `GL_INT_IMAGE_1D_ARRAY`, `GL_INT_IMAGE_2D_ARRAY`, `GL_INT_IMAGE_2D_MULTISAMPLE`, `GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY`, `GL_UNSIGNED_INT_IMAGE_1D`, `GL_UNSIGNED_INT_IMAGE_2D`, `GL_UNSIGNED_INT_IMAGE_3D`, `GL_UNSIGNED_INT_IMAGE_2D_RECT`, `GL_UNSIGNED_INT_IMAGE_CUBE`, `GL_UNSIGNED_INT_IMAGE_BUFFER`, `GL_UNSIGNED_INT_IMAGE_1D_ARRAY`, `GL_UNSIGNED_INT_IMAGE_2D_ARRAY`, `GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE`, `GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY`, and the atomic counter type, `GL_UNSIGNED_INT_ATOMIC_COUNTER` are only available if the GL version is 4.2 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the number of active uniform variables in **program**.
    * 
    * `GL_INVALID_VALUE` is generated if **bufSize** is less than 0.
    * 
    * @param program Specifies the program object to be queried.
    * @param index Specifies the index of the uniform variable to be queried.
    * @param bufSize Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by **name**.
    * @param length Returns the number of characters actually written by OpenGL in the string indicated by **name** (excluding the null terminator) if a value other than `NULL` is passed.
    * @param size Returns the size of the uniform variable.
    * @param type Returns the data type of the uniform variable.
    * @param name Returns a null terminated string containing the name of the uniform variable.

    * @see **`glGetUniform`**, **`glGetUniformLocation`**, **`glLinkProgram`**, **`glUniform`**, **`glUseProgram`**

    **/
    static function getActiveUniform(program:Int, in_dex:Int, bufSize:Int, length:DataPointer, size:DataPointer, type:DataPointer, name:Pointer<Char>):Void return ExtensionsNative.getActiveUniform(program, in_dex, bufSize, length, size, type, name);
    static function getActiveUniformARB(programObj:Int, in_dex:Int, maxLength:Int, length:DataPointer, size:DataPointer, type:DataPointer, name:Pointer<Char>):Void return ExtensionsNative.getActiveUniformARB(programObj, in_dex, maxLength, length, size, type, name);
    /**
    * - #### Purpose:
    * retrieve the name of an active uniform block
    * ### Description:
    * **glGetActiveUniformBlockName** retrieves the name of the active uniform block at **uniformBlockIndex** within **program**.
    * 
    * **program** must be the name of a program object for which the command **`glLinkProgram`** must have been called in the past, although it is not required that **`glLinkProgram`** must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.
    * 
    * **uniformBlockIndex** is an active uniform block index of **program**, and must be less than the value of `GL_ACTIVE_UNIFORM_BLOCKS`.
    * 
    * Upon success, the name of the uniform block identified by **unifomBlockIndex** is returned into **uniformBlockName**. The name is nul-terminated. The actual number of characters written into **uniformBlockName**, excluding the nul terminator, is returned in **length**. If **length** is NULL, no length is returned.
    * 
    * **bufSize** contains the maximum number of characters (including the nul terminator) that will be written into **uniformBlockName**.
    * 
    * If an error occurs, nothing will be written to **uniformBlockName** or **length**.
    * 
    * 
    * ### Notes:
    * **glGetActiveUniformBlockName** is available only if the GL version is 3.1 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **program** is not the name of a program object for which **`glLinkProgram`** has been called in the past.
    * 
    * `GL_INVALID_VALUE` is generated if **uniformBlockIndex** is greater than or equal to the value of `GL_ACTIVE_UNIFORM_BLOCKS` or is not the index of an active uniform block in **program**.
    * 
    * @param program Specifies the name of a program containing the uniform block.
    * @param uniformBlockIndex Specifies the index of the uniform block within **program**.
    * @param bufSize Specifies the size of the buffer addressed by **uniformBlockName**.
    * @param length Specifies the address of a variable to receive the number of characters that were written to **uniformBlockName**.
    * @param uniformBlockName Specifies the address an array of characters to receive the name of the uniform block at **uniformBlockIndex**.

    * @see **`glGetActiveUniformBlock`**, **`glGetUniformBlockIndex`**

    **/
    static function getActiveUniformBlockName(program:Int, uniformBlockIndex:Int, bufSize:Int, length:DataPointer, uniformBlockName:Pointer<Char>):Void return ExtensionsNative.getActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
    static function getActiveUniformBlockiv(program:Int, uniformBlockIndex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
    /**
    * - #### Purpose:
    * query the name of an active uniform
    * ### Description:
    * **glGetActiveUniformName** returns the name of the active uniform at **uniformIndex** within **program**. If **uniformName** is not NULL, up to **bufSize** characters (including a nul-terminator) will be written into the array whose address is specified by **uniformName**. If **length** is not NULL, the number of characters that were (or would have been) written into **uniformName** (not including the nul-terminator) will be placed in the variable whose address is specified in **length**. If **length** is NULL, no length is returned. The length of the longest uniform name in **program** is given by the value of `GL_ACTIVE_UNIFORM_MAX_LENGTH`, which can be queried with **`glGetProgram`**.
    * 
    * If **glGetActiveUniformName** is not successful, nothing is written to **length** or **uniformName**.
    * 
    * **program** must be the name of a program for which the command **`glLinkProgram`** has been issued in the past. It is not necessary for **program** to have been linked successfully. The link could have failed because the number of active uniforms exceeded the limit.
    * 
    * **uniformIndex** must be an active uniform index of the program **program**, in the range zero to the value of `GL_ACTIVE_UNIFORMS` minus one. The value of `GL_ACTIVE_UNIFORMS` can be queried with **`glGetProgram`**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **uniformIndex** is greater than or equal to the value of `GL_ACTIVE_UNIFORMS`.
    * 
    * `GL_INVALID_VALUE` is generated if **bufSize** is negative.
    * 
    * `GL_INVALID_VALUE` is generated if **program** is not the name of a program object for which **`glLinkProgram`** has been issued.
    * 
    * @param program Specifies the program containing the active uniform index **uniformIndex**.
    * @param uniformIndex Specifies the index of the active uniform whose name to query.
    * @param bufSize Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in **uniformName**.
    * @param length Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by **uniformName**.
    * @param uniformName Specifies the address of a buffer into which the GL will place the name of the active uniform at **uniformIndex** within **program**.

    * @see **`glGetActiveUniform`**, **`glGetUniformIndices`**, **`glGetProgram`**, **`glLinkProgram`**

    **/
    static function getActiveUniformName(program:Int, uniformIndex:Int, bufSize:Int, length:DataPointer, uniformName:Pointer<Char>):Void return ExtensionsNative.getActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
    /**
    * - #### Purpose:
    * Returns information about several active uniform variables for the specified program object
    * ### Description:
    * **glGetActiveUniformsiv** queries the value of the parameter named **pname** for each of the uniforms within **program** whose indices are specified in the array of **uniformCount** unsigned integers **uniformIndices**. Upon success, the value of the parameter for each uniform is written into the corresponding entry in the array whose address is given in **params**. If an error is generated, nothing is written into **params**.
    * 
    * If **pname** is `GL_UNIFORM_TYPE`, then an array identifying the types of uniforms specified by the corresponding array of **uniformIndices** is returned. The returned types can be any of the values from the following table: Returned Symbolic Contant Shader Uniform Type `GL_FLOAT` `float` `GL_FLOAT_VEC2` `vec2` `GL_FLOAT_VEC3` `vec3` `GL_FLOAT_VEC4` `vec4` `GL_DOUBLE` `double` `GL_DOUBLE_VEC2` `dvec2` `GL_DOUBLE_VEC3` `dvec3` `GL_DOUBLE_VEC4` `dvec4` `GL_INT` `int` `GL_INT_VEC2` `ivec2` `GL_INT_VEC3` `ivec3` `GL_INT_VEC4` `ivec4` `GL_UNSIGNED_INT` `unsigned int` `GL_UNSIGNED_INT_VEC2` `uvec2` `GL_UNSIGNED_INT_VEC3` `uvec3` `GL_UNSIGNED_INT_VEC4` `uvec4` `GL_BOOL` `bool` `GL_BOOL_VEC2` `bvec2` `GL_BOOL_VEC3` `bvec3` `GL_BOOL_VEC4` `bvec4` `GL_FLOAT_MAT2` `mat2` `GL_FLOAT_MAT3` `mat3` `GL_FLOAT_MAT4` `mat4` `GL_FLOAT_MAT2x3` `mat2x3` `GL_FLOAT_MAT2x4` `mat2x4` `GL_FLOAT_MAT3x2` `mat3x2` `GL_FLOAT_MAT3x4` `mat3x4` `GL_FLOAT_MAT4x2` `mat4x2` `GL_FLOAT_MAT4x3` `mat4x3` `GL_DOUBLE_MAT2` `dmat2` `GL_DOUBLE_MAT3` `dmat3` `GL_DOUBLE_MAT4` `dmat4` `GL_DOUBLE_MAT2x3` `dmat2x3` `GL_DOUBLE_MAT2x4` `dmat2x4` `GL_DOUBLE_MAT3x2` `dmat3x2` `GL_DOUBLE_MAT3x4` `dmat3x4` `GL_DOUBLE_MAT4x2` `dmat4x2` `GL_DOUBLE_MAT4x3` `dmat4x3` `GL_SAMPLER_1D` `sampler1D` `GL_SAMPLER_2D` `sampler2D` `GL_SAMPLER_3D` `sampler3D` `GL_SAMPLER_CUBE` `samplerCube` `GL_SAMPLER_1D_SHADOW` `sampler1DShadow` `GL_SAMPLER_2D_SHADOW` `sampler2DShadow` `GL_SAMPLER_1D_ARRAY` `sampler1DArray` `GL_SAMPLER_2D_ARRAY` `sampler2DArray` `GL_SAMPLER_1D_ARRAY_SHADOW` `sampler1DArrayShadow` `GL_SAMPLER_2D_ARRAY_SHADOW` `sampler2DArrayShadow` `GL_SAMPLER_2D_MULTISAMPLE` `sampler2DMS` `GL_SAMPLER_2D_MULTISAMPLE_ARRAY` `sampler2DMSArray` `GL_SAMPLER_CUBE_SHADOW` `samplerCubeShadow` `GL_SAMPLER_BUFFER` `samplerBuffer` `GL_SAMPLER_2D_RECT` `sampler2DRect` `GL_SAMPLER_2D_RECT_SHADOW` `sampler2DRectShadow` `GL_INT_SAMPLER_1D` `isampler1D` `GL_INT_SAMPLER_2D` `isampler2D` `GL_INT_SAMPLER_3D` `isampler3D` `GL_INT_SAMPLER_CUBE` `isamplerCube` `GL_INT_SAMPLER_1D_ARRAY` `isampler1DArray` `GL_INT_SAMPLER_2D_ARRAY` `isampler2DArray` `GL_INT_SAMPLER_2D_MULTISAMPLE` `isampler2DMS` `GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY` `isampler2DMSArray` `GL_INT_SAMPLER_BUFFER` `isamplerBuffer` `GL_INT_SAMPLER_2D_RECT` `isampler2DRect` `GL_UNSIGNED_INT_SAMPLER_1D` `usampler1D` `GL_UNSIGNED_INT_SAMPLER_2D` `usampler2D` `GL_UNSIGNED_INT_SAMPLER_3D` `usampler3D` `GL_UNSIGNED_INT_SAMPLER_CUBE` `usamplerCube` `GL_UNSIGNED_INT_SAMPLER_1D_ARRAY` `usampler2DArray` `GL_UNSIGNED_INT_SAMPLER_2D_ARRAY` `usampler2DArray` `GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE` `usampler2DMS` `GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY` `usampler2DMSArray` `GL_UNSIGNED_INT_SAMPLER_BUFFER` `usamplerBuffer` `GL_UNSIGNED_INT_SAMPLER_2D_RECT` `usampler2DRect`
    * 
    * If **pname** is `GL_UNIFORM_SIZE`, then an array identifying the size of the uniforms specified by the corresponding array of **uniformIndices** is returned. The sizes returned are in units of the type returned by a query of `GL_UNIFORM_TYPE`. For active uniforms that are arrays, the size is the number of active elements in the array; for all other uniforms, the size is one.
    * 
    * If **pname** is `GL_UNIFORM_NAME_LENGTH`, then an array identifying the length, including the terminating null character, of the uniform name strings specified by the corresponding array of **uniformIndices** is returned.
    * 
    * If **pname** is `GL_UNIFORM_BLOCK_INDEX`, then an array identifying the uniform block index of each of the uniforms specified by the corresponding array of **uniformIndices** is returned. The uniform block index of a uniform associated with the default uniform block is -1.
    * 
    * If **pname** is `GL_UNIFORM_OFFSET`, then an array of uniform buffer offsets is returned. For uniforms in a named uniform block, the returned value will be its offset, in basic machine units, relative to the beginning of the uniform block in the buffer object data store. For atomic counter uniforms, the returned value will be its offset relative to the beginning of its active atomic counter buffer. For all other uniforms, -1 will be returned.
    * 
    * If **pname** is `GL_UNIFORM_ARRAY_STRIDE`, then an array identifying the stride between elements of each of the uniforms specified by the corresponding array of **uniformIndices** is returned. For uniforms in named uniform blocks and for uniforms declared as atomic counters, the stride is the difference, in basic machine units, of consecutive elements in an array, or zero for uniforms not declared as an array. For all other uniforms, a stride of -1 will be returned.
    * 
    * If **pname** is `GL_UNIFORM_MATRIX_STRIDE`, then an array identifying the stride between columns of a column-major matrix or rows of a row-major matrix, in basic machine units, of each of the uniforms specified by the corresponding array of **uniformIndices** is returned. The matrix stride of a uniform associated with the default uniform block is -1. Note that this information only makes sense for uniforms that are matrices. For uniforms that are not matrices, but are declared in a named uniform block, a matrix stride of zero is returned.
    * 
    * If **pname** is `GL_UNIFORM_IS_ROW_MAJOR`, then an array identifying whether each of the uniforms specified by the corresponding array of **uniformIndices** is a row-major matrix or not is returned. A value of one indicates a row-major matrix, and a value of zero indicates a column-major matrix, a matrix in the default uniform block, or a non-matrix.
    * 
    * If **pname** is `GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX`, then an array identifying the active atomic counter buffer index of each of the uniforms specified by the corresponding array of **uniformIndices** is returned. For uniforms other than atomic counters, the returned buffer index is -1. The returned indices may be passed to **`glGetActiveAtomicCounterBufferiv`** to query the properties of the associated buffer, and not necessarily the binding point specified in the uniform declaration.
    * 
    * 
    * ### Notes:
    * The double types, `GL_DOUBLE`, `GL_DOUBLE_VEC2`, `GL_DOUBLE_VEC3`, `GL_DOUBLE_VEC4`, `GL_DOUBLE_MAT2`, `GL_DOUBLE_MAT3`, `GL_DOUBLE_MAT4`, `GL_DOUBLE_MAT2x3`, `GL_DOUBLE_MAT2x4`, `GL_DOUBLE_MAT3x2`, `GL_DOUBLE_MAT3x4`, `GL_DOUBLE_MAT4x2`, and `GL_DOUBLE_MAT4x3` are only available if the GL version is 4.1 or higher.
    * 
    * `GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX` is only accepted by **pname** if the GL version is 4.2 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * `GL_INVALID_VALUE` is generated if **uniformCount** is greater than or equal to the value of `GL_ACTIVE_UNIFORMS` for **program**.
    * 
    * `GL_INVALID_ENUM` is generated if **pname** is not an accepted token.
    * 
    * @param program Specifies the program object to be queried.
    * @param uniformCount Specifies both the number of elements in the array of indices **uniformIndices** and the number of parameters written to **params** upon successful return.
    * @param uniformIndices Specifies the address of an array of **uniformCount** integers containing the indices of uniforms within **program** whose parameter **pname** should be queried.
    * @param pname Specifies the property of each uniform in **uniformIndices** that should be written into the corresponding element of **params**.
    * @param params Specifies the address of an array of **uniformCount** integers which are to receive the value of **pname** for each uniform in **uniformIndices**.

    * @see **`glGetUniform`**, **`glGetActiveUniform`**, **`glGetUniformLocation`**, **`glLinkProgram`**, **`glUniform`**, **`glUseProgram`**

    **/
    static function getActiveUniformsiv(program:Int, uniformCount:Int, uniformIndices:DataPointer, pname:Int, params:DataPointer):Void return ExtensionsNative.getActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
    static function getActiveVaryingNV(program:Int, in_dex:Int, bufSize:Int, length:DataPointer, size:DataPointer, type:DataPointer, name:Pointer<Char>):Void return ExtensionsNative.getActiveVaryingNV(program, in_dex, bufSize, length, size, type, name);
    static function getArrayObjectfvATI(array:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getArrayObjectfvATI(array, pname, params);
    static function getArrayObjectivATI(array:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getArrayObjectivATI(array, pname, params);
    static function getAttachedObjectsARB(contain_erObj:Int, maxCount:Int, count:DataPointer, obj:DataPointer):Void return ExtensionsNative.getAttachedObjectsARB(contain_erObj, maxCount, count, obj);
    /**
    * - #### Purpose:
    * Returns the handles of the shader objects attached to a program object
    * ### Description:
    * **glGetAttachedShaders** returns the names of the shader objects attached to **program**. The names of shader objects that are attached to **program** will be returned in **shaders.** The actual number of shader names written into **shaders** is returned in **count.** If no shader objects are attached to **program**, **count** is set to 0. The maximum number of shader names that may be returned in **shaders** is specified by **maxCount**.
    * 
    * If the number of names actually returned is not required (for instance, if it has just been obtained by calling **`glGetProgram`**), a value of `NULL` may be passed for count. If no shader objects are attached to **program**, a value of 0 will be returned in **count**. The actual number of attached shaders can be obtained by calling **`glGetProgram`** with the value `GL_ATTACHED_SHADERS`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * `GL_INVALID_VALUE` is generated if **maxCount** is less than 0.
    * 
    * @param program Specifies the program object to be queried.
    * @param maxCount Specifies the size of the array for storing the returned object names.
    * @param count Returns the number of names actually returned in **shaders**.
    * @param shaders Specifies an array that is used to return the names of attached shader objects.

    * @see **`glAttachShader`**, **`glDetachShader`**.

    **/
    static function getAttachedShaders(program:Int, maxCount:Int, count:DataPointer, shaders:DataPointer):Void return ExtensionsNative.getAttachedShaders(program, maxCount, count, shaders);
    /**
    * - #### Purpose:
    * Returns the location of an attribute variable
    * ### Description:
    * **glGetAttribLocation** queries the previously linked program object specified by **program** for the attribute variable specified by **name** and returns the index of the generic vertex attribute that is bound to that attribute variable. If **name** is a matrix attribute variable, the index of the first column of the matrix is returned. If the named attribute variable is not an active attribute in the specified program object or if **name** starts with the reserved prefix "gl_", a value of -1 is returned.
    * 
    * The association between an attribute variable name and a generic attribute index can be specified at any time by calling **`glBindAttribLocation`**. Attribute bindings do not go into effect until **`glLinkProgram`** is called. After a program object has been linked successfully, the index values for attribute variables remain fixed until the next link command occurs. The attribute values can only be queried after a link if the link was successful. **glGetAttribLocation** returns the binding that actually went into effect the last time **`glLinkProgram`** was called for the specified program object. Attribute bindings that have been specified since the last link operation are not returned by **glGetAttribLocation**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **program** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** has not been successfully linked.
    * 
    * @param program Specifies the program object to be queried.
    * @param name Points to a null terminated string containing the name of the attribute variable whose location is to be queried.

    * @see **`glBindAttribLocation`**, **`glLinkProgram`**, **`glVertexAttrib`**, **`glVertexAttribPointer`**

    **/
    static function getAttribLocation(program:Int, name:String):Int return ExtensionsNative.getAttribLocation(program, name);
    static function getAttribLocationARB(programObj:Int, name:String):Int return ExtensionsNative.getAttribLocationARB(programObj, name);
    static function getBooleanIndexedvEXT(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getBooleanIndexedvEXT(target, in_dex, data);
    static function getBooleani_v(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getBooleani_v(target, in_dex, data);
    static function getBooleanv(pname:Int, data:DataPointer):Void return ExtensionsNative.getBooleanv(pname, data);
    static function getBufferParameteri64v(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getBufferParameteri64v(target, pname, params);
    static function getBufferParameteriv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getBufferParameteriv(target, pname, params);
    static function getBufferParameterivARB(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getBufferParameterivARB(target, pname, params);
    static function getBufferParameterui64vNV(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getBufferParameterui64vNV(target, pname, params);
    /**
    * - #### Purpose:
    * return the pointer to a mapped buffer object's data store
    * ### Description:
    * **glGetBufferPointerv** and **glGetNamedBufferPointerv** return the buffer pointer **pname**, which must be `GL_BUFFER_MAP_POINTER`. The single buffer map pointer is returned in **params**. A `NULL` pointer is returned if the buffer object's data store is not currently mapped; or if the requesting context did not map the buffer object's data store, and the implementation is unable to support mappings on multiple clients.
    * 
    * 
    * ### Notes:
    * If an error is generated, no change is made to the contents of **params**.
    * 
    * The initial value for the pointer is `NULL`.
    * 
    * The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.
    * 
    * The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.
    * 
    * The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if by **glGetBufferPointerv** if **target** is not one of the accepted buffer targets, or if **pname** is not `GL_BUFFER_MAP_POINTER`.
    * 
    * `GL_INVALID_OPERATION` is generated by **glGetBufferPointerv** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glGetNamedBufferPointerv** if **buffer** is not the name of an existing buffer object.
    * 
    * @param target Specifies the target to which the buffer object is bound for **glGetBufferPointerv**, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of the buffer object for **glGetNamedBufferPointerv**.
    * @param pname Specifies the name of the pointer to be returned. Must be `GL_BUFFER_MAP_POINTER`.
    * @param params Returns the pointer value specified by **pname**.

    * @see **`glBindBuffer`**, **`glMapBuffer`**

    **/
    static function getBufferPointerv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getBufferPointerv(target, pname, params);
    static function getBufferPointervARB(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getBufferPointervARB(target, pname, params);
    static function getBufferPointervOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getBufferPointervOES(target, pname, params);
    /**
    * - #### Purpose:
    * returns a subset of a buffer object's data store
    * ### Description:
    * **glGetBufferSubData** and **glGetNamedBufferSubData** return some or all of the data contents of the data store of the specified buffer object. Data starting at byte offset **offset** and extending for **size** bytes is copied from the buffer object's data store to the memory pointed to by **data**. An error is thrown if the buffer object is currently mapped, or if **offset** and **size** together define a range beyond the bounds of the buffer object's data store.
    * 
    * 
    * ### Notes:
    * If an error is generated, no change is made to the contents of **data**.
    * 
    * The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.
    * 
    * The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.
    * 
    * The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glGetBufferSubData** if **target** is not one of the generic buffer binding targets.
    * 
    * `GL_INVALID_OPERATION` is generated by **glGetBufferSubData** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glGetNamedBufferSubData** if **buffer** is not the name of an existing buffer object.
    * 
    * `GL_INVALID_VALUE` is generated if **offset** or **size** is negative, or if $offset + size$ is greater than the value of `GL_BUFFER_SIZE` for the buffer object.
    * 
    * `GL_INVALID_OPERATION` is generated if the buffer object is mapped with **`glMapBufferRange`** or **`glMapBuffer`**, unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the **glMapBufferRange** **access** flags.
    * 
    * @param target Specifies the target to which the buffer object is bound for **glGetBufferSubData**, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of the buffer object for **glGetNamedBufferSubData**.
    * @param offset Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
    * @param size Specifies the size in bytes of the data store region being returned.
    * @param data Specifies a pointer to the location where buffer object data is returned.

    * @see **`glBindBuffer`**, **`glBufferData`**, **`glBufferSubData`**, **`glMapBuffer`**, **`glUnmapBuffer`**

    **/
    static function getBufferSubData(target:Int, offset:Int, size:Int, data:DataPointer):Void return ExtensionsNative.getBufferSubData(target, offset, size, data);
    static function getBufferSubDataARB(target:Int, offset:Int, size:Int, data:DataPointer):Void return ExtensionsNative.getBufferSubDataARB(target, offset, size, data);
    static function getClipPlane(plane:Int, equation:DataPointer):Void return ExtensionsNative.getClipPlane(plane, equation);
    static function getClipPlanef(plane:Int, equation:DataPointer):Void return ExtensionsNative.getClipPlanef(plane, equation);
    static function getClipPlanefOES(plane:Int, equation:DataPointer):Void return ExtensionsNative.getClipPlanefOES(plane, equation);
    static function getClipPlanex(plane:Int, equation:DataPointer):Void return ExtensionsNative.getClipPlanex(plane, equation);
    static function getClipPlanexOES(plane:Int, equation:DataPointer):Void return ExtensionsNative.getClipPlanexOES(plane, equation);
    static function getColorTable(target:Int, format:Int, type:Int, table:DataPointer):Void return ExtensionsNative.getColorTable(target, format, type, table);
    static function getColorTableEXT(target:Int, format:Int, type:Int, data:DataPointer):Void return ExtensionsNative.getColorTableEXT(target, format, type, data);
    static function getColorTableParameterfv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getColorTableParameterfv(target, pname, params);
    static function getColorTableParameterfvEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getColorTableParameterfvEXT(target, pname, params);
    static function getColorTableParameterfvSGI(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getColorTableParameterfvSGI(target, pname, params);
    static function getColorTableParameteriv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getColorTableParameteriv(target, pname, params);
    static function getColorTableParameterivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getColorTableParameterivEXT(target, pname, params);
    static function getColorTableParameterivSGI(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getColorTableParameterivSGI(target, pname, params);
    static function getColorTableSGI(target:Int, format:Int, type:Int, table:DataPointer):Void return ExtensionsNative.getColorTableSGI(target, format, type, table);
    static function getCombinerInputParameterfvNV(stage:Int, portion:Int, variable:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getCombinerInputParameterfvNV(stage, portion, variable, pname, params);
    static function getCombinerInputParameterivNV(stage:Int, portion:Int, variable:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getCombinerInputParameterivNV(stage, portion, variable, pname, params);
    static function getCombinerOutputParameterfvNV(stage:Int, portion:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getCombinerOutputParameterfvNV(stage, portion, pname, params);
    static function getCombinerOutputParameterivNV(stage:Int, portion:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getCombinerOutputParameterivNV(stage, portion, pname, params);
    static function getCombinerStageParameterfvNV(stage:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getCombinerStageParameterfvNV(stage, pname, params);
    static function getCommandHeaderNV(tokenID:Int, size:Int):Int return ExtensionsNative.getCommandHeaderNV(tokenID, size);
    static function getCompressedMultiTexImageEXT(texunit:Int, target:Int, lod:Int, img:DataPointer):Void return ExtensionsNative.getCompressedMultiTexImageEXT(texunit, target, lod, img);
    /**
    * - #### Purpose:
    * return a compressed texture image
    * ### Description:
    * **glGetCompressedTexImage** and **glGetnCompressedTexImage** return the compressed texture image associated with **target** and **lod** into **pixels**. **glGetCompressedTextureImage** serves the same purpose, but instead of taking a texture target, it takes the ID of the texture object. **pixels** should be an array of **bufSize** bytes for **glGetnCompresedTexImage** and **glGetCompressedTextureImage** functions, and of `GL_TEXTURE_COMPRESSED_IMAGE_SIZE` bytes in case of **glGetCompressedTexImage**. If the actual data takes less space than **bufSize**, the remaining bytes will not be touched. **target** specifies the texture target, to which the texture the data the function should extract the data from is bound to. **lod** specifies the level-of-detail number of the desired image.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is requested, **pixels** is treated as a byte offset into the buffer object's data store.
    * 
    * To minimize errors, first verify that the texture is compressed by calling **`glGetTexLevelParameter`** with argument `GL_TEXTURE_COMPRESSED`. If the texture is compressed, you can determine the amount of memory required to store the compressed texture by calling **`glGetTexLevelParameter`** with argument `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`. Finally, retrieve the internal format of the texture by calling **`glGetTexLevelParameter`** with argument `GL_TEXTURE_INTERNAL_FORMAT`. To store the texture for later use, associate the internal format and size with the retrieved texture image. These data can be used by the respective texture or subtexture loading routine used for loading **target** textures.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated by **glGetCompressedTextureImage** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than zero or greater than the maximum number of LODs permitted by the implementation.
    * 
    * `GL_INVALID_OPERATION` is generated if **glGetCompressedTexImage**, **glGetnCompressedTexImage**, and **glGetCompressedTextureImage** is used to retrieve a texture that is in an uncompressed internal format.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target, the buffer storage was not initialized with **glBufferStorage** using `GL_MAP_PERSISTENT_BIT` flag, and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size.
    * 
    * @param target Specifies the target to which the texture is bound for **glGetCompressedTexImage** and **glGetnCompressedTexImage** functions. `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, and `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_TEXTURE_RECTANGLE` are accepted.
    * @param texture Specifies the texture object name for **glGetCompressedTextureImage** function.
    * @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.
    * @param bufSize Specifies the size of the buffer **pixels** for **glGetCompressedTextureImage** and **glGetnCompressedTexImage** functions.
    * @param pixels Returns the compressed texture image.

    * @see **`glActiveTexture`**, **`glCompressedTexImage1D`**, **`glCompressedTexImage2D`**, **`glCompressedTexImage3D`**, **`glCompressedTexSubImage1D`**, **`glCompressedTexSubImage2D`**, **`glCompressedTexSubImage3D`**, **`glReadPixels`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexParameter`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**

    **/
    static function getCompressedTexImage(target:Int, level:Int, img:DataPointer):Void return ExtensionsNative.getCompressedTexImage(target, level, img);
    static function getCompressedTexImageARB(target:Int, level:Int, img:DataPointer):Void return ExtensionsNative.getCompressedTexImageARB(target, level, img);
    static function getCompressedTextureImage(texture:Int, level:Int, bufSize:Int, pixels:DataPointer):Void return ExtensionsNative.getCompressedTextureImage(texture, level, bufSize, pixels);
    static function getCompressedTextureImageEXT(texture:Int, target:Int, lod:Int, img:DataPointer):Void return ExtensionsNative.getCompressedTextureImageEXT(texture, target, lod, img);
    /**
    * - #### Purpose:
    * retrieve a sub-region of a compressed texture image from a
        compressed texture object
    * ### Description:
    * **glGetCompressedTextureSubImage** can be used to obtain a sub-region of a compressed texture image instead of the whole image, as long as the compressed data are arranged into fixed-size blocks of texels. **texture** is the name of the texture object, and must not be a buffer or multisample texture. The effective **target** is the value of `GL_TEXTURE_TARGET` for texture. **level** and **pixels** have the same meaning as the corresponding arguments of **glCompressedTexSubImage3D**. **bufSize** indicates the size of the buffer to receive the retrieved pixel data.
    * 
    * For cube map textures, the behavior is as though **glGetCompressedTexImage** were called once for each requested face (selected by **zoffset** and **depth**, as described below) with target corresponding to the requested texture cube map face as indicated by the table presented below. **pixels** is offset appropriately for each successive image.
    * 
    * **xoffset**, **yoffset** and **zoffset** indicate the position of the subregion to return. **width**, **height** and **depth** indicate the size of the region to return. These arguments have the same meaning as for **glCompressedTexSubImage3D**, though there are extra restrictions, described in the errors section below.
    * 
    * The mapping between the **xoffset**, **yoffset**, **zoffset**, **width**, **height** and **depth** parameters and the faces, layers, and layer-faces for cube map, array, and cube map array textures is the same as for glGetTextureSubImage.
    * 
    * The **xoffset**, **yoffset**, **zoffset** offsets and **width**, **height** and **depth** sizes must be multiples of the values of `GL_PACK_COMPRESSED_BLOCK_WIDTH`, `GL_PACK_COMPRESSED_BLOCK_HEIGHT`, and `GL_PACK_COMPRESSED_BLOCK_DEPTH` respectively, unless **offset** is zero and the corresponding **size** is the same as the texture size in that dimension.
    * 
    * Pixel storage modes are treated as for **glGetCompressedTexSubImage**. The texel at (**xoffset**, **yoffset**, **zoffset**) will be stored at the location indicated by **pixels** and the current pixel packing parameters.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` error is generated if **texture** is the name of a buffer or multisample texture.
    * 
    * `GL_INVALID_OPERATION` error is generated if the buffer size required to store the requested data is greater than **bufSize**.
    * 
    * `GL_INVALID_OPERATION` error is generated if the texture compression format is not based on fixed-size blocks.
    * 
    * `GL_INVALID_VALUE` error is generated if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_VALUE` is generated if **xoffset**, **yoffset** or **zoffset** are negative.
    * 
    * `GL_INVALID_VALUE` is generated if **xoffset** + **width** is greater than the texture's width, **yoffset** + **height** is greater than the texture's height, or **zoffset** + **depth** is greater than the texture's depth.
    * 
    * `GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D` and either **yoffset** is not zero, or **height** is not one.
    * 
    * `GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D` or `GL_TEXTURE_RECTANGLE` and either **zoffset** is not zero, or **depth** is not one.
    * 
    * `GL_INVALID_VALUE` error is generated if **xoffset**, **yoffset** or **zoffset** is not a multiple of the compressed block width, height or depth respectively.
    * 
    * `GL_INVALID_VALUE` error is generated if **width**, **height** or **depth** is not a multiple of the compressed block width, height or depth respectively, unless the **offset** is zero and the **size** equals the texture image size.
    * 
    * @param texture Specifies the name of the source texture object. Must be `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY` or `GL_TEXTURE_RECTANGLE`. In specific, buffer and multisample textures are not permitted.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.
    * @param xoffset Specifies a texel offset in the x direction within the texture array.
    * @param yoffset Specifies a texel offset in the y direction within the texture array.
    * @param zoffset Specifies a texel offset in the z direction within the texture array.
    * @param width Specifies the width of the texture subimage. Must be a multiple of the compressed block's width, unless the **offset** is zero and the size equals the texture image size.
    * @param height Specifies the height of the texture subimage. Must be a multiple of the compressed block's height, unless the **offset** is zero and the size equals the texture image size.
    * @param depth Specifies the depth of the texture subimage. Must be a multiple of the compressed block's depth, unless the **offset** is zero and the size equals the texture image size.
    * @param bufSize Specifies the size of the buffer to receive the retrieved pixel data.
    * @param pixels Returns the texture subimage. Should be a pointer to an array of the type specified by type.

    * @see **`glCompressedTexImage1D`**, **`glCompressedTexImage2D`**, **`glCompressedTexImage3D`**, **`glCompressedTexSubImage1D`**, **`glCompressedTexSubImage2D`**, **`glCompressedTexSubImage3D`**, **`glGetCompressedTexImage`**, **glGetCompressedTextureImage**, **`glReadPixels`**

    **/
    static function getCompressedTextureSubImage(texture:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, bufSize:Int, pixels:DataPointer):Void return ExtensionsNative.getCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
    static function getConvolutionFilter(target:Int, format:Int, type:Int, image:DataPointer):Void return ExtensionsNative.getConvolutionFilter(target, format, type, image);
    static function getConvolutionFilterEXT(target:Int, format:Int, type:Int, image:DataPointer):Void return ExtensionsNative.getConvolutionFilterEXT(target, format, type, image);
    static function getConvolutionParameterfv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getConvolutionParameterfv(target, pname, params);
    static function getConvolutionParameterfvEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getConvolutionParameterfvEXT(target, pname, params);
    static function getConvolutionParameteriv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getConvolutionParameteriv(target, pname, params);
    static function getConvolutionParameterivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getConvolutionParameterivEXT(target, pname, params);
    static function getConvolutionParameterxvOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getConvolutionParameterxvOES(target, pname, params);
    static function getCoverageModulationTableNV(bufSize:Int, v:DataPointer):Void return ExtensionsNative.getCoverageModulationTableNV(bufSize, v);
    /**
    * - #### Purpose:
    * retrieve messages from the debug message log
    * ### Description:
    * **glGetDebugMessageLog** retrieves messages from the debug message log. A maximum of **count** messages are retrieved from the log. If **sources** is not NULL then the source of each message is written into up to **count** elements of the array. If **types** is not NULL then the type of each message is written into up to **count** elements of the array. If **id** is not NULL then the identifier of each message is written into up to **count** elements of the array. If **severities** is not NULL then the severity of each message is written into up to **count** elements of the array. If **lengths** is not NULL then the length of each message is written into up to **count** elements of the array.
    * 
    * **messageLog** specifies the address of a character array into which the debug messages will be written. Each message will be concatenated onto the array starting at the first element of **messageLog**. **bufSize** specifies the size of the array **messageLog**. If a message will not fit into the remaining space in **messageLog** then the function terminates and returns the number of messages written so far, which may be zero.
    * 
    * If **glGetDebugMessageLog** returns zero then no messages are present in the debug log, or there was not enough space in **messageLog** to retrieve the first message in the queue. If **messageLog** is NULL then no messages are written and the value of **bufSize** is ignored.
    * 
    * 
    * ### Notes:
    * Although debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug context may produce no messages at all.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **count** or **bufSize** is negative.
    * 
    * @param count The number of debug messages to retrieve from the log.
    * @param bufSize The size of the buffer whose address is given by **messageLog**.
    * @param sources The address of an array of variables to receive the sources of the retrieved messages.
    * @param types The address of an array of variables to receive the types of the retrieved messages.
    * @param ids The address of an array of unsigned integers to receive the ids of the retrieved messages.
    * @param severities The address of an array of variables to receive the severites of the retrieved messages.
    * @param lengths The address of an array of variables to receive the lengths of the received messages.
    * @param messageLog The address of an array of characters that will receive the messages.

    * @see **`glDebugMessageInsert`**, **`glDebugMessageCallback`**, **`glDebugMessageControl`**.

    **/
    static function getDebugMessageLog(count:Int, bufSize:Int, sources:DataPointer, types:DataPointer, ids:DataPointer, severities:DataPointer, lengths:DataPointer, messageLog:Pointer<Char>):Int return ExtensionsNative.getDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    static function getDebugMessageLogAMD(count:Int, bufSize:Int, categories:DataPointer, severities:DataPointer, ids:DataPointer, lengths:DataPointer, message:Pointer<Char>):Int return ExtensionsNative.getDebugMessageLogAMD(count, bufSize, categories, severities, ids, lengths, message);
    static function getDebugMessageLogARB(count:Int, bufSize:Int, sources:DataPointer, types:DataPointer, ids:DataPointer, severities:DataPointer, lengths:DataPointer, messageLog:Pointer<Char>):Int return ExtensionsNative.getDebugMessageLogARB(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    static function getDebugMessageLogKHR(count:Int, bufSize:Int, sources:DataPointer, types:DataPointer, ids:DataPointer, severities:DataPointer, lengths:DataPointer, messageLog:Pointer<Char>):Int return ExtensionsNative.getDebugMessageLogKHR(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    static function getDetailTexFuncSGIS(target:Int, poin_ts:DataPointer):Void return ExtensionsNative.getDetailTexFuncSGIS(target, poin_ts);
    static function getDoubleIndexedvEXT(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getDoubleIndexedvEXT(target, in_dex, data);
    static function getDoublei_v(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getDoublei_v(target, in_dex, data);
    static function getDoublei_vEXT(pname:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getDoublei_vEXT(pname, in_dex, params);
    static function getDoublev(pname:Int, data:DataPointer):Void return ExtensionsNative.getDoublev(pname, data);
    static function getDriverControlStringQCOM(driverControl:Int, bufSize:Int, length:DataPointer, driverControlStrin_g:Pointer<Char>):Void return ExtensionsNative.getDriverControlStringQCOM(driverControl, bufSize, length, driverControlStrin_g);
    static function getDriverControlsQCOM(num:DataPointer, size:Int, driverControls:DataPointer):Void return ExtensionsNative.getDriverControlsQCOM(num, size, driverControls);
    /**
    * - #### Purpose:
    * return error information
    * ### Description:
    * **glGetError** returns the value of the error flag. Each detectable error is assigned a numeric code and symbolic name. When an error occurs, the error flag is set to the appropriate error code value. No other errors are recorded until **glGetError** is called, the error code is returned, and the flag is reset to `GL_NO_ERROR`. If a call to **glGetError** returns `GL_NO_ERROR`, there has been no detectable error since the last call to **glGetError**, or since the GL was initialized.
    * 
    * To allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to `GL_NO_ERROR` when **glGetError** is called. If more than one flag has recorded an error, **glGetError** returns and clears an arbitrary error flag value. Thus, **glGetError** should always be called in a loop, until it returns `GL_NO_ERROR`, if all error flags are to be reset.
    * 
    * Initially, all error flags are set to `GL_NO_ERROR`.
    * 
    * The following errors are currently defined:
    * 
    * *``GL_NO_ERROR``* No error has been recorded. The value of this symbolic constant is guaranteed to be 0.
    * 
    * *``GL_INVALID_ENUM``* An unacceptable value is specified for an enumerated argument. The offending command is ignored and has no other side effect than to set the error flag.
    * 
    * *``GL_INVALID_VALUE``* A numeric argument is out of range. The offending command is ignored and has no other side effect than to set the error flag.
    * 
    * *``GL_INVALID_OPERATION``* The specified operation is not allowed in the current state. The offending command is ignored and has no other side effect than to set the error flag.
    * 
    * *``GL_INVALID_FRAMEBUFFER_OPERATION``* The framebuffer object is not complete. The offending command is ignored and has no other side effect than to set the error flag.
    * 
    * *``GL_OUT_OF_MEMORY``* There is not enough memory left to execute the command. The state of the GL is undefined, except for the state of the error flags, after this error is recorded.
    * 
    * *``GL_STACK_UNDERFLOW``* An attempt has been made to perform an operation that would cause an internal stack to underflow.
    * 
    * *``GL_STACK_OVERFLOW``* An attempt has been made to perform an operation that would cause an internal stack to overflow.
    * 
    * When an error flag is set, results of a GL operation are undefined only if `GL_OUT_OF_MEMORY` has occurred. In all other cases, the command generating the error is ignored and has no effect on the GL state or frame buffer contents. If the generating command returns a value, it returns 0. If **glGetError** itself generates an error, it returns 0.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * * @see **/
    static function getError():Int return ExtensionsNative.getError();
    static function getFenceivNV(fence:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFenceivNV(fence, pname, params);
    static function getFinalCombinerInputParameterfvNV(variable:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFinalCombinerInputParameterfvNV(variable, pname, params);
    static function getFinalCombinerInputParameterivNV(variable:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFinalCombinerInputParameterivNV(variable, pname, params);
    static function getFirstPerfQueryIdINTEL(queryId:DataPointer):Void return ExtensionsNative.getFirstPerfQueryIdINTEL(queryId);
    static function getFixedv(pname:Int, params:DataPointer):Void return ExtensionsNative.getFixedv(pname, params);
    static function getFixedvOES(pname:Int, params:DataPointer):Void return ExtensionsNative.getFixedvOES(pname, params);
    static function getFloatIndexedvEXT(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getFloatIndexedvEXT(target, in_dex, data);
    static function getFloati_v(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getFloati_v(target, in_dex, data);
    static function getFloati_vEXT(pname:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getFloati_vEXT(pname, in_dex, params);
    static function getFloati_vNV(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getFloati_vNV(target, in_dex, data);
    static function getFloati_vOES(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getFloati_vOES(target, in_dex, data);
    static function getFloatv(pname:Int, data:DataPointer):Void return ExtensionsNative.getFloatv(pname, data);
    static function getFogFuncSGIS(poin_ts:DataPointer):Void return ExtensionsNative.getFogFuncSGIS(poin_ts);
    /**
    * - #### Purpose:
    * query the bindings of color indices to user-defined varying out variables
    * ### Description:
    * **glGetFragDataIndex** returns the index of the fragment color to which the variable **name** was bound when the program object **program** was last linked. If **name** is not a varying out variable of **program**, or if an error occurs, -1 will be returned.
    * 
    * 
    * ### Notes:
    * **glGetFragDataIndex** is available only if the GL version is 3.3 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **program** is not the name of a program object.
    * 
    * @param program The name of the program containing varying out variable whose binding to query
    * @param name The name of the user-defined varying out variable whose index to query

    * @see **`glCreateProgram`**, **`glBindFragDataLocation`**, **`glBindFragDataLocationIndexed`**, **`glGetFragDataLocation`**

    **/
    static function getFragDataIndex(program:Int, name:String):Int return ExtensionsNative.getFragDataIndex(program, name);
    static function getFragDataIndexEXT(program:Int, name:String):Int return ExtensionsNative.getFragDataIndexEXT(program, name);
    /**
    * - #### Purpose:
    * query the bindings of color numbers to user-defined varying out variables
    * ### Description:
    * **glGetFragDataLocation** retrieves the assigned color number binding for the user-defined varying out variable **name** for program **program**. **program** must have previously been linked. **name** must be a null-terminated string. If **name** is not the name of an active user-defined varying out fragment shader variable within **program**, -1 will be returned.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **program** is not the name of a program object.
    * 
    * @param program The name of the program containing varying out variable whose binding to query
    * @param name The name of the user-defined varying out variable whose binding to query

    * @see **`glCreateProgram`**, **`glBindFragDataLocation`**

    **/
    static function getFragDataLocation(program:Int, name:String):Int return ExtensionsNative.getFragDataLocation(program, name);
    static function getFragDataLocationEXT(program:Int, name:String):Int return ExtensionsNative.getFragDataLocationEXT(program, name);
    static function getFragmentLightfvSGIX(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFragmentLightfvSGIX(light, pname, params);
    static function getFragmentLightivSGIX(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFragmentLightivSGIX(light, pname, params);
    static function getFragmentMaterialfvSGIX(face:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFragmentMaterialfvSGIX(face, pname, params);
    static function getFragmentMaterialivSGIX(face:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFragmentMaterialivSGIX(face, pname, params);
    static function getFragmentShadingRatesEXT(samples:Int, maxCount:Int, count:DataPointer, shadin_gRates:DataPointer):Void return ExtensionsNative.getFragmentShadingRatesEXT(samples, maxCount, count, shadin_gRates);
    static function getFramebufferAttachmentParameteriv(target:Int, attachment:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFramebufferAttachmentParameteriv(target, attachment, pname, params);
    static function getFramebufferAttachmentParameterivEXT(target:Int, attachment:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFramebufferAttachmentParameterivEXT(target, attachment, pname, params);
    static function getFramebufferAttachmentParameterivOES(target:Int, attachment:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFramebufferAttachmentParameterivOES(target, attachment, pname, params);
    static function getFramebufferParameterfvAMD(target:Int, pname:Int, numsamples:Int, pixelin_dex:Int, size:Int, values:DataPointer):Void return ExtensionsNative.getFramebufferParameterfvAMD(target, pname, numsamples, pixelin_dex, size, values);
    static function getFramebufferParameteriv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFramebufferParameteriv(target, pname, params);
    static function getFramebufferParameterivEXT(framebuffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFramebufferParameterivEXT(framebuffer, pname, params);
    static function getFramebufferPixelLocalStorageSizeEXT(target:Int):Int return ExtensionsNative.getFramebufferPixelLocalStorageSizeEXT(target);
    /**
    * - #### Purpose:
    * check if the rendering context has not been lost due to software or hardware issues
    * ### Description:
    * Certain events can result in a reset of the GL context. Such a reset causes all context state to be lost and requires the application to recreate all objects in the affected context.
    * 
    * **glGetGraphicsResetStatus** can return one of the following constants:
    * 
    * *``GL_NO_ERROR``* Indicates that the GL context has not been in a reset state since the last call.
    * 
    * *``GL_GUILTY_CONTEXT_RESET``* Indicates that a reset has been detected that is attributable to the current GL context.
    * 
    * *``GL_INNOCENT_CONTEXT_RESET``* Indicates a reset has been detected that is not attributable to the current GL context.
    * 
    * *``GL_UNKNOWN_CONTEXT_RESET``* Indicates a detected graphics reset whose cause is unknown.
    * 
    * If a reset status other than `GL_NO_ERROR` is returned and subsequent calls return `GL_NO_ERROR`, the context reset was encountered and completed. If a reset status is repeatedly returned, the context may be in the process of resetting.
    * 
    * Reset notification behavior is determined at context creation time, and may be queried by calling **GetIntegerv** with the symbolic constant `GL_RESET_NOTIFICATION_STRATEGY`.
    * 
    * If the reset notification behavior is `GL_NO_RESET_NOTIFICATION`, then the implementation will never deliver notification of reset events, and **glGetGraphicsResetStatus** will always return `GL_NO_ERROR`.
    * 
    * If the behavior is `GL_LOSE_CONTEXT_ON_RESET`, a graphics reset will result in the loss of all context state, requiring the recreation of all associated objects. In this case **glGetGraphicsResetStatus** may return any of the values described above.
    * 
    * If a graphics reset notification occurs in a context, a notification must also occur in all other contexts which share objects with that context.
    * 
    * After a graphics reset has occurred on a context, subsequent GL commands on that context (or any context which shares with that context) will generate a `GL_CONTEXT_LOST` error. Such commands will not have side effects (in particular, they will not modify memory passed by pointer for query results), and will not block indefinitely or cause termination of the application. There are two important exceptions to this behavior:
    * 
    * **glGetError** and **glGetGraphicsResetStatus** behave normally following a graphics reset, so that the application can determine a reset has occurred, and when it is safe to destroy and re-create the context. Any commands which might cause a polling application to block indefinitely will generate a `GL_CONTEXT_LOST` error, but will also return a value indicating completion to the application. Such commands include: **glGetSynciv** with pname `GL_SYNC_STATUS` ignores the other parameters and returns `GL_SIGNALED` in **values**. **glGetQueryObjectuiv** with pname `GL_QUERY_RESULT_AVAILABLE` ignores the other parameters and returns `TRUE` in **params**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * * @see **`glGetError`** **glGetIntegerv**, **glGetQueryObjectuiv** **glGetSynciv**

    **/
    static function getGraphicsResetStatus():Int return ExtensionsNative.getGraphicsResetStatus();
    static function getGraphicsResetStatusARB():Int return ExtensionsNative.getGraphicsResetStatusARB();
    static function getGraphicsResetStatusEXT():Int return ExtensionsNative.getGraphicsResetStatusEXT();
    static function getGraphicsResetStatusKHR():Int return ExtensionsNative.getGraphicsResetStatusKHR();
    static function getHandleARB(pname:Int):Int return ExtensionsNative.getHandleARB(pname);
    static function getHistogram(target:Int, reset:Bool, format:Int, type:Int, values:DataPointer):Void return ExtensionsNative.getHistogram(target, reset, format, type, values);
    static function getHistogramEXT(target:Int, reset:Bool, format:Int, type:Int, values:DataPointer):Void return ExtensionsNative.getHistogramEXT(target, reset, format, type, values);
    static function getHistogramParameterfv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getHistogramParameterfv(target, pname, params);
    static function getHistogramParameterfvEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getHistogramParameterfvEXT(target, pname, params);
    static function getHistogramParameteriv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getHistogramParameteriv(target, pname, params);
    static function getHistogramParameterivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getHistogramParameterivEXT(target, pname, params);
    static function getHistogramParameterxvOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getHistogramParameterxvOES(target, pname, params);
    static function getImageHandleARB(texture:Int, level:Int, layered:Bool, layer:Int, format:Int):Int return ExtensionsNative.getImageHandleARB(texture, level, layered, layer, format);
    static function getImageHandleNV(texture:Int, level:Int, layered:Bool, layer:Int, format:Int):Int return ExtensionsNative.getImageHandleNV(texture, level, layered, layer, format);
    static function getImageTransformParameterfvHP(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getImageTransformParameterfvHP(target, pname, params);
    static function getImageTransformParameterivHP(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getImageTransformParameterivHP(target, pname, params);
    static function getInfoLogARB(obj:Int, maxLength:Int, length:DataPointer, in_foLog:Pointer<Char>):Void return ExtensionsNative.getInfoLogARB(obj, maxLength, length, in_foLog);
    static function getInstrumentsSGIX():Int return ExtensionsNative.getInstrumentsSGIX();
    static function getInteger64i_v(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getInteger64i_v(target, in_dex, data);
    static function getInteger64v(pname:Int, data:DataPointer):Void return ExtensionsNative.getInteger64v(pname, data);
    static function getInteger64vAPPLE(pname:Int, params:DataPointer):Void return ExtensionsNative.getInteger64vAPPLE(pname, params);
    static function getInteger64vEXT(pname:Int, data:DataPointer):Void return ExtensionsNative.getInteger64vEXT(pname, data);
    static function getIntegerIndexedvEXT(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getIntegerIndexedvEXT(target, in_dex, data);
    static function getIntegeri_v(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getIntegeri_v(target, in_dex, data);
    static function getIntegeri_vEXT(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getIntegeri_vEXT(target, in_dex, data);
    static function getIntegerui64i_vNV(value:Int, in_dex:Int, result:DataPointer):Void return ExtensionsNative.getIntegerui64i_vNV(value, in_dex, result);
    static function getIntegerui64vNV(value:Int, result:DataPointer):Void return ExtensionsNative.getIntegerui64vNV(value, result);
    static function getIntegerv(pname:Int, data:DataPointer):Void return ExtensionsNative.getIntegerv(pname, data);
    static function getInternalformatSampleivNV(target:Int, in_ternalformat:Int, samples:Int, pname:Int, count:Int, params:DataPointer):Void return ExtensionsNative.getInternalformatSampleivNV(target, in_ternalformat, samples, pname, count, params);
    static function getInternalformati64v(target:Int, in_ternalformat:Int, pname:Int, count:Int, params:DataPointer):Void return ExtensionsNative.getInternalformati64v(target, in_ternalformat, pname, count, params);
    static function getInternalformativ(target:Int, in_ternalformat:Int, pname:Int, count:Int, params:DataPointer):Void return ExtensionsNative.getInternalformativ(target, in_ternalformat, pname, count, params);
    static function getInvariantBooleanvEXT(id:Int, value:Int, data:DataPointer):Void return ExtensionsNative.getInvariantBooleanvEXT(id, value, data);
    static function getInvariantFloatvEXT(id:Int, value:Int, data:DataPointer):Void return ExtensionsNative.getInvariantFloatvEXT(id, value, data);
    static function getInvariantIntegervEXT(id:Int, value:Int, data:DataPointer):Void return ExtensionsNative.getInvariantIntegervEXT(id, value, data);
    static function getLightfv(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getLightfv(light, pname, params);
    static function getLightiv(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getLightiv(light, pname, params);
    static function getLightxOES(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getLightxOES(light, pname, params);
    static function getLightxv(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getLightxv(light, pname, params);
    static function getLightxvOES(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getLightxvOES(light, pname, params);
    static function getListParameterfvSGIX(list:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getListParameterfvSGIX(list, pname, params);
    static function getListParameterivSGIX(list:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getListParameterivSGIX(list, pname, params);
    static function getLocalConstantBooleanvEXT(id:Int, value:Int, data:DataPointer):Void return ExtensionsNative.getLocalConstantBooleanvEXT(id, value, data);
    static function getLocalConstantFloatvEXT(id:Int, value:Int, data:DataPointer):Void return ExtensionsNative.getLocalConstantFloatvEXT(id, value, data);
    static function getLocalConstantIntegervEXT(id:Int, value:Int, data:DataPointer):Void return ExtensionsNative.getLocalConstantIntegervEXT(id, value, data);
    static function getMapAttribParameterfvNV(target:Int, in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMapAttribParameterfvNV(target, in_dex, pname, params);
    static function getMapAttribParameterivNV(target:Int, in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMapAttribParameterivNV(target, in_dex, pname, params);
    static function getMapControlPointsNV(target:Int, in_dex:Int, type:Int, ustride:Int, vstride:Int, packed:Bool, poin_ts:DataPointer):Void return ExtensionsNative.getMapControlPointsNV(target, in_dex, type, ustride, vstride, packed, poin_ts);
    static function getMapParameterfvNV(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMapParameterfvNV(target, pname, params);
    static function getMapParameterivNV(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMapParameterivNV(target, pname, params);
    static function getMapdv(target:Int, query:Int, v:DataPointer):Void return ExtensionsNative.getMapdv(target, query, v);
    static function getMapfv(target:Int, query:Int, v:DataPointer):Void return ExtensionsNative.getMapfv(target, query, v);
    static function getMapiv(target:Int, query:Int, v:DataPointer):Void return ExtensionsNative.getMapiv(target, query, v);
    static function getMapxvOES(target:Int, query:Int, v:DataPointer):Void return ExtensionsNative.getMapxvOES(target, query, v);
    static function getMaterialfv(face:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMaterialfv(face, pname, params);
    static function getMaterialiv(face:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMaterialiv(face, pname, params);
    static function getMaterialxOES(face:Int, pname:Int, param:Int):Void return ExtensionsNative.getMaterialxOES(face, pname, param);
    static function getMaterialxv(face:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMaterialxv(face, pname, params);
    static function getMaterialxvOES(face:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMaterialxvOES(face, pname, params);
    static function getMemoryObjectDetachedResourcesuivNV(memory:Int, pname:Int, first:Int, count:Int, params:DataPointer):Void return ExtensionsNative.getMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, params);
    static function getMemoryObjectParameterivEXT(memoryObject:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMemoryObjectParameterivEXT(memoryObject, pname, params);
    static function getMinmax(target:Int, reset:Bool, format:Int, type:Int, values:DataPointer):Void return ExtensionsNative.getMinmax(target, reset, format, type, values);
    static function getMinmaxEXT(target:Int, reset:Bool, format:Int, type:Int, values:DataPointer):Void return ExtensionsNative.getMinmaxEXT(target, reset, format, type, values);
    static function getMinmaxParameterfv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMinmaxParameterfv(target, pname, params);
    static function getMinmaxParameterfvEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMinmaxParameterfvEXT(target, pname, params);
    static function getMinmaxParameteriv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMinmaxParameteriv(target, pname, params);
    static function getMinmaxParameterivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMinmaxParameterivEXT(target, pname, params);
    static function getMultiTexEnvfvEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMultiTexEnvfvEXT(texunit, target, pname, params);
    static function getMultiTexEnvivEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMultiTexEnvivEXT(texunit, target, pname, params);
    static function getMultiTexGendvEXT(texunit:Int, coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMultiTexGendvEXT(texunit, coord, pname, params);
    static function getMultiTexGenfvEXT(texunit:Int, coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMultiTexGenfvEXT(texunit, coord, pname, params);
    static function getMultiTexGenivEXT(texunit:Int, coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMultiTexGenivEXT(texunit, coord, pname, params);
    static function getMultiTexImageEXT(texunit:Int, target:Int, level:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.getMultiTexImageEXT(texunit, target, level, format, type, pixels);
    static function getMultiTexLevelParameterfvEXT(texunit:Int, target:Int, level:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMultiTexLevelParameterfvEXT(texunit, target, level, pname, params);
    static function getMultiTexLevelParameterivEXT(texunit:Int, target:Int, level:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMultiTexLevelParameterivEXT(texunit, target, level, pname, params);
    static function getMultiTexParameterIivEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMultiTexParameterIivEXT(texunit, target, pname, params);
    static function getMultiTexParameterIuivEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMultiTexParameterIuivEXT(texunit, target, pname, params);
    static function getMultiTexParameterfvEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMultiTexParameterfvEXT(texunit, target, pname, params);
    static function getMultiTexParameterivEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getMultiTexParameterivEXT(texunit, target, pname, params);
    static function getMultisamplefv(pname:Int, in_dex:Int, val:DataPointer):Void return ExtensionsNative.getMultisamplefv(pname, in_dex, val);
    static function getMultisamplefvNV(pname:Int, in_dex:Int, val:DataPointer):Void return ExtensionsNative.getMultisamplefvNV(pname, in_dex, val);
    static function getNamedBufferParameteri64v(buffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedBufferParameteri64v(buffer, pname, params);
    static function getNamedBufferParameteriv(buffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedBufferParameteriv(buffer, pname, params);
    static function getNamedBufferParameterivEXT(buffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedBufferParameterivEXT(buffer, pname, params);
    static function getNamedBufferParameterui64vNV(buffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedBufferParameterui64vNV(buffer, pname, params);
    static function getNamedBufferPointerv(buffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedBufferPointerv(buffer, pname, params);
    static function getNamedBufferPointervEXT(buffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedBufferPointervEXT(buffer, pname, params);
    static function getNamedBufferSubData(buffer:Int, offset:Int, size:Int, data:DataPointer):Void return ExtensionsNative.getNamedBufferSubData(buffer, offset, size, data);
    static function getNamedBufferSubDataEXT(buffer:Int, offset:Int, size:Int, data:DataPointer):Void return ExtensionsNative.getNamedBufferSubDataEXT(buffer, offset, size, data);
    static function getNamedFramebufferParameterfvAMD(framebuffer:Int, pname:Int, numsamples:Int, pixelin_dex:Int, size:Int, values:DataPointer):Void return ExtensionsNative.getNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelin_dex, size, values);
    static function getNamedFramebufferAttachmentParameteriv(framebuffer:Int, attachment:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, params);
    static function getNamedFramebufferAttachmentParameterivEXT(framebuffer:Int, attachment:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, params);
    static function getNamedFramebufferParameteriv(framebuffer:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.getNamedFramebufferParameteriv(framebuffer, pname, param);
    static function getNamedFramebufferParameterivEXT(framebuffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedFramebufferParameterivEXT(framebuffer, pname, params);
    static function getNamedProgramLocalParameterIivEXT(program:Int, target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getNamedProgramLocalParameterIivEXT(program, target, in_dex, params);
    static function getNamedProgramLocalParameterIuivEXT(program:Int, target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getNamedProgramLocalParameterIuivEXT(program, target, in_dex, params);
    static function getNamedProgramLocalParameterdvEXT(program:Int, target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getNamedProgramLocalParameterdvEXT(program, target, in_dex, params);
    static function getNamedProgramLocalParameterfvEXT(program:Int, target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getNamedProgramLocalParameterfvEXT(program, target, in_dex, params);
    static function getNamedProgramStringEXT(program:Int, target:Int, pname:Int, strin_g:DataPointer):Void return ExtensionsNative.getNamedProgramStringEXT(program, target, pname, strin_g);
    static function getNamedProgramivEXT(program:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedProgramivEXT(program, target, pname, params);
    static function getNamedRenderbufferParameteriv(renderbuffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedRenderbufferParameteriv(renderbuffer, pname, params);
    static function getNamedRenderbufferParameterivEXT(renderbuffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedRenderbufferParameterivEXT(renderbuffer, pname, params);
    static function getNamedStringARB(namelen:Int, name:String, bufSize:Int, strin_glen:DataPointer, strin_g:Pointer<Char>):Void return ExtensionsNative.getNamedStringARB(namelen, name, bufSize, strin_glen, strin_g);
    static function getNamedStringivARB(namelen:Int, name:String, pname:Int, params:DataPointer):Void return ExtensionsNative.getNamedStringivARB(namelen, name, pname, params);
    static function getNextPerfQueryIdINTEL(queryId:Int, nextQueryId:DataPointer):Void return ExtensionsNative.getNextPerfQueryIdINTEL(queryId, nextQueryId);
    static function getObjectBufferfvATI(buffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getObjectBufferfvATI(buffer, pname, params);
    static function getObjectBufferivATI(buffer:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getObjectBufferivATI(buffer, pname, params);
    /**
    * - #### Purpose:
    * retrieve the label of a named object identified within a namespace
    * ### Description:
    * **glGetObjectLabel** retrieves the label of the object identified by **name** within the namespace given by **identifier**. **identifier** must be one of `GL_BUFFER`, `GL_SHADER`, `GL_PROGRAM`, `GL_VERTEX_ARRAY`, `GL_QUERY`, `GL_PROGRAM_PIPELINE`, `GL_TRANSFORM_FEEDBACK`, `GL_SAMPLER`, `GL_TEXTURE`, `GL_RENDERBUFFER`, `GL_FRAMEBUFFER`, to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame buffers, respectively.
    * 
    * **label** is the address of a string that will be used to store the object label. **bufSize** specifies the number of characters in the array identified by **label**. **length** contains the address of a variable which will receive the number of characters in the object label. If **length** is NULL, then it is ignored and no data is written. Likewise, if **label** is NULL, or if **bufSize** is zero then no data is written to **label**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **identifier** is not one of the accepted object types.
    * 
    * `GL_INVALID_OPERATION` is generated if **name** is not the name of an existing object of the type specified by **identifier**.
    * 
    * `GL_INVALID_VALUE` is generated if **bufSize** is zero.
    * 
    * If not NULL, **length** and **label** should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur.
    * 
    * @param identifier The namespace from which the name of the object is allocated.
    * @param name The name of the object whose label to retrieve.
    * @param bufSize The length of the buffer whose address is in **label**.
    * @param length The address of a variable to receive the length of the object label.
    * @param label The address of a string that will receive the object label.

    * @see **`glPushDebugGroup`**, **`glPopDebugGroup`**, **`glObjectLabel`**, **`glGetObjectPtrLabel`**.

    **/
    static function getObjectLabel(identifier:Int, name:Int, bufSize:Int, length:DataPointer, label:Pointer<Char>):Void return ExtensionsNative.getObjectLabel(identifier, name, bufSize, length, label);
    static function getObjectLabelEXT(type:Int, object:Int, bufSize:Int, length:DataPointer, label:Pointer<Char>):Void return ExtensionsNative.getObjectLabelEXT(type, object, bufSize, length, label);
    static function getObjectLabelKHR(identifier:Int, name:Int, bufSize:Int, length:DataPointer, label:Pointer<Char>):Void return ExtensionsNative.getObjectLabelKHR(identifier, name, bufSize, length, label);
    static function getObjectParameterfvARB(obj:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getObjectParameterfvARB(obj, pname, params);
    static function getObjectParameterivAPPLE(objectType:Int, name:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getObjectParameterivAPPLE(objectType, name, pname, params);
    static function getObjectParameterivARB(obj:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getObjectParameterivARB(obj, pname, params);
    /**
    * - #### Purpose:
    * retrieve the label of a sync object identified by a pointer
    * ### Description:
    * **glGetObjectPtrLabel** retrieves the label of the sync object identified by **ptr**.
    * 
    * **label** is the address of a string that will be used to store the object label. **bufSize** specifies the number of characters in the array identified by **label**. **length** contains the address of a variable which will receive the number of characters in the object label. If **length** is NULL, then it is ignored and no data is written. Likewise, if **label** is NULL, or if **bufSize** is zero then no data is written to **label**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **identifier** is not one of the accepted object types.
    * 
    * `GL_INVALID_VALUE` is generated if **ptr** is not the name of an existing sync object.
    * 
    * `GL_INVALID_VALUE` is generated if **bufSize** is zero.
    * 
    * If not NULL, **length** and **label** should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur.
    * 
    * @param ptr The name of the sync object whose label to retrieve.
    * @param bufSize The length of the buffer whose address is in **label**.
    * @param length The address of a variable to receive the length of the object label.
    * @param label The address of a string that will receive the object label.

    * @see **`glPushDebugGroup`**, **`glPopDebugGroup`**, **`glObjectLabel`**, **`glGetObjectLabel`**.

    **/
    static function getObjectPtrLabel(ptr:DataPointer, bufSize:Int, length:DataPointer, label:Pointer<Char>):Void return ExtensionsNative.getObjectPtrLabel(ptr, bufSize, length, label);
    static function getObjectPtrLabelKHR(ptr:DataPointer, bufSize:Int, length:DataPointer, label:Pointer<Char>):Void return ExtensionsNative.getObjectPtrLabelKHR(ptr, bufSize, length, label);
    static function getOcclusionQueryivNV(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getOcclusionQueryivNV(id, pname, params);
    static function getOcclusionQueryuivNV(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getOcclusionQueryuivNV(id, pname, params);
    static function getPathColorGenfvNV(color:Int, pname:Int, value:DataPointer):Void return ExtensionsNative.getPathColorGenfvNV(color, pname, value);
    static function getPathColorGenivNV(color:Int, pname:Int, value:DataPointer):Void return ExtensionsNative.getPathColorGenivNV(color, pname, value);
    static function getPathCommandsNV(path:Int, commands:DataPointer):Void return ExtensionsNative.getPathCommandsNV(path, commands);
    static function getPathCoordsNV(path:Int, coords:DataPointer):Void return ExtensionsNative.getPathCoordsNV(path, coords);
    static function getPathDashArrayNV(path:Int, dashArray:DataPointer):Void return ExtensionsNative.getPathDashArrayNV(path, dashArray);
    static function getPathLengthNV(path:Int, startSegment:Int, numSegments:Int):Float return ExtensionsNative.getPathLengthNV(path, startSegment, numSegments);
    static function getPathMetricRangeNV(metricQueryMask:Int, firstPathName:Int, numPaths:Int, stride:Int, metrics:DataPointer):Void return ExtensionsNative.getPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);
    static function getPathMetricsNV(metricQueryMask:Int, numPaths:Int, pathNameType:Int, paths:DataPointer, pathBase:Int, stride:Int, metrics:DataPointer):Void return ExtensionsNative.getPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    static function getPathParameterfvNV(path:Int, pname:Int, value:DataPointer):Void return ExtensionsNative.getPathParameterfvNV(path, pname, value);
    static function getPathParameterivNV(path:Int, pname:Int, value:DataPointer):Void return ExtensionsNative.getPathParameterivNV(path, pname, value);
    static function getPathSpacingNV(pathListMode:Int, numPaths:Int, pathNameType:Int, paths:DataPointer, pathBase:Int, advanceScale:Float, kernin_gScale:Float, transformType:Int, returnedSpacin_g:DataPointer):Void return ExtensionsNative.getPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kernin_gScale, transformType, returnedSpacin_g);
    static function getPathTexGenfvNV(texCoordSet:Int, pname:Int, value:DataPointer):Void return ExtensionsNative.getPathTexGenfvNV(texCoordSet, pname, value);
    static function getPathTexGenivNV(texCoordSet:Int, pname:Int, value:DataPointer):Void return ExtensionsNative.getPathTexGenivNV(texCoordSet, pname, value);
    static function getPerfCounterInfoINTEL(queryId:Int, counterId:Int, counterNameLength:Int, counterName:Pointer<Char>, counterDescLength:Int, counterDesc:Pointer<Char>, counterOffset:DataPointer, counterDataSize:DataPointer, counterTypeEnum:DataPointer, counterDataTypeEnum:DataPointer, rawCounterMaxValue:DataPointer):Void return ExtensionsNative.getPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    static function getPerfMonitorCounterDataAMD(monitor:Int, pname:Int, dataSize:Int, data:DataPointer, bytesWritten:DataPointer):Void return ExtensionsNative.getPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
    static function getPerfMonitorCounterInfoAMD(group:Int, counter:Int, pname:Int, data:DataPointer):Void return ExtensionsNative.getPerfMonitorCounterInfoAMD(group, counter, pname, data);
    static function getPerfMonitorCounterStringAMD(group:Int, counter:Int, bufSize:Int, length:DataPointer, counterStrin_g:Pointer<Char>):Void return ExtensionsNative.getPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterStrin_g);
    static function getPerfMonitorCountersAMD(group:Int, numCounters:DataPointer, maxActiveCounters:DataPointer, counterSize:Int, counters:DataPointer):Void return ExtensionsNative.getPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
    static function getPerfMonitorGroupStringAMD(group:Int, bufSize:Int, length:DataPointer, groupStrin_g:Pointer<Char>):Void return ExtensionsNative.getPerfMonitorGroupStringAMD(group, bufSize, length, groupStrin_g);
    static function getPerfMonitorGroupsAMD(numGroups:DataPointer, groupsSize:Int, groups:DataPointer):Void return ExtensionsNative.getPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
    static function getPerfQueryDataINTEL(queryHandle:Int, flags:Int, dataSize:Int, data:DataPointer, bytesWritten:DataPointer):Void return ExtensionsNative.getPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);
    static function getPerfQueryIdByNameINTEL(queryName:Pointer<Char>, queryId:DataPointer):Void return ExtensionsNative.getPerfQueryIdByNameINTEL(queryName, queryId);
    static function getPerfQueryInfoINTEL(queryId:Int, queryNameLength:Int, queryName:Pointer<Char>, dataSize:DataPointer, noCounters:DataPointer, noInstances:DataPointer, capsMask:DataPointer):Void return ExtensionsNative.getPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
    static function getPixelMapfv(map:Int, values:DataPointer):Void return ExtensionsNative.getPixelMapfv(map, values);
    static function getPixelMapuiv(map:Int, values:DataPointer):Void return ExtensionsNative.getPixelMapuiv(map, values);
    static function getPixelMapusv(map:Int, values:DataPointer):Void return ExtensionsNative.getPixelMapusv(map, values);
    static function getPixelMapxv(map:Int, size:Int, values:DataPointer):Void return ExtensionsNative.getPixelMapxv(map, size, values);
    static function getPixelTexGenParameterfvSGIS(pname:Int, params:DataPointer):Void return ExtensionsNative.getPixelTexGenParameterfvSGIS(pname, params);
    static function getPixelTexGenParameterivSGIS(pname:Int, params:DataPointer):Void return ExtensionsNative.getPixelTexGenParameterivSGIS(pname, params);
    static function getPixelTransformParameterfvEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getPixelTransformParameterfvEXT(target, pname, params);
    static function getPixelTransformParameterivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getPixelTransformParameterivEXT(target, pname, params);
    static function getPointerIndexedvEXT(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getPointerIndexedvEXT(target, in_dex, data);
    static function getPointeri_vEXT(pname:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getPointeri_vEXT(pname, in_dex, params);
    /**
    * - #### Purpose:
    * return the address of the specified pointer
    * ### Description:
    * **glGetPointerv** returns pointer information. **pname** indicates the pointer to be returned, and **params** is a pointer to a location in which to place the returned data. The parameters that may be queried include:
    * 
    * *``GL_DEBUG_CALLBACK_FUNCTION``* Returns the current callback function set with the **callback** argument of **`glDebugMessageCallback`**.
    * 
    * *``GL_DEBUG_CALLBACK_USER_PARAM``* Returns the user parameter to the current callback function set with the **userParam** argument of **`glDebugMessageCallback`**.
    * 
    * 
    * ### Notes:
    * **glGetPointerv** is available in the OpenGL core profile only if the GL version is 4.3 or later. It is available in the compatibility profile for all GL versions, and accepts additional queries. However, these reference pages document only the core profile.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **pname** is not an accepted value.
    * 
    * @param pname Specifies the pointer to be returned. Must be one of `GL_DEBUG_CALLBACK_FUNCTION` or `GL_DEBUG_CALLBACK_USER_PARAM`.
    * @param params Returns the pointer value specified by **pname**.

    * @see **`glDebugMessageCallback`**

    **/
    static function getPointerv(pname:Int, params:DataPointer):Void return ExtensionsNative.getPointerv(pname, params);
    static function getPointervEXT(pname:Int, params:DataPointer):Void return ExtensionsNative.getPointervEXT(pname, params);
    static function getPointervKHR(pname:Int, params:DataPointer):Void return ExtensionsNative.getPointervKHR(pname, params);
    static function getPolygonStipple(mask:DataPointer):Void return ExtensionsNative.getPolygonStipple(mask);
    /**
    * - #### Purpose:
    * return a binary representation of a program object's compiled and linked executable source
    * ### Description:
    * **glGetProgramBinary** returns a binary representation of the compiled and linked executable for **program** into the array of bytes whose address is specified in **binary**. The maximum number of bytes that may be written into **binary** is specified by **bufSize**. If the program binary is greater in size than **bufSize** bytes, then an error is generated, otherwise the actual number of bytes written into **binary** is returned in the variable whose address is given by **length**. If **length** is `NULL`, then no length is returned.
    * 
    * The format of the program binary written into **binary** is returned in the variable whose address is given by **binaryFormat**, and may be implementation dependent. The binary produced by the GL may subsequently be returned to the GL by calling **`glProgramBinary`**, with **binaryFormat** and **length** set to the values returned by **glGetProgramBinary**, and passing the returned binary data in the **binary** parameter.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **bufSize** is less than the size of `GL_PROGRAM_BINARY_LENGTH` for **program**.
    * 
    * `GL_INVALID_OPERATION` is generated if `GL_LINK_STATUS` for the program object is false.
    * 
    * @param program Specifies the name of a program object whose binary representation to retrieve.
    * @param bufSize Specifies the size of the buffer whose address is given by **binary**.
    * @param length Specifies the address of a variable to receive the number of bytes written into **binary**.
    * @param binaryFormat Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
    * @param binary Specifies the address an array into which the GL will return **program**'s binary representation.

    * @see **`glGetProgram`**, **`glProgramBinary`**

    **/
    static function getProgramBinary(program:Int, bufSize:Int, length:DataPointer, bin_aryFormat:DataPointer, bin_ary:DataPointer):Void return ExtensionsNative.getProgramBinary(program, bufSize, length, bin_aryFormat, bin_ary);
    static function getProgramBinaryOES(program:Int, bufSize:Int, length:DataPointer, bin_aryFormat:DataPointer, bin_ary:DataPointer):Void return ExtensionsNative.getProgramBinaryOES(program, bufSize, length, bin_aryFormat, bin_ary);
    static function getProgramEnvParameterIivNV(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getProgramEnvParameterIivNV(target, in_dex, params);
    static function getProgramEnvParameterIuivNV(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getProgramEnvParameterIuivNV(target, in_dex, params);
    static function getProgramEnvParameterdvARB(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getProgramEnvParameterdvARB(target, in_dex, params);
    static function getProgramEnvParameterfvARB(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getProgramEnvParameterfvARB(target, in_dex, params);
    /**
    * - #### Purpose:
    * Returns the information log for a program object
    * ### Description:
    * **glGetProgramInfoLog** returns the information log for the specified program object. The information log for a program object is modified when the program object is linked or validated. The string that is returned will be null terminated.
    * 
    * **glGetProgramInfoLog** returns in **infoLog** as much of the information log as it can, up to a maximum of **maxLength** characters. The number of characters actually returned, excluding the null termination character, is specified by **length**. If the length of the returned string is not required, a value of `NULL` can be passed in the **length** argument. The size of the buffer required to store the returned information log can be obtained by calling **`glGetProgram`** with the value `GL_INFO_LOG_LENGTH`.
    * 
    * The information log for a program object is either an empty string, or a string containing information about the last link operation, or a string containing information about the last validation operation. It may contain diagnostic messages, warning messages, and other information. When a program object is created, its information log will be a string of length 0.
    * 
    * 
    * ### Notes:
    * The information log for a program object is the OpenGL implementer's primary mechanism for conveying information about linking and validating. Therefore, the information log can be helpful to application developers during the development process, even when these operations are successful. Application developers should not expect different OpenGL implementations to produce identical information logs.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * `GL_INVALID_VALUE` is generated if **maxLength** is less than 0.
    * 
    * @param program Specifies the program object whose information log is to be queried.
    * @param maxLength Specifies the size of the character buffer for storing the returned information log.
    * @param length Returns the length of the string returned in **infoLog** (excluding the null terminator).
    * @param infoLog Specifies an array of characters that is used to return the information log.

    * @see **`glCompileShader`**, **`glGetShaderInfoLog`**, **`glLinkProgram`**, **`glValidateProgram`**

    **/
    static function getProgramInfoLog(program:Int, bufSize:Int, length:DataPointer, in_foLog:Pointer<Char>):Void return ExtensionsNative.getProgramInfoLog(program, bufSize, length, in_foLog);
    static function getProgramInterfaceiv(program:Int, programInterface:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getProgramInterfaceiv(program, programInterface, pname, params);
    static function getProgramLocalParameterIivNV(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getProgramLocalParameterIivNV(target, in_dex, params);
    static function getProgramLocalParameterIuivNV(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getProgramLocalParameterIuivNV(target, in_dex, params);
    static function getProgramLocalParameterdvARB(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getProgramLocalParameterdvARB(target, in_dex, params);
    static function getProgramLocalParameterfvARB(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.getProgramLocalParameterfvARB(target, in_dex, params);
    static function getProgramNamedParameterdvNV(id:Int, len:Int, name:DataPointer, params:DataPointer):Void return ExtensionsNative.getProgramNamedParameterdvNV(id, len, name, params);
    static function getProgramNamedParameterfvNV(id:Int, len:Int, name:DataPointer, params:DataPointer):Void return ExtensionsNative.getProgramNamedParameterfvNV(id, len, name, params);
    static function getProgramParameterdvNV(target:Int, in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getProgramParameterdvNV(target, in_dex, pname, params);
    static function getProgramParameterfvNV(target:Int, in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getProgramParameterfvNV(target, in_dex, pname, params);
    /**
    * - #### Purpose:
    * retrieve the info log string from a program pipeline object
    * ### Description:
    * **glGetProgramPipelineInfoLog** retrieves the info log for the program pipeline object **pipeline**. The info log, including its null terminator, is written into the array of characters whose address is given by **infoLog**. The maximum number of characters that may be written into **infoLog** is given by **bufSize**, and the actual number of characters written into **infoLog** is returned in the integer whose address is given by **length**. If **length** is `NULL`, no length is returned.
    * 
    * The actual length of the info log for the program pipeline may be determined by calling **`glGetProgramPipeline`** with **pname** set to `GL_INFO_LOG_LENGTH`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **pipeline** is not a name previously returned from a call to **`glGenProgramPipelines`** or if such a name has been deleted by a call to **`glDeleteProgramPipelines`**.
    * 
    * @param pipeline Specifies the name of a program pipeline object from which to retrieve the info log.
    * @param bufSize Specifies the maximum number of characters, including the null terminator, that may be written into **infoLog**.
    * @param length Specifies the address of a variable into which will be written the number of characters written into **infoLog**.
    * @param infoLog Specifies the address of an array of characters into which will be written the info log for **pipeline**.

    * @see **`glGenProgramPipelines`**, **`glBindProgramPipeline`**, **`glDeleteProgramPipelines`**, **`glGetProgramPipeline`**

    **/
    static function getProgramPipelineInfoLog(pipelin_e:Int, bufSize:Int, length:DataPointer, in_foLog:Pointer<Char>):Void return ExtensionsNative.getProgramPipelineInfoLog(pipelin_e, bufSize, length, in_foLog);
    static function getProgramPipelineInfoLogEXT(pipelin_e:Int, bufSize:Int, length:DataPointer, in_foLog:Pointer<Char>):Void return ExtensionsNative.getProgramPipelineInfoLogEXT(pipelin_e, bufSize, length, in_foLog);
    static function getProgramPipelineiv(pipelin_e:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getProgramPipelineiv(pipelin_e, pname, params);
    static function getProgramPipelineivEXT(pipelin_e:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getProgramPipelineivEXT(pipelin_e, pname, params);
    /**
    * - #### Purpose:
    * query the index of a named resource within a program
    * ### Description:
    * **glGetProgramResourceIndex** returns the unsigned integer index assigned to a resource named **name** in the interface type **programInterface** of program object **program**.
    * 
    * **program** must be the name of an existing program object. **programInterface** is the name of the interface within **program** which contains the resource named **name**and must be one of the following values:
    * 
    * *``GL_UNIFORM``* The query is targeted at the set of active uniforms within **program**.
    * 
    * *``GL_UNIFORM_BLOCK``* The query is targeted at the set of active uniform blocks within **program**.
    * 
    * *``GL_PROGRAM_INPUT``* The query is targeted at the set of active input variables used by the first shader stage of **program**. If **program** contains multiple shader stages then input variables from any stage other than the first will not be enumerated.
    * 
    * *``GL_PROGRAM_OUTPUT``* The query is targeted at the set of active output variables produced by the last shader stage of **program**. If **program** contains multiple shader stages then output variables from any stage other than the last will not be enumerated.
    * 
    * *``GL_VERTEX_SUBROUTINE``* *``GL_TESS_CONTROL_SUBROUTINE``* *``GL_TESS_EVALUATION_SUBROUTINE``* *``GL_GEOMETRY_SUBROUTINE``* *``GL_FRAGMENT_SUBROUTINE``* *``GL_COMPUTE_SUBROUTINE``* The query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of **program**, respectively.
    * 
    * *``GL_VERTEX_SUBROUTINE_UNIFORM``* *``GL_TESS_CONTROL_SUBROUTINE_UNIFORM``* *``GL_TESS_EVALUATION_SUBROUTINE_UNIFORM``* *``GL_GEOMETRY_SUBROUTINE_UNIFORM``* *``GL_FRAGMENT_SUBROUTINE_UNIFORM``* *``GL_COMPUTE_SUBROUTINE_UNIFORM``* The query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of **program**, respectively.
    * 
    * *``GL_TRANSFORM_FEEDBACK_VARYING``* The query is targeted at the set of output variables from the last non-fragment stage of **program** that would be captured if transform feedback were active.
    * 
    * *``GL_TRANSFORM_FEEDBACK_BUFFER``* The query is targeted at the set of active buffer binding points to which output variables in the `GL_TRANSFORM_FEEDBACK_VARYING` interface are written.
    * 
    * *``GL_BUFFER_VARIABLE``* The query is targeted at the set of active buffer variables used by **program**.
    * 
    * *``GL_SHADER_STORAGE_BLOCK``* The query is targeted at the set of active shader storage blocks used by **program**.
    * 
    * If **name** exactly matches the name string of one of the active resources for **programInterface**, the index of the matched resource is returned. Additionally, if **name** would exactly match the name string of an active resource if "[0]" were appended to **name**, the index of the matched resource is returned. Otherwise, **name** is considered not to be the name of an active resource, and `GL_INVALID_INDEX` is returned.
    * 
    * For the interface `GL_TRANSFORM_FEEDBACK_VARYING`, the value `GL_INVALID_INDEX` should be returned when querying the index assigned to the special names gl_NextBuffer, gl_SkipComponents1, gl_SkipComponents2, gl_SkipComponents3, or gl_SkipComponents4.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **programInterface** is not one of the accepted interface types.
    * 
    * `GL_INVALID_ENUM` is generated if **programInterface** is `GL_ATOMIC_COUNTER_BUFFER` or `GL_TRANSFORM_FEEDBACK_BUFFER`, since active atomic counter and transform feedback buffer resources are not assigned name strings.
    * 
    * Although not an error, `GL_INVALID_INDEX` is returned if **name** is not the name of a resource within the interface identified by **programInterface**.
    * 
    * @param program The name of a program object whose resources to query.
    * @param programInterface A token identifying the interface within **program** containing the resource named **name**.
    * @param name The name of the resource to query the index of.

    * @see **`glGetProgramResourceName`**, **`glGetProgramResource`**, **`glGetProgramResourceLocation`**, **`glGetProgramResourceLocationIndex`**.

    **/
    static function getProgramResourceIndex(program:Int, programInterface:Int, name:String):Int return ExtensionsNative.getProgramResourceIndex(program, programInterface, name);
    /**
    * - #### Purpose:
    * query the location of a named resource within a program
    * ### Description:
    * **glGetProgramResourceLocation** returns the location assigned to the variable named **name** in interface **programInterface** of program object **program**. **program** must be the name of a program that has been linked successfully. **programInterface** must be one of `GL_UNIFORM`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`, `GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`, or `GL_TRANSFORM_FEEDBACK_BUFFER`.
    * 
    * The value -1 will be returned if an error occurs, if **name** does not identify an active variable on **programInterface**, or if **name** identifies an active variable that does not have a valid location assigned, as described above. The locations returned by these commands are the same locations returned when querying the `GL_LOCATION` and `GL_LOCATION_INDEX` resource properties.
    * 
    * A string provided to **glGetProgramResourceLocation** is considered to match an active variable if:
    * 
    * Any other string is considered not to identify an active variable. If the string specifies an element of an array variable, **glGetProgramResourceLocation** returns the location assigned to that element. If it specifies the base name of an array, it identifies the resources associated with the first element of the array.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not the name of an existing program object.
    * 
    * `GL_INVALID_ENUM` is generated if **programInterface** is not one of the accepted interface types.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** has not been linked successfully.
    * 
    * @param program The name of a program object whose resources to query.
    * @param programInterface A token identifying the interface within **program** containing the resource named **name**.
    * @param name The name of the resource to query the location of.

    * @see **`glGetProgramResourceName`**, **`glGetProgramResourceIndex`**, **`glGetProgramResource`**, **`glGetProgramResourceLocationIndex`**.

    **/
    static function getProgramResourceLocation(program:Int, programInterface:Int, name:String):Int return ExtensionsNative.getProgramResourceLocation(program, programInterface, name);
    /**
    * - #### Purpose:
    * query the fragment color index of a named variable within a program
    * ### Description:
    * **glGetProgramResourceLocationIndex** returns the fragment color index assigned to the variable named **name** in interface **programInterface** of program object **program**. **program** must be the name of a program that has been linked successfully. **programInterface** must be `GL_PROGRAM_OUTPUT`.
    * 
    * The value -1 will be returned if an error occurs, if **name** does not identify an active variable on **programInterface**, or if **name** identifies an active variable that does not have a valid location assigned, as described above. The locations returned by these commands are the same locations returned when querying the `GL_LOCATION` and `GL_LOCATION_INDEX` resource properties.
    * 
    * A string provided to **glGetProgramResourceLocationIndex** is considered to match an active variable if:
    * 
    * Any other string is considered not to identify an active variable. If the string specifies an element of an array variable, **glGetProgramResourceLocation** returns the location assigned to that element. If it specifies the base name of an array, it identifies the resources associated with the first element of the array.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not the name of an existing program object.
    * 
    * `GL_INVALID_ENUM` is generated if **programInterface** is not one of the accepted interface types.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** has not been linked successfully.
    * 
    * @param program The name of a program object whose resources to query.
    * @param programInterface A token identifying the interface within **program** containing the resource named **name**.
    * @param name The name of the resource to query the location of.

    * @see **`glGetProgramResourceName`**, **`glGetProgramResourceIndex`**, **`glGetProgramResource`**, **`glGetProgramResourceLocationIndex`**.

    **/
    static function getProgramResourceLocationIndex(program:Int, programInterface:Int, name:String):Int return ExtensionsNative.getProgramResourceLocationIndex(program, programInterface, name);
    static function getProgramResourceLocationIndexEXT(program:Int, programInterface:Int, name:String):Int return ExtensionsNative.getProgramResourceLocationIndexEXT(program, programInterface, name);
    /**
    * - #### Purpose:
    * query the name of an indexed resource within a program
    * ### Description:
    * **glGetProgramResourceName** retrieves the name string assigned to the single active resource with an index of **index** in the interface **programInterface** of program object **program**. **index** must be less than the number of entries in the active resource list for **programInterface**.
    * 
    * **program** must be the name of an existing program object. **programInterface** is the name of the interface within **program** which contains the resource and must be one of the following values:
    * 
    * *``GL_UNIFORM``* The query is targeted at the set of active uniforms within **program**.
    * 
    * *``GL_UNIFORM_BLOCK``* The query is targeted at the set of active uniform blocks within **program**.
    * 
    * *``GL_PROGRAM_INPUT``* The query is targeted at the set of active input variables used by the first shader stage of **program**. If **program** contains multiple shader stages then input variables from any stage other than the first will not be enumerated.
    * 
    * *``GL_PROGRAM_OUTPUT``* The query is targeted at the set of active output variables produced by the last shader stage of **program**. If **program** contains multiple shader stages then output variables from any stage other than the last will not be enumerated.
    * 
    * *``GL_VERTEX_SUBROUTINE``* *``GL_TESS_CONTROL_SUBROUTINE``* *``GL_TESS_EVALUATION_SUBROUTINE``* *``GL_GEOMETRY_SUBROUTINE``* *``GL_FRAGMENT_SUBROUTINE``* *``GL_COMPUTE_SUBROUTINE``* The query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of **program**, respectively.
    * 
    * *``GL_VERTEX_SUBROUTINE_UNIFORM``* *``GL_TESS_CONTROL_SUBROUTINE_UNIFORM``* *``GL_TESS_EVALUATION_SUBROUTINE_UNIFORM``* *``GL_GEOMETRY_SUBROUTINE_UNIFORM``* *``GL_FRAGMENT_SUBROUTINE_UNIFORM``* *``GL_COMPUTE_SUBROUTINE_UNIFORM``* The query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of **program**, respectively.
    * 
    * *``GL_TRANSFORM_FEEDBACK_VARYING``* The query is targeted at the set of output variables from the last non-fragment stage of **program** that would be captured if transform feedback were active.
    * 
    * *``GL_BUFFER_VARIABLE``* The query is targeted at the set of active buffer variables used by **program**.
    * 
    * *``GL_SHADER_STORAGE_BLOCK``* The query is targeted at the set of active shader storage blocks used by **program**.
    * 
    * The name string assigned to the active resource identified by **index** is returned as a null-terminated string in the character array whose address is given in **name**. The actual number of characters written into **name**, excluding the null terminator, is returned in **length**. If **length** is NULL, no length is returned. The maximum number of characters that may be written into **name**, including the null terminator, is specified by **bufSize**. If the length of the name string including the null terminator is greater than **bufSize**, the first **bufSize**-1 characters of the name string will be written to **name**, followed by a null terminator. If **bufSize** is zero, no error will be generated but no characters will be written to **name**. The length of the longest name string for **programInterface**&gt;, including a null terminator, can be queried by calling **`glGetProgramInterface`** with a **pname** of `GL_MAX_NAME_LENGTH`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **programInterface** is not one of the accepted interface types.
    * 
    * `GL_INVALID_VALUE` is generated if **progam** is not the name of an existing program.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the number of entries in the active resource list for **programInterface**.
    * 
    * `GL_INVALID_ENUM` is generated if **programInterface** is `GL_ATOMIC_COUNTER_BUFFER` or `GL_TRANSFORM_FEEDBACK_BUFFER`, since active atomic counter and transform feedback buffer resources are not assigned name strings.
    * 
    * @param program The name of a program object whose resources to query.
    * @param programInterface A token identifying the interface within **program** containing the indexed resource.
    * @param index The index of the resource within **programInterface** of **program**.
    * @param bufSize The size of the character array whose address is given by **name**.
    * @param length The address of a variable which will receive the length of the resource name.
    * @param name The address of a character array into which will be written the name of the resource.

    * @see **`glGetProgramResourceIndex`**, **`glGetProgramResource`**, **`glGetProgramResourceLocation`**, **`glGetProgramResourceLocationIndex`**.

    **/
    static function getProgramResourceName(program:Int, programInterface:Int, in_dex:Int, bufSize:Int, length:DataPointer, name:Pointer<Char>):Void return ExtensionsNative.getProgramResourceName(program, programInterface, in_dex, bufSize, length, name);
    static function getProgramResourcefvNV(program:Int, programInterface:Int, in_dex:Int, propCount:Int, props:DataPointer, count:Int, length:DataPointer, params:DataPointer):Void return ExtensionsNative.getProgramResourcefvNV(program, programInterface, in_dex, propCount, props, count, length, params);
    static function getProgramResourceiv(program:Int, programInterface:Int, in_dex:Int, propCount:Int, props:DataPointer, count:Int, length:DataPointer, params:DataPointer):Void return ExtensionsNative.getProgramResourceiv(program, programInterface, in_dex, propCount, props, count, length, params);
    static function getProgramStageiv(program:Int, shadertype:Int, pname:Int, values:DataPointer):Void return ExtensionsNative.getProgramStageiv(program, shadertype, pname, values);
    static function getProgramStringARB(target:Int, pname:Int, strin_g:DataPointer):Void return ExtensionsNative.getProgramStringARB(target, pname, strin_g);
    static function getProgramStringNV(id:Int, pname:Int, program:DataPointer):Void return ExtensionsNative.getProgramStringNV(id, pname, program);
    static function getProgramSubroutineParameteruivNV(target:Int, in_dex:Int, param:DataPointer):Void return ExtensionsNative.getProgramSubroutineParameteruivNV(target, in_dex, param);
    static function getProgramiv(program:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getProgramiv(program, pname, params);
    static function getProgramivARB(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getProgramivARB(target, pname, params);
    static function getProgramivNV(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getProgramivNV(id, pname, params);
    static function getQueryBufferObjecti64v(id:Int, buffer:Int, pname:Int, offset:Int):Void return ExtensionsNative.getQueryBufferObjecti64v(id, buffer, pname, offset);
    static function getQueryBufferObjectiv(id:Int, buffer:Int, pname:Int, offset:Int):Void return ExtensionsNative.getQueryBufferObjectiv(id, buffer, pname, offset);
    static function getQueryBufferObjectui64v(id:Int, buffer:Int, pname:Int, offset:Int):Void return ExtensionsNative.getQueryBufferObjectui64v(id, buffer, pname, offset);
    static function getQueryBufferObjectuiv(id:Int, buffer:Int, pname:Int, offset:Int):Void return ExtensionsNative.getQueryBufferObjectuiv(id, buffer, pname, offset);
    static function getQueryIndexediv(target:Int, in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryIndexediv(target, in_dex, pname, params);
    static function getQueryObjecti64v(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryObjecti64v(id, pname, params);
    static function getQueryObjecti64vEXT(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryObjecti64vEXT(id, pname, params);
    static function getQueryObjectiv(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryObjectiv(id, pname, params);
    static function getQueryObjectivARB(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryObjectivARB(id, pname, params);
    static function getQueryObjectivEXT(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryObjectivEXT(id, pname, params);
    static function getQueryObjectui64v(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryObjectui64v(id, pname, params);
    static function getQueryObjectui64vEXT(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryObjectui64vEXT(id, pname, params);
    static function getQueryObjectuiv(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryObjectuiv(id, pname, params);
    static function getQueryObjectuivARB(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryObjectuivARB(id, pname, params);
    static function getQueryObjectuivEXT(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryObjectuivEXT(id, pname, params);
    /**
    * - #### Purpose:
    * return parameters of a query object target
    * ### Description:
    * **glGetQueryiv** returns in **params** a selected parameter of the query object target specified by **target**.
    * 
    * **pname** names a specific query object target parameter. When **pname** is `GL_CURRENT_QUERY`, the name of the currently active query for **target**, or zero if no query is active, will be placed in **params**. If **pname** is `GL_QUERY_COUNTER_BITS`, the implementation-dependent number of bits used to hold the result of queries for **target** is returned in **params**.
    * 
    * 
    * ### Notes:
    * The target `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` is available only if the GL version is 4.3 or greater.
    * 
    * If an error is generated, no change is made to the contents of **params**.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** or **pname** is not an accepted value.
    * 
    * @param target Specifies a query object target. Must be `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, `GL_TIME_ELAPSED`, or `GL_TIMESTAMP`.
    * @param pname Specifies the symbolic name of a query object target parameter. Accepted values are `GL_CURRENT_QUERY` or `GL_QUERY_COUNTER_BITS`.
    * @param params Returns the requested data.

    * @see **`glGetQueryObject`**, **`glIsQuery`**

    **/
    static function getQueryiv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryiv(target, pname, params);
    static function getQueryivARB(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryivARB(target, pname, params);
    static function getQueryivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getQueryivEXT(target, pname, params);
    static function getRenderbufferParameteriv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getRenderbufferParameteriv(target, pname, params);
    static function getRenderbufferParameterivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getRenderbufferParameterivEXT(target, pname, params);
    static function getRenderbufferParameterivOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getRenderbufferParameterivOES(target, pname, params);
    static function getSamplerParameterIiv(sampler:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getSamplerParameterIiv(sampler, pname, params);
    static function getSamplerParameterIivEXT(sampler:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getSamplerParameterIivEXT(sampler, pname, params);
    static function getSamplerParameterIivOES(sampler:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getSamplerParameterIivOES(sampler, pname, params);
    static function getSamplerParameterIuiv(sampler:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getSamplerParameterIuiv(sampler, pname, params);
    static function getSamplerParameterIuivEXT(sampler:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getSamplerParameterIuivEXT(sampler, pname, params);
    static function getSamplerParameterIuivOES(sampler:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getSamplerParameterIuivOES(sampler, pname, params);
    static function getSamplerParameterfv(sampler:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getSamplerParameterfv(sampler, pname, params);
    static function getSamplerParameteriv(sampler:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getSamplerParameteriv(sampler, pname, params);
    static function getSemaphoreParameterivNV(semaphore:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getSemaphoreParameterivNV(semaphore, pname, params);
    static function getSemaphoreParameterui64vEXT(semaphore:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getSemaphoreParameterui64vEXT(semaphore, pname, params);
    static function getSeparableFilter(target:Int, format:Int, type:Int, row:DataPointer, column:DataPointer, span:DataPointer):Void return ExtensionsNative.getSeparableFilter(target, format, type, row, column, span);
    static function getSeparableFilterEXT(target:Int, format:Int, type:Int, row:DataPointer, column:DataPointer, span:DataPointer):Void return ExtensionsNative.getSeparableFilterEXT(target, format, type, row, column, span);
    /**
    * - #### Purpose:
    * Returns the information log for a shader object
    * ### Description:
    * **glGetShaderInfoLog** returns the information log for the specified shader object. The information log for a shader object is modified when the shader is compiled. The string that is returned will be null terminated.
    * 
    * **glGetShaderInfoLog** returns in **infoLog** as much of the information log as it can, up to a maximum of **maxLength** characters. The number of characters actually returned, excluding the null termination character, is specified by **length**. If the length of the returned string is not required, a value of `NULL` can be passed in the **length** argument. The size of the buffer required to store the returned information log can be obtained by calling **`glGetShader`** with the value `GL_INFO_LOG_LENGTH`.
    * 
    * The information log for a shader object is a string that may contain diagnostic messages, warning messages, and other information about the last compile operation. When a shader object is created, its information log will be a string of length 0.
    * 
    * 
    * ### Notes:
    * The information log for a shader object is the OpenGL implementer's primary mechanism for conveying information about the compilation process. Therefore, the information log can be helpful to application developers during the development process, even when compilation is successful. Application developers should not expect different OpenGL implementations to produce identical information logs.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **shader** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **shader** is not a shader object.
    * 
    * `GL_INVALID_VALUE` is generated if **maxLength** is less than 0.
    * 
    * @param shader Specifies the shader object whose information log is to be queried.
    * @param maxLength Specifies the size of the character buffer for storing the returned information log.
    * @param length Returns the length of the string returned in **infoLog** (excluding the null terminator).
    * @param infoLog Specifies an array of characters that is used to return the information log.

    * @see **`glCompileShader`**, **`glGetProgramInfoLog`**, **`glLinkProgram`**, **`glValidateProgram`**

    **/
    static function getShaderInfoLog(shader:Int, bufSize:Int, length:DataPointer, in_foLog:Pointer<Char>):Void return ExtensionsNative.getShaderInfoLog(shader, bufSize, length, in_foLog);
    /**
    * - #### Purpose:
    * retrieve the range and precision for numeric formats supported by the shader compiler
    * ### Description:
    * **glGetShaderPrecisionFormat** retrieves the numeric range and precision for the implementation's representation of quantities in different numeric formats in specified shader type. **shaderType** specifies the type of shader for which the numeric precision and range is to be retrieved and must be one of `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`. **precisionType** specifies the numeric format to query and must be one of `GL_LOW_FLOAT`, `GL_MEDIUM_FLOAT` `GL_HIGH_FLOAT`, `GL_LOW_INT`, `GL_MEDIUM_INT`, or `GL_HIGH_INT`.
    * 
    * **range** points to an array of two integers into which the format's numeric range will be returned. If min and max are the smallest values representable in the format, then the values returned are defined to be: **range**[0] = floor(log2(|min|)) and **range**[1] = floor(log2(|max|)).
    * 
    * **precision** specifies the address of an integer into which will be written the log2 value of the number of bits of precision of the format. If the smallest representable value greater than 1 is 1 + eps, then the integer addressed by **precision** will contain floor(-log2(eps)).
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **shaderType** or **precisionType** is not an accepted value.
    * 
    * @param shaderType Specifies the type of shader whose precision to query. **shaderType** must be `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`.
    * @param precisionType Specifies the numeric format whose precision and range to query.
    * @param range Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
    * @param precision Specifies the address of an integer into which the numeric precision of the implementation is written.

    * @see **/
    static function getShaderPrecisionFormat(shadertype:Int, precisiontype:Int, range:DataPointer, precision:DataPointer):Void return ExtensionsNative.getShaderPrecisionFormat(shadertype, precisiontype, range, precision);
    /**
    * - #### Purpose:
    * Returns the source code string from a shader object
    * ### Description:
    * **glGetShaderSource** returns the concatenation of the source code strings from the shader object specified by **shader**. The source code strings for a shader object are the result of a previous call to **`glShaderSource`**. The string returned by the function will be null terminated.
    * 
    * **glGetShaderSource** returns in **source** as much of the source code string as it can, up to a maximum of **bufSize** characters. The number of characters actually returned, excluding the null termination character, is specified by **length**. If the length of the returned string is not required, a value of `NULL` can be passed in the **length** argument. The size of the buffer required to store the returned source code string can be obtained by calling **`glGetShader`** with the value `GL_SHADER_SOURCE_LENGTH`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **shader** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **shader** is not a shader object.
    * 
    * `GL_INVALID_VALUE` is generated if **bufSize** is less than 0.
    * 
    * @param shader Specifies the shader object to be queried.
    * @param bufSize Specifies the size of the character buffer for storing the returned source code string.
    * @param length Returns the length of the string returned in **source** (excluding the null terminator).
    * @param source Specifies an array of characters that is used to return the source code string.

    * @see **`glCreateShader`**, **`glShaderSource`**

    **/
    static function getShaderSource(shader:Int, bufSize:Int, length:DataPointer, source:Pointer<Char>):Void return ExtensionsNative.getShaderSource(shader, bufSize, length, source);
    static function getShaderSourceARB(obj:Int, maxLength:Int, length:DataPointer, source:Pointer<Char>):Void return ExtensionsNative.getShaderSourceARB(obj, maxLength, length, source);
    static function getShaderiv(shader:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getShaderiv(shader, pname, params);
    static function getShadingRateImagePaletteNV(viewport:Int, entry:Int, rate:DataPointer):Void return ExtensionsNative.getShadingRateImagePaletteNV(viewport, entry, rate);
    static function getShadingRateSampleLocationivNV(rate:Int, samples:Int, in_dex:Int, location:DataPointer):Void return ExtensionsNative.getShadingRateSampleLocationivNV(rate, samples, in_dex, location);
    static function getSharpenTexFuncSGIS(target:Int, poin_ts:DataPointer):Void return ExtensionsNative.getSharpenTexFuncSGIS(target, poin_ts);
    static function getStageIndexNV(shadertype:Int):Int return ExtensionsNative.getStageIndexNV(shadertype);
    /**
    * - #### Purpose:
    * retrieve the index of a subroutine uniform of a given shader stage within a program
    * ### Description:
    * **glGetSubroutineIndex** returns the index of a subroutine uniform within a shader stage attached to a program object. **program** contains the name of the program to which the shader is attached. **shadertype** specifies the stage from which to query shader subroutine index. **name** contains the null-terminated name of the subroutine uniform whose name to query.
    * 
    * If **name** is not the name of a subroutine uniform in the shader stage, `GL_INVALID_INDEX` is returned, but no error is generated. If **name** is the name of a subroutine uniform in the shader stage, a value between zero and the value of `GL_ACTIVE_SUBROUTINES` minus one will be returned. Subroutine indices are assigned using consecutive integers in the range from zero to the value of `GL_ACTIVE_SUBROUTINES` minus one for the shader stage.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **shadertype** or **pname** is not one of the accepted values.
    * 
    * `GL_INVALID_VALUE` is generated if **program** is not the name of an existing program object.
    * 
    * @param program Specifies the name of the program containing shader stage.
    * @param shadertype Specifies the shader stage from which to query for subroutine uniform index. **shadertype** must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.
    * @param name Specifies the name of the subroutine uniform whose index to query.

    * @see **`glGetProgram`**, **`glGetActiveSubroutineUniform`**, **`glGetActiveSubroutineUniformName`**

    **/
    static function getSubroutineIndex(program:Int, shadertype:Int, name:String):Int return ExtensionsNative.getSubroutineIndex(program, shadertype, name);
    /**
    * - #### Purpose:
    * retrieve the location of a subroutine uniform of a given shader stage within a program
    * ### Description:
    * **glGetSubroutineUniformLocation** returns the location of the subroutine uniform variable **name** in the shader stage of type **shadertype** attached to **program**, with behavior otherwise identical to **`glGetUniformLocation`**.
    * 
    * If **name** is not the name of a subroutine uniform in the shader stage, -1 is returned, but no error is generated. If **name** is the name of a subroutine uniform in the shader stage, a value between zero and the value of `GL_ACTIVE_SUBROUTINE_LOCATIONS` minus one will be returned. Subroutine locations are assigned using consecutive integers in the range from zero to the value of `GL_ACTIVE_SUBROUTINE_LOCATIONS` minus one for the shader stage. For active subroutine uniforms declared as arrays, the declared array elements are assigned consecutive locations.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **shadertype** or **pname** is not one of the accepted values.
    * 
    * `GL_INVALID_VALUE` is generated if **program** is not the name of an existing program object.
    * 
    * @param program Specifies the name of the program containing shader stage.
    * @param shadertype Specifies the shader stage from which to query for subroutine uniform index. **shadertype** must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.
    * @param name Specifies the name of the subroutine uniform whose index to query.

    * @see **`glGetProgram`**, **`glGetActiveSubroutineUniform`**, **`glGetActiveSubroutineUniformName`**, **`glGetUniformLocation`**

    **/
    static function getSubroutineUniformLocation(program:Int, shadertype:Int, name:String):Int return ExtensionsNative.getSubroutineUniformLocation(program, shadertype, name);
    static function getSynciv(sync:DataPointer, pname:Int, count:Int, length:DataPointer, values:DataPointer):Void return ExtensionsNative.getSynciv(sync, pname, count, length, values);
    static function getSyncivAPPLE(sync:DataPointer, pname:Int, count:Int, length:DataPointer, values:DataPointer):Void return ExtensionsNative.getSyncivAPPLE(sync, pname, count, length, values);
    static function getTexBumpParameterfvATI(pname:Int, param:DataPointer):Void return ExtensionsNative.getTexBumpParameterfvATI(pname, param);
    static function getTexBumpParameterivATI(pname:Int, param:DataPointer):Void return ExtensionsNative.getTexBumpParameterivATI(pname, param);
    static function getTexEnvfv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexEnvfv(target, pname, params);
    static function getTexEnviv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexEnviv(target, pname, params);
    static function getTexEnvxv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexEnvxv(target, pname, params);
    static function getTexEnvxvOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexEnvxvOES(target, pname, params);
    static function getTexFilterFuncSGIS(target:Int, filter:Int, weights:DataPointer):Void return ExtensionsNative.getTexFilterFuncSGIS(target, filter, weights);
    static function getTexGendv(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexGendv(coord, pname, params);
    static function getTexGenfv(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexGenfv(coord, pname, params);
    static function getTexGenfvOES(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexGenfvOES(coord, pname, params);
    static function getTexGeniv(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexGeniv(coord, pname, params);
    static function getTexGenivOES(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexGenivOES(coord, pname, params);
    static function getTexGenxvOES(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexGenxvOES(coord, pname, params);
    /**
    * - #### Purpose:
    * return a texture image
    * ### Description:
    * **glGetTexImage**, **glGetnTexImage** and **glGetTextureImage** functions return a texture image into **pixels**. For **glGetTexImage** and **glGetnTexImage**, **target** specifies whether the desired texture image is one specified by **`glTexImage1D`** (`GL_TEXTURE_1D`), **`glTexImage2D`** (`GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_2D` or any of `GL_TEXTURE_CUBE_MAP_*`), or **`glTexImage3D`** (`GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_ARRAY`). For **glGetTextureImage**, **texture** specifies the texture object name. In addition to types of textures accepted by **glGetTexImage** and **glGetnTexImage**, the function also accepts cube map texture objects (with effective target `GL_TEXTURE_CUBE_MAP`). **level** specifies the level-of-detail number of the desired image. **format** and **type** specify the format and type of the desired image array. See the reference page for **`glTexImage1D`** for a description of the acceptable values for the **format** and **type** parameters, respectively. For glGetnTexImage and glGetTextureImage functions, bufSize tells the size of the buffer to receive the retrieved pixel data. **glGetnTexImage** and **glGetTextureImage** do not write more than **bufSize** bytes into **pixels**.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is requested, **pixels** is treated as a byte offset into the buffer object's data store.
    * 
    * To understand the operation of **glGetTexImage**, consider the selected internal four-component texture image to be an RGBA color buffer the size of the image. The semantics of **glGetTexImage** are then identical to those of **`glReadPixels`**, with the exception that no pixel transfer operations are performed, when called with the same **format** and **type**, with x and y set to 0, width set to the width of the texture image and height set to 1 for 1D images, or to the height of the texture image for 2D images.
    * 
    * If the selected texture image does not contain four components, the following mappings are applied. Single-component textures are treated as RGBA buffers with red set to the single-component value, green set to 0, blue set to 0, and alpha set to 1. Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the value of component one, and green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with red set to component zero, green set to component one, blue set to component two, and alpha set to 1.
    * 
    * To determine the required size of **pixels**, use **`glGetTexLevelParameter`** to determine the dimensions of the internal texture image, then scale the required number of pixels by the storage required for each pixel, based on **format** and **type**. Be sure to take the pixel storage parameters into account, especially `GL_PACK_ALIGNMENT`.
    * 
    * If **glGetTextureImage** is used against a cube map texture object, the texture is treated as a three-dimensional image of a depth of 6, where the cube map faces are ordered as image layers, in an order presented in the table below:
    * 
    * 
    * ### Notes:
    * If an error is generated, no change is made to the contents of **pixels**.
    * 
    * **glGetTexImage** and **glGetnTexImage** return the texture image for the active texture unit.
    * 
    * `GL_STENCIL_INDEX` is accepted for **format** only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glGetTexImage** and **glGetnTexImage** functions if **target** is not an accepted value. These include:
    * 
    * `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, and `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z` for **glGetTexImage** and **glGetnTexImage** functions. `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_RECTANGLE`, and `GL_TEXTURE_CUBE_MAP` for **glGetTextureImage** function.
    * 
    * `GL_INVALID_OPERATION` is generated by **glGetTextureImage** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_ENUM` is generated if **format**, or **type** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` may be generated if **level** is greater than log 2 &amp;af; max, where maxis the returned value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is non-zero and the effective target is `GL_TEXTURE_RECTANGLE`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, or `GL_UNSIGNED_INT_10F_11F_11F_REV` and **format** is not `GL_RGB`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, or `GL_UNSIGNED_INT_5_9_9_9_REV` and **format** is neither `GL_RGBA` or `GL_BGRA`.
    * 
    * `GL_INVALID_OPERATION` is generated if **format** is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX` or `GL_DEPTH_STENCIL`.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and **pixels** is not evenly divisible into the number of bytes needed to store in memory a datum indicated by **type**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glGetTextureImage** and **glGetnTexImage** if the buffer size required to store the requested data is greater than **bufSize**.
    * 
    * @param target Specifies the target to which the texture is bound for **glGetTexImage** and **glGetnTexImage** functions. `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, and `GL_TEXTURE_CUBE_MAP_ARRAY` are acceptable.
    * @param texture Specifies the texture object name.
    * @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param format Specifies a pixel format for the returned data. The supported formats are `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RG`, `GL_RGB`, `GL_RGBA`, `GL_BGR`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_GREEN_INTEGER`, `GL_BLUE_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGR_INTEGER`, `GL_BGRA_INTEGER`.
    * @param type Specifies a pixel type for the returned data. The supported types are `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.
    * @param bufSize Specifies the size of the buffer **pixels** for **glGetnTexImage** and **glGetTextureImage** functions.
    * @param pixels Returns the texture image. Should be a pointer to an array of the type specified by **type**.

    * @see **`glActiveTexture`**, **`glReadPixels`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**, **`glTexParameter`**

    **/
    static function getTexImage(target:Int, level:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.getTexImage(target, level, format, type, pixels);
    static function getTexLevelParameterfv(target:Int, level:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexLevelParameterfv(target, level, pname, params);
    static function getTexLevelParameteriv(target:Int, level:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexLevelParameteriv(target, level, pname, params);
    static function getTexLevelParameterxvOES(target:Int, level:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexLevelParameterxvOES(target, level, pname, params);
    static function getTexParameterIiv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexParameterIiv(target, pname, params);
    static function getTexParameterIivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexParameterIivEXT(target, pname, params);
    static function getTexParameterIivOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexParameterIivOES(target, pname, params);
    static function getTexParameterIuiv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexParameterIuiv(target, pname, params);
    static function getTexParameterIuivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexParameterIuivEXT(target, pname, params);
    static function getTexParameterIuivOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexParameterIuivOES(target, pname, params);
    static function getTexParameterPointervAPPLE(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexParameterPointervAPPLE(target, pname, params);
    static function getTexParameterfv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexParameterfv(target, pname, params);
    static function getTexParameteriv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexParameteriv(target, pname, params);
    static function getTexParameterxv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexParameterxv(target, pname, params);
    static function getTexParameterxvOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTexParameterxvOES(target, pname, params);
    static function getTextureHandleARB(texture:Int):Int return ExtensionsNative.getTextureHandleARB(texture);
    static function getTextureHandleIMG(texture:Int):Int return ExtensionsNative.getTextureHandleIMG(texture);
    static function getTextureHandleNV(texture:Int):Int return ExtensionsNative.getTextureHandleNV(texture);
    static function getTextureImage(texture:Int, level:Int, format:Int, type:Int, bufSize:Int, pixels:DataPointer):Void return ExtensionsNative.getTextureImage(texture, level, format, type, bufSize, pixels);
    static function getTextureImageEXT(texture:Int, target:Int, level:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.getTextureImageEXT(texture, target, level, format, type, pixels);
    static function getTextureLevelParameterfv(texture:Int, level:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureLevelParameterfv(texture, level, pname, params);
    static function getTextureLevelParameterfvEXT(texture:Int, target:Int, level:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureLevelParameterfvEXT(texture, target, level, pname, params);
    static function getTextureLevelParameteriv(texture:Int, level:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureLevelParameteriv(texture, level, pname, params);
    static function getTextureLevelParameterivEXT(texture:Int, target:Int, level:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureLevelParameterivEXT(texture, target, level, pname, params);
    static function getTextureParameterIiv(texture:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureParameterIiv(texture, pname, params);
    static function getTextureParameterIivEXT(texture:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureParameterIivEXT(texture, target, pname, params);
    static function getTextureParameterIuiv(texture:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureParameterIuiv(texture, pname, params);
    static function getTextureParameterIuivEXT(texture:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureParameterIuivEXT(texture, target, pname, params);
    static function getTextureParameterfv(texture:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureParameterfv(texture, pname, params);
    static function getTextureParameterfvEXT(texture:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureParameterfvEXT(texture, target, pname, params);
    static function getTextureParameteriv(texture:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureParameteriv(texture, pname, params);
    static function getTextureParameterivEXT(texture:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTextureParameterivEXT(texture, target, pname, params);
    static function getTextureSamplerHandleARB(texture:Int, sampler:Int):Int return ExtensionsNative.getTextureSamplerHandleARB(texture, sampler);
    static function getTextureSamplerHandleIMG(texture:Int, sampler:Int):Int return ExtensionsNative.getTextureSamplerHandleIMG(texture, sampler);
    static function getTextureSamplerHandleNV(texture:Int, sampler:Int):Int return ExtensionsNative.getTextureSamplerHandleNV(texture, sampler);
    /**
    * - #### Purpose:
    * retrieve a sub-region of a texture image from a texture
        object
    * ### Description:
    * **glGetTextureSubImage** returns a texture subimage into pixels.
    * 
    * **texture** is the name of the source texture object and must not be a buffer or multisample texture. The effective **target** parameter is the value of `GL_TEXTURE_TARGET` for texture. **Level**, **format**, **type** and **pixels** have the same meaning as for **glGetTexImage**. **bufSize** is the size of the buffer to receive the retrieved pixel data.
    * 
    * For cube map textures, the behavior is as though **GetTextureImage** were called, but only texels from the requested cube map faces (selected by **zoffset** and **depth**, as described below) were returned.
    * 
    * **xoffset**, **yoffset** and **zoffset** values indicate the position of the subregion to return. **width**, **height** and **depth** indicate the size of the region to return. These parameters have the same meaning as for **glTexSubImage3D**, though for one- and two-dimensional textures there are extra restrictions, described in the errors section below.
    * 
    * For one-dimensional array textures, **yoffset** is interpreted as the first layer to access and **height** is the number of layers to access.
    * 
    * For two-dimensional array textures, **zoffset** is interpreted as the first layer to access and **depth** is the number of layers to access.
    * 
    * Cube map textures are treated as an array of six slices in the z-dimension, where the value of **zoffset** is interpreted as specifying the cube map face for the corresponding layer (as presented in the table below) and **depth** is the number of faces to access:
    * 
    * Layer number Cube Map Face 0 GL_TEXTURE_CUBE_MAP_POSITIVE_X 1 GL_TEXTURE_CUBE_MAP_NEGATIVE_X 2 GL_TEXTURE_CUBE_MAP_POSITIVE_Y 3 GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 4 GL_TEXTURE_CUBE_MAP_POSITIVE_Z 5 GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
    * 
    * For cube map array textures, **zoffset** is the first layer-face to access, and **depth** is the number of layer-faces to access. A layer-face described by $k$ is translated into an array layer and face according to $$ layer = \left\lfloor { layer \over 6 } \right\rfloor$$ and $$ face = k \bmod 6. $$
    * 
    * Component groups from the specified sub-region are packed and placed into memory as described for **glGetTextureImage**, starting with the texel at (**xoffset**, **yoffset**, **zoffset**).
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` error is generated if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_OPERATION` error is generated if **texture** is the name of a buffer or multisample texture.
    * 
    * `GL_INVALID_VALUE` is generated if **xoffset**, **yoffset** or **zoffset** are negative.
    * 
    * `GL_INVALID_VALUE` is generated if **xoffset** + **width** is greater than the texture's width, **yoffset** + **height** is greater than the texture's height, or **zoffset** + **depth** is greater than the texture's depth.
    * 
    * `GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D` and either **yoffset** is not zero, or **height** is not one.
    * 
    * `GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D` or `GL_TEXTURE_RECTANGLE` and either **zoffset** is not zero, or **depth** is not one.
    * 
    * `GL_INVALID_OPERATION` error is generated if the buffer size required to store the requested data is greater than **bufSize**.
    * 
    * @param texture Specifies the name of the source texture object. Must be `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY` or `GL_TEXTURE_RECTANGLE`. In specific, buffer and multisample textures are not permitted.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.
    * @param xoffset Specifies a texel offset in the x direction within the texture array.
    * @param yoffset Specifies a texel offset in the y direction within the texture array.
    * @param zoffset Specifies a texel offset in the z direction within the texture array.
    * @param width Specifies the width of the texture subimage.
    * @param height Specifies the height of the texture subimage.
    * @param depth Specifies the depth of the texture subimage.
    * @param format Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_DEPTH_COMPONENT` and `GL_STENCIL_INDEX`.
    * @param type Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.
    * @param bufSize Specifies the size of the buffer to receive the retrieved pixel data.
    * @param pixels Returns the texture subimage. Should be a pointer to an array of the type specified by **type**.

    * @see **`glGetTexImage`**, **glGetTextureImage**, **`glReadPixels`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**

    **/
    static function getTextureSubImage(texture:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, type:Int, bufSize:Int, pixels:DataPointer):Void return ExtensionsNative.getTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
    static function getTrackMatrixivNV(target:Int, address:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getTrackMatrixivNV(target, address, pname, params);
    /**
    * - #### Purpose:
    * retrieve information about varying variables selected for transform feedback
    * ### Description:
    * Information about the set of varying variables in a linked program that will be captured during transform feedback may be retrieved by calling **glGetTransformFeedbackVarying**. **glGetTransformFeedbackVarying** provides information about the varying variable selected by **index**. An **index** of 0 selects the first varying variable specified in the **varyings** array passed to **`glTransformFeedbackVaryings`**, and an **index** of the value of `GL_TRANSFORM_FEEDBACK_VARYINGS` minus one selects the last such variable.
    * 
    * The name of the selected varying is returned as a null-terminated string in **name**. The actual number of characters written into **name**, excluding the null terminator, is returned in **length**. If **length** is NULL, no length is returned. The maximum number of characters that may be written into **name**, including the null terminator, is specified by **bufSize**.
    * 
    * The length of the longest varying name in program is given by `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`, which can be queried with **`glGetProgram`**.
    * 
    * For the selected varying variable, its type is returned into **type**. The size of the varying is returned into **size**. The value in **size** is in units of the type returned in **type**. The type returned can be any of the scalar, vector, or matrix attribute types returned by **`glGetActiveAttrib`**. If an error occurred, the return parameters **length**, **size**, **type** and **name** will be unmodified. This command will return as much information about the varying variables as possible. If no information is available, **length** will be set to zero and **name** will be an empty string. This situation could arise if **glGetTransformFeedbackVarying** is called after a failed link.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not the name of a program object.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater or equal to the value of `GL_TRANSFORM_FEEDBACK_VARYINGS`.
    * 
    * `GL_INVALID_OPERATION` is generated **program** has not been linked.
    * 
    * @param program The name of the target program object.
    * @param index The index of the varying variable whose information to retrieve.
    * @param bufSize The maximum number of characters, including the null terminator, that may be written into **name**.
    * @param length The address of a variable which will receive the number of characters written into **name**, excluding the null-terminator. If **length** is `NULL` no length is returned.
    * @param size The address of a variable that will receive the size of the varying.
    * @param type The address of a variable that will receive the type of the varying.
    * @param name The address of a buffer into which will be written the name of the varying.

    * @see **`glBeginTransformFeedback`**, **glEndTransformFeedback**, **`glTransformFeedbackVaryings`**, **`glGetProgram`**

    **/
    static function getTransformFeedbackVarying(program:Int, in_dex:Int, bufSize:Int, length:DataPointer, size:DataPointer, type:DataPointer, name:Pointer<Char>):Void return ExtensionsNative.getTransformFeedbackVarying(program, in_dex, bufSize, length, size, type, name);
    static function getTransformFeedbackVaryingEXT(program:Int, in_dex:Int, bufSize:Int, length:DataPointer, size:DataPointer, type:DataPointer, name:Pointer<Char>):Void return ExtensionsNative.getTransformFeedbackVaryingEXT(program, in_dex, bufSize, length, size, type, name);
    static function getTransformFeedbackVaryingNV(program:Int, in_dex:Int, location:DataPointer):Void return ExtensionsNative.getTransformFeedbackVaryingNV(program, in_dex, location);
    static function getTransformFeedbacki64_v(xfb:Int, pname:Int, in_dex:Int, param:DataPointer):Void return ExtensionsNative.getTransformFeedbacki64_v(xfb, pname, in_dex, param);
    static function getTransformFeedbacki_v(xfb:Int, pname:Int, in_dex:Int, param:DataPointer):Void return ExtensionsNative.getTransformFeedbacki_v(xfb, pname, in_dex, param);
    static function getTransformFeedbackiv(xfb:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.getTransformFeedbackiv(xfb, pname, param);
    static function getTranslatedShaderSourceANGLE(shader:Int, bufSize:Int, length:DataPointer, source:Pointer<Char>):Void return ExtensionsNative.getTranslatedShaderSourceANGLE(shader, bufSize, length, source);
    /**
    * - #### Purpose:
    * retrieve the index of a named uniform block
    * ### Description:
    * **glGetUniformBlockIndex** retrieves the index of a uniform block within **program**.
    * 
    * **program** must be the name of a program object for which the command **`glLinkProgram`** must have been called in the past, although it is not required that **`glLinkProgram`** must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.
    * 
    * **uniformBlockName** must contain a nul-terminated string specifying the name of the uniform block.
    * 
    * **glGetUniformBlockIndex** returns the uniform block index for the uniform block named **uniformBlockName** of **program**. If **uniformBlockName** does not identify an active uniform block of **program**, **glGetUniformBlockIndex** returns the special identifier, `GL_INVALID_INDEX`. Indices of the active uniform blocks of a program are assigned in consecutive order, beginning with zero.
    * 
    * 
    * ### Notes:
    * **glGetUniformBlockIndex** is available only if the GL version is 3.1 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **program** is not the name of a program object for which **`glLinkProgram`** has been called in the past.
    * 
    * @param program Specifies the name of a program containing the uniform block.
    * @param uniformBlockName Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.

    * @see **`glGetActiveUniformBlockName`**, **`glGetActiveUniformBlock`**, **`glLinkProgram`**

    **/
    static function getUniformBlockIndex(program:Int, uniformBlockName:String):Int return ExtensionsNative.getUniformBlockIndex(program, uniformBlockName);
    static function getUniformBufferSizeEXT(program:Int, location:Int):Int return ExtensionsNative.getUniformBufferSizeEXT(program, location);
    /**
    * - #### Purpose:
    * retrieve the index of a named uniform block
    * ### Description:
    * **glGetUniformIndices** retrieves the indices of a number of uniforms within **program**.
    * 
    * **program** must be the name of a program object for which the command **`glLinkProgram`** must have been called in the past, although it is not required that **`glLinkProgram`** must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.
    * 
    * **uniformCount** indicates both the number of elements in the array of names **uniformNames** and the number of indices that may be written to **uniformIndices**.
    * 
    * **uniformNames** contains a list of **uniformCount** name strings identifying the uniform names to be queried for indices. For each name string in **uniformNames**, the index assigned to the active uniform of that name will be written to the corresponding element of **uniformIndices**. If a string in **uniformNames** is not the name of an active uniform, the special value `GL_INVALID_INDEX` will be written to the corresponding element of **uniformIndices**.
    * 
    * If an error occurs, nothing is written to **uniformIndices**.
    * 
    * 
    * ### Notes:
    * **glGetUniformIndices** is available only if the GL version is 3.1 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **program** is not the name of a program object for which **`glLinkProgram`** has been called in the past.
    * 
    * @param program Specifies the name of a program containing uniforms whose indices to query.
    * @param uniformCount Specifies the number of uniforms whose indices to query.
    * @param uniformNames Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
    * @param uniformIndices Specifies the address of an array that will receive the indices of the uniforms.

    * @see **`glGetActiveUniform`**, **`glGetActiveUniformName`**, **`glLinkProgram`**

    **/
    static function getUniformIndices(program:Int, uniformCount:Int, uniformNames:String, uniformIndices:DataPointer):Void return ExtensionsNative.getUniformIndices(program, uniformCount, uniformNames, uniformIndices);
    /**
    * - #### Purpose:
    * Returns the location of a uniform variable
    * ### Description:
    * **glGetUniformLocation** returns an integer that represents the location of a specific uniform variable within a program object. **name** must be a null terminated string that contains no white space. **name** must be an active uniform variable name in **program** that is not a structure, an array of structures, or a subcomponent of a vector or a matrix. This function returns -1 if **name** does not correspond to an active uniform variable in **program**, if **name** starts with the reserved prefix "gl_", or if **name** is associated with an atomic counter or a named uniform block.
    * 
    * Uniform variables that are structures or arrays of structures may be queried by calling **glGetUniformLocation** for each field within the structure. The array element operator "[]" and the structure field operator "." may be used in **name** in order to select elements within an array or fields within a structure. The result of using these operators is not allowed to be another structure, an array of structures, or a subcomponent of a vector or a matrix. Except if the last part of **name** indicates a uniform variable array, the location of the first element of an array can be retrieved by using the name of the array, or by using the name appended by "[0]".
    * 
    * The actual locations assigned to uniform variables are not known until the program object is linked successfully. After linking has occurred, the command **glGetUniformLocation** can be used to obtain the location of a uniform variable. This location value can then be passed to **`glUniform`** to set the value of the uniform variable or to **`glGetUniform`** in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. Uniform variable locations and values can only be queried after a link if the link was successful.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** has not been successfully linked.
    * 
    * @param program Specifies the program object to be queried.
    * @param name Points to a null terminated string containing the name of the uniform variable whose location is to be queried.

    * @see **`glLinkProgram`**, **`glUniform`**

    **/
    static function getUniformLocation(program:Int, name:String):Int return ExtensionsNative.getUniformLocation(program, name);
    static function getUniformLocationARB(programObj:Int, name:String):Int return ExtensionsNative.getUniformLocationARB(programObj, name);
    static function getUniformOffsetEXT(program:Int, location:Int):Int return ExtensionsNative.getUniformOffsetEXT(program, location);
    static function getUniformSubroutineuiv(shadertype:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformSubroutineuiv(shadertype, location, params);
    static function getUniformdv(program:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformdv(program, location, params);
    static function getUniformfv(program:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformfv(program, location, params);
    static function getUniformfvARB(programObj:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformfvARB(programObj, location, params);
    static function getUniformi64vARB(program:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformi64vARB(program, location, params);
    static function getUniformi64vNV(program:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformi64vNV(program, location, params);
    static function getUniformiv(program:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformiv(program, location, params);
    static function getUniformivARB(programObj:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformivARB(programObj, location, params);
    static function getUniformui64vARB(program:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformui64vARB(program, location, params);
    static function getUniformui64vNV(program:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformui64vNV(program, location, params);
    static function getUniformuiv(program:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformuiv(program, location, params);
    static function getUniformuivEXT(program:Int, location:Int, params:DataPointer):Void return ExtensionsNative.getUniformuivEXT(program, location, params);
    static function getUnsignedBytevEXT(pname:Int, data:DataPointer):Void return ExtensionsNative.getUnsignedBytevEXT(pname, data);
    static function getUnsignedBytei_vEXT(target:Int, in_dex:Int, data:DataPointer):Void return ExtensionsNative.getUnsignedBytei_vEXT(target, in_dex, data);
    static function getVariantArrayObjectfvATI(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVariantArrayObjectfvATI(id, pname, params);
    static function getVariantArrayObjectivATI(id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVariantArrayObjectivATI(id, pname, params);
    static function getVariantBooleanvEXT(id:Int, value:Int, data:DataPointer):Void return ExtensionsNative.getVariantBooleanvEXT(id, value, data);
    static function getVariantFloatvEXT(id:Int, value:Int, data:DataPointer):Void return ExtensionsNative.getVariantFloatvEXT(id, value, data);
    static function getVariantIntegervEXT(id:Int, value:Int, data:DataPointer):Void return ExtensionsNative.getVariantIntegervEXT(id, value, data);
    static function getVariantPointervEXT(id:Int, value:Int, data:DataPointer):Void return ExtensionsNative.getVariantPointervEXT(id, value, data);
    static function getVaryingLocationNV(program:Int, name:String):Int return ExtensionsNative.getVaryingLocationNV(program, name);
    static function getVertexArrayIndexed64iv(vaobj:Int, in_dex:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.getVertexArrayIndexed64iv(vaobj, in_dex, pname, param);
    static function getVertexArrayIndexediv(vaobj:Int, in_dex:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.getVertexArrayIndexediv(vaobj, in_dex, pname, param);
    static function getVertexArrayIntegeri_vEXT(vaobj:Int, in_dex:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.getVertexArrayIntegeri_vEXT(vaobj, in_dex, pname, param);
    static function getVertexArrayIntegervEXT(vaobj:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.getVertexArrayIntegervEXT(vaobj, pname, param);
    static function getVertexArrayPointeri_vEXT(vaobj:Int, in_dex:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.getVertexArrayPointeri_vEXT(vaobj, in_dex, pname, param);
    static function getVertexArrayPointervEXT(vaobj:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.getVertexArrayPointervEXT(vaobj, pname, param);
    /**
    * - #### Purpose:
    * retrieve parameters of a vertex array object
    * ### Description:
    * This function provides a mean of querying properties of an existing vertex array object. The vertex array object does not have to be bound to the rendering context at the time of the call, but must have been bound at least once prior to this call.
    * 
    * **glGetVertexArrayiv** can be used to retrieve ID of a buffer object that will be bound to the `GL_ELEMENT_ARRAY_BUFFER` binding point whenever the queried vertex array object is bound to the rendering context. The binding can be changed for an active vertex array object with a **glBindBuffer** call.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` error is generated if **vaobj** is not the name of an existing vertex array object.
    * 
    * `GL_INVALID_ENUM` error is generated if **pname** is not `GL_ELEMENT_ARRAY_BUFFER_BINDING`.
    * 
    * @param vaobj specifies the name of the vertex array object to use for the query.
    * @param pname Name of the property to use for the query. Must be `GL_ELEMENT_ARRAY_BUFFER_BINDING`.
    * @param param Returns the requested value.

    * @see **`glBindBuffer`**, **`glBindVertexArray`**, **`glGet`**

    **/
    static function getVertexArrayiv(vaobj:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.getVertexArrayiv(vaobj, pname, param);
    static function getVertexAttribArrayObjectfvATI(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribArrayObjectfvATI(in_dex, pname, params);
    static function getVertexAttribArrayObjectivATI(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribArrayObjectivATI(in_dex, pname, params);
    static function getVertexAttribIiv(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribIiv(in_dex, pname, params);
    static function getVertexAttribIivEXT(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribIivEXT(in_dex, pname, params);
    static function getVertexAttribIuiv(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribIuiv(in_dex, pname, params);
    static function getVertexAttribIuivEXT(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribIuivEXT(in_dex, pname, params);
    static function getVertexAttribLdv(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribLdv(in_dex, pname, params);
    static function getVertexAttribLdvEXT(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribLdvEXT(in_dex, pname, params);
    static function getVertexAttribLi64vNV(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribLi64vNV(in_dex, pname, params);
    static function getVertexAttribLui64vARB(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribLui64vARB(in_dex, pname, params);
    static function getVertexAttribLui64vNV(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribLui64vNV(in_dex, pname, params);
    /**
    * - #### Purpose:
    * return the address of the specified generic vertex attribute pointer
    * ### Description:
    * **glGetVertexAttribPointerv** returns pointer information. **index** is the generic vertex attribute to be queried, **pname** is a symbolic constant indicating the pointer to be returned, and **params** is a pointer to a location in which to place the returned data.
    * 
    * The **pointer** returned is a byte offset into the data store of the buffer object that was bound to the `GL_ARRAY_BUFFER` target (see **`glBindBuffer`**) when the desired pointer was previously specified.
    * 
    * 
    * ### Notes:
    * The state returned is retrieved from the currently bound vertex array object.
    * 
    * The initial value for each pointer is 0.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if no vertex array object is currently bound.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.
    * 
    * `GL_INVALID_ENUM` is generated if **pname** is not an accepted value.
    * 
    * @param index Specifies the generic vertex attribute parameter to be returned.
    * @param pname Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be `GL_VERTEX_ATTRIB_ARRAY_POINTER`.
    * @param pointer Returns the pointer value.

    * @see **`glGetVertexAttrib`**, **`glVertexAttribPointer`**

    **/
    static function getVertexAttribPointerv(in_dex:Int, pname:Int, poin_ter:DataPointer):Void return ExtensionsNative.getVertexAttribPointerv(in_dex, pname, poin_ter);
    static function getVertexAttribPointervARB(in_dex:Int, pname:Int, poin_ter:DataPointer):Void return ExtensionsNative.getVertexAttribPointervARB(in_dex, pname, poin_ter);
    static function getVertexAttribPointervNV(in_dex:Int, pname:Int, poin_ter:DataPointer):Void return ExtensionsNative.getVertexAttribPointervNV(in_dex, pname, poin_ter);
    static function getVertexAttribdv(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribdv(in_dex, pname, params);
    static function getVertexAttribdvARB(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribdvARB(in_dex, pname, params);
    static function getVertexAttribdvNV(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribdvNV(in_dex, pname, params);
    static function getVertexAttribfv(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribfv(in_dex, pname, params);
    static function getVertexAttribfvARB(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribfvARB(in_dex, pname, params);
    static function getVertexAttribfvNV(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribfvNV(in_dex, pname, params);
    static function getVertexAttribiv(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribiv(in_dex, pname, params);
    static function getVertexAttribivARB(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribivARB(in_dex, pname, params);
    static function getVertexAttribivNV(in_dex:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVertexAttribivNV(in_dex, pname, params);
    static function getVideoCaptureStreamdvNV(video_capture_slot:Int, stream:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVideoCaptureStreamdvNV(video_capture_slot, stream, pname, params);
    static function getVideoCaptureStreamfvNV(video_capture_slot:Int, stream:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVideoCaptureStreamfvNV(video_capture_slot, stream, pname, params);
    static function getVideoCaptureStreamivNV(video_capture_slot:Int, stream:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVideoCaptureStreamivNV(video_capture_slot, stream, pname, params);
    static function getVideoCaptureivNV(video_capture_slot:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVideoCaptureivNV(video_capture_slot, pname, params);
    static function getVideoi64vNV(video_slot:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVideoi64vNV(video_slot, pname, params);
    static function getVideoivNV(video_slot:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVideoivNV(video_slot, pname, params);
    static function getVideoui64vNV(video_slot:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVideoui64vNV(video_slot, pname, params);
    static function getVideouivNV(video_slot:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getVideouivNV(video_slot, pname, params);
    static function getnColorTable(target:Int, format:Int, type:Int, bufSize:Int, table:DataPointer):Void return ExtensionsNative.getnColorTable(target, format, type, bufSize, table);
    static function getnColorTableARB(target:Int, format:Int, type:Int, bufSize:Int, table:DataPointer):Void return ExtensionsNative.getnColorTableARB(target, format, type, bufSize, table);
    static function getnCompressedTexImage(target:Int, lod:Int, bufSize:Int, pixels:DataPointer):Void return ExtensionsNative.getnCompressedTexImage(target, lod, bufSize, pixels);
    static function getnCompressedTexImageARB(target:Int, lod:Int, bufSize:Int, img:DataPointer):Void return ExtensionsNative.getnCompressedTexImageARB(target, lod, bufSize, img);
    static function getnConvolutionFilter(target:Int, format:Int, type:Int, bufSize:Int, image:DataPointer):Void return ExtensionsNative.getnConvolutionFilter(target, format, type, bufSize, image);
    static function getnConvolutionFilterARB(target:Int, format:Int, type:Int, bufSize:Int, image:DataPointer):Void return ExtensionsNative.getnConvolutionFilterARB(target, format, type, bufSize, image);
    static function getnHistogram(target:Int, reset:Bool, format:Int, type:Int, bufSize:Int, values:DataPointer):Void return ExtensionsNative.getnHistogram(target, reset, format, type, bufSize, values);
    static function getnHistogramARB(target:Int, reset:Bool, format:Int, type:Int, bufSize:Int, values:DataPointer):Void return ExtensionsNative.getnHistogramARB(target, reset, format, type, bufSize, values);
    static function getnMapdv(target:Int, query:Int, bufSize:Int, v:DataPointer):Void return ExtensionsNative.getnMapdv(target, query, bufSize, v);
    static function getnMapdvARB(target:Int, query:Int, bufSize:Int, v:DataPointer):Void return ExtensionsNative.getnMapdvARB(target, query, bufSize, v);
    static function getnMapfv(target:Int, query:Int, bufSize:Int, v:DataPointer):Void return ExtensionsNative.getnMapfv(target, query, bufSize, v);
    static function getnMapfvARB(target:Int, query:Int, bufSize:Int, v:DataPointer):Void return ExtensionsNative.getnMapfvARB(target, query, bufSize, v);
    static function getnMapiv(target:Int, query:Int, bufSize:Int, v:DataPointer):Void return ExtensionsNative.getnMapiv(target, query, bufSize, v);
    static function getnMapivARB(target:Int, query:Int, bufSize:Int, v:DataPointer):Void return ExtensionsNative.getnMapivARB(target, query, bufSize, v);
    static function getnMinmax(target:Int, reset:Bool, format:Int, type:Int, bufSize:Int, values:DataPointer):Void return ExtensionsNative.getnMinmax(target, reset, format, type, bufSize, values);
    static function getnMinmaxARB(target:Int, reset:Bool, format:Int, type:Int, bufSize:Int, values:DataPointer):Void return ExtensionsNative.getnMinmaxARB(target, reset, format, type, bufSize, values);
    static function getnPixelMapfv(map:Int, bufSize:Int, values:DataPointer):Void return ExtensionsNative.getnPixelMapfv(map, bufSize, values);
    static function getnPixelMapfvARB(map:Int, bufSize:Int, values:DataPointer):Void return ExtensionsNative.getnPixelMapfvARB(map, bufSize, values);
    static function getnPixelMapuiv(map:Int, bufSize:Int, values:DataPointer):Void return ExtensionsNative.getnPixelMapuiv(map, bufSize, values);
    static function getnPixelMapuivARB(map:Int, bufSize:Int, values:DataPointer):Void return ExtensionsNative.getnPixelMapuivARB(map, bufSize, values);
    static function getnPixelMapusv(map:Int, bufSize:Int, values:DataPointer):Void return ExtensionsNative.getnPixelMapusv(map, bufSize, values);
    static function getnPixelMapusvARB(map:Int, bufSize:Int, values:DataPointer):Void return ExtensionsNative.getnPixelMapusvARB(map, bufSize, values);
    static function getnPolygonStipple(bufSize:Int, pattern:DataPointer):Void return ExtensionsNative.getnPolygonStipple(bufSize, pattern);
    static function getnPolygonStippleARB(bufSize:Int, pattern:DataPointer):Void return ExtensionsNative.getnPolygonStippleARB(bufSize, pattern);
    static function getnSeparableFilter(target:Int, format:Int, type:Int, rowBufSize:Int, row:DataPointer, columnBufSize:Int, column:DataPointer, span:DataPointer):Void return ExtensionsNative.getnSeparableFilter(target, format, type, rowBufSize, row, columnBufSize, column, span);
    static function getnSeparableFilterARB(target:Int, format:Int, type:Int, rowBufSize:Int, row:DataPointer, columnBufSize:Int, column:DataPointer, span:DataPointer):Void return ExtensionsNative.getnSeparableFilterARB(target, format, type, rowBufSize, row, columnBufSize, column, span);
    static function getnTexImage(target:Int, level:Int, format:Int, type:Int, bufSize:Int, pixels:DataPointer):Void return ExtensionsNative.getnTexImage(target, level, format, type, bufSize, pixels);
    static function getnTexImageARB(target:Int, level:Int, format:Int, type:Int, bufSize:Int, img:DataPointer):Void return ExtensionsNative.getnTexImageARB(target, level, format, type, bufSize, img);
    static function getnUniformdv(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformdv(program, location, bufSize, params);
    static function getnUniformdvARB(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformdvARB(program, location, bufSize, params);
    static function getnUniformfv(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformfv(program, location, bufSize, params);
    static function getnUniformfvARB(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformfvARB(program, location, bufSize, params);
    static function getnUniformfvEXT(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformfvEXT(program, location, bufSize, params);
    static function getnUniformfvKHR(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformfvKHR(program, location, bufSize, params);
    static function getnUniformi64vARB(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformi64vARB(program, location, bufSize, params);
    static function getnUniformiv(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformiv(program, location, bufSize, params);
    static function getnUniformivARB(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformivARB(program, location, bufSize, params);
    static function getnUniformivEXT(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformivEXT(program, location, bufSize, params);
    static function getnUniformivKHR(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformivKHR(program, location, bufSize, params);
    static function getnUniformui64vARB(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformui64vARB(program, location, bufSize, params);
    static function getnUniformuiv(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformuiv(program, location, bufSize, params);
    static function getnUniformuivARB(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformuivARB(program, location, bufSize, params);
    static function getnUniformuivKHR(program:Int, location:Int, bufSize:Int, params:DataPointer):Void return ExtensionsNative.getnUniformuivKHR(program, location, bufSize, params);
    static function globalAlphaFactorbSUN(factor:Int):Void return ExtensionsNative.globalAlphaFactorbSUN(factor);
    static function globalAlphaFactordSUN(factor:DataPointer):Void return ExtensionsNative.globalAlphaFactordSUN(factor);
    static function globalAlphaFactorfSUN(factor:Float):Void return ExtensionsNative.globalAlphaFactorfSUN(factor);
    static function globalAlphaFactoriSUN(factor:Int):Void return ExtensionsNative.globalAlphaFactoriSUN(factor);
    static function globalAlphaFactorsSUN(factor:Int):Void return ExtensionsNative.globalAlphaFactorsSUN(factor);
    static function globalAlphaFactorubSUN(factor:Int):Void return ExtensionsNative.globalAlphaFactorubSUN(factor);
    static function globalAlphaFactoruiSUN(factor:Int):Void return ExtensionsNative.globalAlphaFactoruiSUN(factor);
    static function globalAlphaFactorusSUN(factor:Int):Void return ExtensionsNative.globalAlphaFactorusSUN(factor);
    /**
    * - #### Purpose:
    * specify implementation-specific hints
    * ### Description:
    * Certain aspects of GL behavior, when there is room for interpretation, can be controlled with hints. A hint is specified with two arguments. **target** is a symbolic constant indicating the behavior to be controlled, and **mode** is another symbolic constant indicating the desired behavior. The initial value for each **target** is `GL_DONT_CARE`. **mode** can be one of the following:
    * 
    * *``GL_FASTEST``* The most efficient option should be chosen.
    * 
    * *``GL_NICEST``* The most correct, or highest quality, option should be chosen.
    * 
    * *``GL_DONT_CARE``* No preference.
    * 
    * Though the implementation aspects that can be hinted are well defined, the interpretation of the hints depends on the implementation. The hint aspects that can be specified with **target**, along with suggested semantics, are as follows:
    * 
    * *``GL_FRAGMENT_SHADER_DERIVATIVE_HINT``* Indicates the accuracy of the derivative calculation for the GL shading language fragment processing built-in functions: `dFdx`, `dFdy`, and `fwidth`.
    * 
    * *``GL_LINE_SMOOTH_HINT``* Indicates the sampling quality of antialiased lines. If a larger filter function is applied, hinting `GL_NICEST` can result in more pixel fragments being generated during rasterization.
    * 
    * *``GL_POLYGON_SMOOTH_HINT``* Indicates the sampling quality of antialiased polygons. Hinting `GL_NICEST` can result in more pixel fragments being generated during rasterization, if a larger filter function is applied.
    * 
    * *``GL_TEXTURE_COMPRESSION_HINT``* Indicates the quality and performance of the compressing texture images. Hinting `GL_FASTEST` indicates that texture images should be compressed as quickly as possible, while `GL_NICEST` indicates that texture images should be compressed with as little image quality loss as possible. `GL_NICEST` should be selected if the texture is to be retrieved by **`glGetCompressedTexImage`** for reuse.
    * 
    * 
    * ### Notes:
    * The interpretation of hints depends on the implementation. Some implementations ignore **glHint** settings.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if either **target** or **mode** is not an accepted value.
    * 
    * @param target Specifies a symbolic constant indicating the behavior to be controlled. `GL_LINE_SMOOTH_HINT`, `GL_POLYGON_SMOOTH_HINT`, `GL_TEXTURE_COMPRESSION_HINT`, and `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` are accepted.
    * @param mode Specifies a symbolic constant indicating the desired behavior. `GL_FASTEST`, `GL_NICEST`, and `GL_DONT_CARE` are accepted.

    * @see **/
    static function hint(target:Int, mode:Int):Void return ExtensionsNative.hint(target, mode);
    static function hintPGI(target:Int, mode:Int):Void return ExtensionsNative.hintPGI(target, mode);
    static function histogram(target:Int, width:Int, in_ternalformat:Int, sin_k:Bool):Void return ExtensionsNative.histogram(target, width, in_ternalformat, sin_k);
    static function histogramEXT(target:Int, width:Int, in_ternalformat:Int, sin_k:Bool):Void return ExtensionsNative.histogramEXT(target, width, in_ternalformat, sin_k);
    static function iglooInterfaceSGIX(pname:Int, params:DataPointer):Void return ExtensionsNative.iglooInterfaceSGIX(pname, params);
    static function imageTransformParameterfHP(target:Int, pname:Int, param:Float):Void return ExtensionsNative.imageTransformParameterfHP(target, pname, param);
    static function imageTransformParameterfvHP(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.imageTransformParameterfvHP(target, pname, params);
    static function imageTransformParameteriHP(target:Int, pname:Int, param:Int):Void return ExtensionsNative.imageTransformParameteriHP(target, pname, param);
    static function imageTransformParameterivHP(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.imageTransformParameterivHP(target, pname, params);
    static function importMemoryFdEXT(memory:Int, size:Int, handleType:Int, fd:Int):Void return ExtensionsNative.importMemoryFdEXT(memory, size, handleType, fd);
    static function importMemoryWin32HandleEXT(memory:Int, size:Int, handleType:Int, handle:DataPointer):Void return ExtensionsNative.importMemoryWin32HandleEXT(memory, size, handleType, handle);
    static function importMemoryWin32NameEXT(memory:Int, size:Int, handleType:Int, name:DataPointer):Void return ExtensionsNative.importMemoryWin32NameEXT(memory, size, handleType, name);
    static function importSemaphoreFdEXT(semaphore:Int, handleType:Int, fd:Int):Void return ExtensionsNative.importSemaphoreFdEXT(semaphore, handleType, fd);
    static function importSemaphoreWin32HandleEXT(semaphore:Int, handleType:Int, handle:DataPointer):Void return ExtensionsNative.importSemaphoreWin32HandleEXT(semaphore, handleType, handle);
    static function importSemaphoreWin32NameEXT(semaphore:Int, handleType:Int, name:DataPointer):Void return ExtensionsNative.importSemaphoreWin32NameEXT(semaphore, handleType, name);
    static function importSyncEXT(external_sync_type:Int, external_sync:Int, flags:Int):DataPointer return ExtensionsNative.importSyncEXT(external_sync_type, external_sync, flags);
    static function indexFormatNV(type:Int, stride:Int):Void return ExtensionsNative.indexFormatNV(type, stride);
    static function indexFuncEXT(func:Int, ref:Float):Void return ExtensionsNative.indexFuncEXT(func, ref);
    static function indexMask(mask:Int):Void return ExtensionsNative.indexMask(mask);
    static function indexMaterialEXT(face:Int, mode:Int):Void return ExtensionsNative.indexMaterialEXT(face, mode);
    static function indexPointer(type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.indexPointer(type, stride, poin_ter);
    static function indexPointerEXT(type:Int, stride:Int, count:Int, poin_ter:DataPointer):Void return ExtensionsNative.indexPointerEXT(type, stride, count, poin_ter);
    static function indexPointerListIBM(type:Int, stride:Int, poin_ter:DataPointer, ptrstride:Int):Void return ExtensionsNative.indexPointerListIBM(type, stride, poin_ter, ptrstride);
    static function indexd(c:DataPointer):Void return ExtensionsNative.indexd(c);
    static function indexdv(c:DataPointer):Void return ExtensionsNative.indexdv(c);
    static function indexf(c:Float):Void return ExtensionsNative.indexf(c);
    static function indexfv(c:DataPointer):Void return ExtensionsNative.indexfv(c);
    static function indexi(c:Int):Void return ExtensionsNative.indexi(c);
    static function indexiv(c:DataPointer):Void return ExtensionsNative.indexiv(c);
    static function indexs(c:Int):Void return ExtensionsNative.indexs(c);
    static function indexsv(c:DataPointer):Void return ExtensionsNative.indexsv(c);
    static function indexub(c:Int):Void return ExtensionsNative.indexub(c);
    static function indexubv(c:DataPointer):Void return ExtensionsNative.indexubv(c);
    static function indexxOES(component:Int):Void return ExtensionsNative.indexxOES(component);
    static function indexxvOES(component:DataPointer):Void return ExtensionsNative.indexxvOES(component);
    static function initNames():Void return ExtensionsNative.initNames();
    static function insertComponentEXT(res:Int, src:Int, num:Int):Void return ExtensionsNative.insertComponentEXT(res, src, num);
    static function insertEventMarkerEXT(length:Int, marker:String):Void return ExtensionsNative.insertEventMarkerEXT(length, marker);
    static function instrumentsBufferSGIX(size:Int, buffer:DataPointer):Void return ExtensionsNative.instrumentsBufferSGIX(size, buffer);
    static function interleavedArrays(format:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.interleavedArrays(format, stride, poin_ter);
    static function interpolatePathsNV(resultPath:Int, pathA:Int, pathB:Int, weight:Float):Void return ExtensionsNative.interpolatePathsNV(resultPath, pathA, pathB, weight);
    /**
    * - #### Purpose:
    * invalidate the content of a buffer object's data store
    * ### Description:
    * **glInvalidateBufferData** invalidates all of the content of the data store of a buffer object. After invalidation, the content of the buffer's data store becomes undefined.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **buffer** is not the name of an existing buffer object.
    * 
    * `GL_INVALID_OPERATION` is generated if any part of **buffer** is currently mapped.
    * 
    * @param buffer The name of a buffer object whose data store to invalidate.

    * @see **`glInvalidateTexSubImage`**,, **`glInvalidateTexImage`**, **`glInvalidateBufferSubData`**, **`glInvalidateFramebuffer`**, **`glInvalidateSubFramebuffer`**.

    **/
    static function invalidateBufferData(buffer:Int):Void return ExtensionsNative.invalidateBufferData(buffer);
    /**
    * - #### Purpose:
    * invalidate a region of a buffer object's data store
    * ### Description:
    * **glInvalidateBufferSubData** invalidates all or part of the content of the data store of a buffer object. After invalidation, the content of the specified range of the buffer's data store becomes undefined. The start of the range is given by **offset** and its size is given by **length**, both measured in basic machine units.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **offset** or **length** is negative, or if **offset** + **length** is greater than the value of `GL_BUFFER_SIZE` for **buffer**.
    * 
    * `GL_INVALID_VALUE` is generated if **buffer** is not the name of an existing buffer object.
    * 
    * `GL_INVALID_OPERATION` is generated if any part of **buffer** is currently mapped.
    * 
    * @param buffer The name of a buffer object, a subrange of whose data store to invalidate.
    * @param offset The offset within the buffer's data store of the start of the range to be invalidated.
    * @param length The length of the range within the buffer's data store to be invalidated.

    * @see **`glInvalidateTexSubImage`**,, **`glInvalidateTexImage`**, **`glInvalidateBufferData`**, **`glInvalidateFramebuffer`**, **`glInvalidateSubFramebuffer`**.

    **/
    static function invalidateBufferSubData(buffer:Int, offset:Int, length:Int):Void return ExtensionsNative.invalidateBufferSubData(buffer, offset, length);
    /**
    * - #### Purpose:
    * invalidate the content of some or all of a framebuffer's attachments
    * ### Description:
    * **glInvalidateFramebuffer** and **glInvalidateNamedFramebufferData** invalidate the entire contents of a specified set of attachments of a framebuffer.
    * 
    * For **glInvalidateFramebuffer**, the framebuffer object is that bound to **target**. **target** must be `GL_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_DRAW_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Default framebuffers may also be invalidated if bound to **target**.
    * 
    * For **glInvalidateNamedFramebufferData**, **framebuffer** is the name of the framebuffer object. If **framebuffer** is zero, the default draw framebuffer is affected.
    * 
    * The set of attachments whose contents are to be invalidated are specified in the **attachments** array, which contains **numAttachments** elements.
    * 
    * If the specified framebuffer is a framebuffer object, each element of **attachments** must be one of `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` `GL_DEPTH_STENCIL_ATTACHMENT`, or `GL_COLOR_ATTACHMENT`i, where i is between zero and the value of `GL_MAX_FRAMEBUFFER_ATTACHMENTS` minus one.
    * 
    * If the specified framebuffer is a default framebuffer, each element of **attachments** must be one of `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_AUX`i, `GL_ACCUM`, `GL_COLOR`, `GL_DEPTH`, or `GL_STENCIL`. `GL_COLOR`, is treated as `GL_BACK_LEFT` for a double-buffered context and `GL_FRONT_LEFT` for a single-buffered context. The other attachments identify the corresponding specific buffer.
    * 
    * The entire contents of each specified attachment become undefined after execution of **glInvalidateFramebuffer** or **glInvalidateNamedFramebufferData**.
    * 
    * If the framebuffer object is not complete, **glInvalidateFramebuffer** and **glInvalidateNamedFramebufferData** may be ignored. This is not an error.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glInvalidateFramebuffer** if **target** is not one of the accepted framebuffer targets.
    * 
    * `GL_INVALID_OPERATION` is generated by **glInvalidateNamedFramebufferData** if **framebuffer** is not zero or the name of an existing framebuffer object.
    * 
    * `GL_INVALID_VALUE` is generated if **numAttachments** is negative.
    * 
    * `GL_INVALID_ENUM` is generated if any element of **attachments** is not one of the accepted framebuffer attachment points, as described above.
    * 
    * `GL_INVALID_OPERATION` is generated if element of **attachments** is `GL_COLOR_ATTACHMENT`m where m is greater than or equal to the value of `GL_MAX_COLOR_ATTACHMENTS`.
    * 
    * @param target Specifies the target to which the framebuffer object is attached for **glInvalidateFramebuffer**.
    * @param framebuffer Specifies the name of the framebuffer object for **glInvalidateNamedFramebufferData**.
    * @param numAttachments Specifies the number of entries in the **attachments** array.
    * @param attachments Specifies a pointer to an array identifying the attachments to be invalidated.

    * @see **`glInvalidateTexSubImage`**, **`glInvalidateTexImage`**, **`glInvalidateBufferSubData`**, **`glInvalidateBufferData`**, **`glInvalidateSubFramebuffer`**.

    **/
    static function invalidateFramebuffer(target:Int, numAttachments:Int, attachments:DataPointer):Void return ExtensionsNative.invalidateFramebuffer(target, numAttachments, attachments);
    static function invalidateNamedFramebufferData(framebuffer:Int, numAttachments:Int, attachments:DataPointer):Void return ExtensionsNative.invalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
    static function invalidateNamedFramebufferSubData(framebuffer:Int, numAttachments:Int, attachments:DataPointer, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.invalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height);
    /**
    * - #### Purpose:
    * invalidate the content of a region of some or all of a framebuffer's attachments
    * ### Description:
    * **glInvalidateSubFramebuffer** and **glInvalidateNamedFramebufferSubData** invalidate the contents of a specified region of a specified set of attachments of a framebuffer.
    * 
    * For **glInvalidateSubFramebuffer**, the framebuffer object is that bound to **target**, which must be one of `GL_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_DRAW_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Default framebuffers may also be invalidated if bound to **target**.
    * 
    * For **glInvalidateNamedFramebufferSubData**, **framebuffer** is the name of the framebuffer object. If **framebuffer** is zero, the default draw framebuffer is affected.
    * 
    * The set of attachments of which a region is to be invalidated are specified in the **attachments** array, which contains **numAttachments** elements.
    * 
    * If the specified framebuffer is a framebuffer object, each element of **attachments** must be one of `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` `GL_DEPTH_STENCIL_ATTACHMENT`, or `GL_COLOR_ATTACHMENT`i, where i is between zero and the value of `GL_MAX_FRAMEBUFFER_ATTACHMENTS` minus one.
    * 
    * If the specified framebuffer is a default framebuffer, each element of **attachments** must be one of `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_AUX`i, `GL_ACCUM`, `GL_COLOR`, `GL_DEPTH`, or `GL_STENCIL`. `GL_COLOR`, is treated as `GL_BACK_LEFT` for a double-buffered context and `GL_FRONT_LEFT` for a single-buffered context. The other attachments identify the corresponding specific buffer.
    * 
    * The contents of the specified region of each specified attachment become undefined after execution of **glInvalidateSubFramebuffer** or **glInvalidateNamedFramebufferSubData**. The region to be invalidated is specified by **x**, **y**, **width** and **height** where **x** and **y** give the offset from the origin (with lower-left corner at $(0,0)$) and **width** and **height** are the width and height, respectively, of the region. Any pixels lying outside of the window allocated to the current GL context (for the default framebuffer), or outside of the attachments of the framebuffer object, are ignored. If the framebuffer object is not complete, these commands may be ignored.
    * 
    * If the framebuffer object is not complete, **glInvalidateSubFramebuffer** and **glInvalidateNamedFramebufferSubData** may be ignored. This is not an error.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` by **glInvalidateSubFramebuffer** if **target** is not one of the accepted framebuffer targets.
    * 
    * `GL_INVALID_OPERATION` by **glInvalidateNamedFramebufferSubData** if **framebuffer** is not zero of the name of an existing framebuffer object.
    * 
    * `GL_INVALID_VALUE` is generated if **numAttachments**, **width** or **height** is negative.
    * 
    * `GL_INVALID_ENUM` is generated if any element of **attachments** is not one of the accepted framebuffer attachment points, as described above.
    * 
    * `GL_INVALID_OPERATION` is generated if element of **attachments** is `GL_COLOR_ATTACHMENT`m where m is greater than or equal to the value of `GL_MAX_COLOR_ATTACHMENTS`.
    * 
    * @param target Specifies the target to which the framebuffer object is attached for **glInvalidateSubFramebuffer**.
    * @param framebuffer Specifies the name of the framebuffer object for **glInvalidateNamedFramebufferSubData**.
    * @param numAttachments Specifies the number of entries in the **attachments** array.
    * @param attachments Specifies a pointer to an array identifying the attachments to be invalidated.
    * @param x Specifies the X offset of the region to be invalidated.
    * @param y Specifies the Y offset of the region to be invalidated.
    * @param width Specifies the width of the region to be invalidated.
    * @param height Specifies the height of the region to be invalidated.

    * @see **`glInvalidateTexSubImage`**, **`glInvalidateTexImage`**, **`glInvalidateBufferSubData`**, **`glInvalidateBufferData`**, **`glInvalidateFramebuffer`**.

    **/
    static function invalidateSubFramebuffer(target:Int, numAttachments:Int, attachments:DataPointer, x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.invalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
    /**
    * - #### Purpose:
    * invalidate the entirety a texture image
    * ### Description:
    * **glInvalidateTexSubImage** invalidates all of a texture image. **texture** and **level** indicated which texture image is being invalidated. After this command, data in the texture image has undefined values.
    * 
    * **level** must be greater than or equal to zero and be less than the base 2 logarithm of the maximum texture width, height, or depth.
    * 
    * For textures of targets `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, level must be zero.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **level** is less than zero or if it is greater or equal to the base 2 logarithm of the maximum texture width, height, or depth.
    * 
    * `GL_INVALID_VALUE` is generated if the target of **texture** is any of `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` and **level** is not zero.
    * 
    * `GL_INVALID_VALUE` is generated if **texture** is not the name of an existing texture object.
    * 
    * @param texture The name of a texture object to invalidate.
    * @param level The level of detail of the texture object to invalidate.

    * @see **`glInvalidateTexSubImage`**,, **`glInvalidateBufferSubData`**, **`glInvalidateBufferData`**, **`glInvalidateFramebuffer`**, **`glInvalidateSubFramebuffer`**.

    **/
    static function invalidateTexImage(texture:Int, level:Int):Void return ExtensionsNative.invalidateTexImage(texture, level);
    /**
    * - #### Purpose:
    * invalidate a region of a texture image
    * ### Description:
    * **glInvalidateTexSubImage** invalidates all or part of a texture image. **texture** and **level** indicated which texture image is being invalidated. After this command, data in that subregion have undefined values. **xoffset**, **yoffset**, **zoffset**, **width**, **height**, and **depth** are interpreted as they are in **`glTexSubImage3D`**. For texture targets that don't have certain dimensions, this command treats those dimensions as having a size of 1. For example, to invalidate a portion of a two- dimensional texture, the application would use **zoffset** equal to zero and **depth** equal to one. Cube map textures are treated as an array of six slices in the z-dimension, where a value of **zoffset** is interpreted as specifying face `GL_TEXTURE_CUBE_MAP_POSITIVE_X` + **zoffset**.
    * 
    * **level** must be greater than or equal to zero and be less than the base 2 logarithm of the maximum texture width, height, or depth. **xoffset**, **yoffset** and **zoffset** must be greater than or equal to zero and be less than the width, height or depth of the image, respectively. Furthermore, **xoffset** + **width**, **yoffset** + **height**, and **zoffset** + **depth** must be less than or equal to the width, height or depth of the image, respectively.
    * 
    * For textures of targets `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, level must be zero.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **xoffset**, **yoffset** or **zoffset** is less than zero, or if any of them is greater than the size of the image in the corresponding dimension.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than zero or if it is greater or equal to the base 2 logarithm of the maximum texture width, height, or depth.
    * 
    * `GL_INVALID_VALUE` is generated if the target of **texture** is any of `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` and **level** is not zero.
    * 
    * `GL_INVALID_VALUE` is generated if **texture** is not the name of an existing texture object.
    * 
    * @param texture The name of a texture object a subregion of which to invalidate.
    * @param level The level of detail of the texture object within which the region resides.
    * @param xoffset The X offset of the region to be invalidated.
    * @param yoffset The Y offset of the region to be invalidated.
    * @param zoffset The Z offset of the region to be invalidated.
    * @param width The width of the region to be invalidated.
    * @param height The height of the region to be invalidated.
    * @param depth The depth of the region to be invalidated.

    * @see **`glInvalidateTexImage`**,, **`glInvalidateBufferSubData`**, **`glInvalidateBufferData`**, **`glInvalidateFramebuffer`**, **`glInvalidateSubFramebuffer`**.

    **/
    static function invalidateTexSubImage(texture:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int):Void return ExtensionsNative.invalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
    static function isAsyncMarkerSGIX(marker:Int):Bool return ExtensionsNative.isAsyncMarkerSGIX(marker);
    /**
    * - #### Purpose:
    * determine if a name corresponds to a buffer object
    * ### Description:
    * **glIsBuffer** returns `GL_TRUE` if **buffer** is currently the name of a buffer object. If **buffer** is zero, or is a non-zero value that is not currently the name of a buffer object, or if an error occurs, **glIsBuffer** returns `GL_FALSE`.
    * 
    * A name returned by **`glGenBuffers`**, but not yet associated with a buffer object by calling **`glBindBuffer`**, is not the name of a buffer object.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param buffer Specifies a value that may be the name of a buffer object.

    * @see **`glBindBuffer`**, **`glDeleteBuffers`**, **`glGenBuffers`**, **`glGet`**

    **/
    static function isBuffer(buffer:Int):Bool return ExtensionsNative.isBuffer(buffer);
    static function isBufferARB(buffer:Int):Bool return ExtensionsNative.isBufferARB(buffer);
    static function isBufferResidentNV(target:Int):Bool return ExtensionsNative.isBufferResidentNV(target);
    static function isCommandListNV(list:Int):Bool return ExtensionsNative.isCommandListNV(list);
    /**
    * - #### Purpose:
    * test whether a capability is enabled
    * ### Description:
    * **glIsEnabled** returns `GL_TRUE` if **cap** is an enabled capability and returns `GL_FALSE` otherwise. Boolean states that are indexed may be tested with **glIsEnabledi**. For **glIsEnabledi**, **index** specifies the index of the capability to test. **index** must be between zero and the count of indexed capabilities for **cap**. Initially all capabilities except `GL_DITHER` are disabled; `GL_DITHER` is initially enabled.
    * 
    * The following capabilities are accepted for **cap**:
    * 
    * 
    * 
    * 
    * 
    * 
    * ### Notes:
    * If an error is generated, **glIsEnabled** and **glIsEnabledi** return `GL_FALSE`.
    * 
    * `GL_PRIMITIVE_RESTART_FIXED_INDEX` are available only if the GL version is 4.3 or greater.
    * 
    * `GL_DEBUG_OUTPUT` and `GL_DEBUG_OUTPUT_SYNCHRONOUS` are available only if the GL version is 4.3 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **cap** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated by **glIsEnabledi** if **index** is outside the valid range for the indexed state **cap**.
    * 
    * @param cap Specifies a symbolic constant indicating a GL capability.
    * @param index Specifies the index of the capability.

    * @see **`glEnable`**, **glDisable**, **`glGet`**

    **/
    static function isEnabled(cap:Int):Bool return ExtensionsNative.isEnabled(cap);
    static function isEnabledIndexedEXT(target:Int, in_dex:Int):Bool return ExtensionsNative.isEnabledIndexedEXT(target, in_dex);
    static function isEnabledi(target:Int, in_dex:Int):Bool return ExtensionsNative.isEnabledi(target, in_dex);
    static function isEnablediEXT(target:Int, in_dex:Int):Bool return ExtensionsNative.isEnablediEXT(target, in_dex);
    static function isEnablediNV(target:Int, in_dex:Int):Bool return ExtensionsNative.isEnablediNV(target, in_dex);
    static function isEnablediOES(target:Int, in_dex:Int):Bool return ExtensionsNative.isEnablediOES(target, in_dex);
    static function isFenceAPPLE(fence:Int):Bool return ExtensionsNative.isFenceAPPLE(fence);
    static function isFenceNV(fence:Int):Bool return ExtensionsNative.isFenceNV(fence);
    /**
    * - #### Purpose:
    * determine if a name corresponds to a framebuffer object
    * ### Description:
    * **glIsFramebuffer** returns `GL_TRUE` if **framebuffer** is currently the name of a framebuffer object. If **framebuffer** is zero, or if `framebuffer` is not the name of a framebuffer object, or if an error occurs, **glIsFramebuffer** returns `GL_FALSE`. If **framebuffer** is a name returned by **`glGenFramebuffers`**, by that has not yet been bound through a call to **`glBindFramebuffer`**, then the name is not a framebuffer object and **glIsFramebuffer** returns `GL_FALSE`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param framebuffer Specifies a value that may be the name of a framebuffer object.

    * @see **`glGenFramebuffers`**, **`glBindFramebuffer`**, **`glDeleteFramebuffers`**

    **/
    static function isFramebuffer(framebuffer:Int):Bool return ExtensionsNative.isFramebuffer(framebuffer);
    static function isFramebufferEXT(framebuffer:Int):Bool return ExtensionsNative.isFramebufferEXT(framebuffer);
    static function isFramebufferOES(framebuffer:Int):Bool return ExtensionsNative.isFramebufferOES(framebuffer);
    static function isImageHandleResidentARB(handle:Int):Bool return ExtensionsNative.isImageHandleResidentARB(handle);
    static function isImageHandleResidentNV(handle:Int):Bool return ExtensionsNative.isImageHandleResidentNV(handle);
    static function isList(list:Int):Bool return ExtensionsNative.isList(list);
    static function isMemoryObjectEXT(memoryObject:Int):Bool return ExtensionsNative.isMemoryObjectEXT(memoryObject);
    static function isNameAMD(identifier:Int, name:Int):Bool return ExtensionsNative.isNameAMD(identifier, name);
    static function isNamedBufferResidentNV(buffer:Int):Bool return ExtensionsNative.isNamedBufferResidentNV(buffer);
    static function isNamedStringARB(namelen:Int, name:String):Bool return ExtensionsNative.isNamedStringARB(namelen, name);
    static function isObjectBufferATI(buffer:Int):Bool return ExtensionsNative.isObjectBufferATI(buffer);
    static function isOcclusionQueryNV(id:Int):Bool return ExtensionsNative.isOcclusionQueryNV(id);
    static function isPathNV(path:Int):Bool return ExtensionsNative.isPathNV(path);
    static function isPointInFillPathNV(path:Int, mask:Int, x:Float, y:Float):Bool return ExtensionsNative.isPointInFillPathNV(path, mask, x, y);
    static function isPointInStrokePathNV(path:Int, x:Float, y:Float):Bool return ExtensionsNative.isPointInStrokePathNV(path, x, y);
    /**
    * - #### Purpose:
    * Determines if a name corresponds to a program object
    * ### Description:
    * **glIsProgram** returns `GL_TRUE` if **program** is the name of a program object previously created with **`glCreateProgram`** and not yet deleted with **`glDeleteProgram`**. If **program** is zero or a non-zero value that is not the name of a program object, or if an error occurs, **glIsProgram** returns `GL_FALSE`.
    * 
    * 
    * ### Notes:
    * No error is generated if **program** is not a valid program object name.
    * 
    * A program object marked for deletion with **`glDeleteProgram`** but still in use as part of current rendering state is still considered a program object and **glIsProgram** will return `GL_TRUE`.
    * 
    * 
    * ### Errors:
    * @param program Specifies a potential program object.

    * @see **`glAttachShader`**, **`glBindAttribLocation`**, **`glCreateProgram`**, **`glDeleteProgram`**, **`glDetachShader`**, **`glLinkProgram`**, **`glUniform`**, **`glUseProgram`**, **`glValidateProgram`**

    **/
    static function isProgram(program:Int):Bool return ExtensionsNative.isProgram(program);
    static function isProgramARB(program:Int):Bool return ExtensionsNative.isProgramARB(program);
    static function isProgramNV(id:Int):Bool return ExtensionsNative.isProgramNV(id);
    /**
    * - #### Purpose:
    * determine if a name corresponds to a program pipeline object
    * ### Description:
    * **glIsProgramPipeline** returns `GL_TRUE` if **pipeline** is currently the name of a program pipeline object. If **pipeline** is zero, or if `pipeline` is not the name of a program pipeline object, or if an error occurs, **glIsProgramPipeline** returns `GL_FALSE`. If **pipeline** is a name returned by **`glGenProgramPipelines`**, but that has not yet been bound through a call to **`glBindProgramPipeline`**, then the name is not a program pipeline object and **glIsProgramPipeline** returns `GL_FALSE`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param pipeline Specifies a value that may be the name of a program pipeline object.

    * @see **`glGenProgramPipelines`**, **`glBindProgramPipeline`**, **`glDeleteProgramPipelines`**

    **/
    static function isProgramPipeline(pipelin_e:Int):Bool return ExtensionsNative.isProgramPipeline(pipelin_e);
    static function isProgramPipelineEXT(pipelin_e:Int):Bool return ExtensionsNative.isProgramPipelineEXT(pipelin_e);
    /**
    * - #### Purpose:
    * determine if a name corresponds to a query object
    * ### Description:
    * **glIsQuery** returns `GL_TRUE` if **id** is currently the name of a query object. If **id** is zero, or is a non-zero value that is not currently the name of a query object, or if an error occurs, **glIsQuery** returns `GL_FALSE`.
    * 
    * A name returned by **`glGenQueries`**, but not yet associated with a query object by calling **`glBeginQuery`**, is not the name of a query object.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param id Specifies a value that may be the name of a query object.

    * @see **`glBeginQuery`**, **`glDeleteQueries`**, **glEndQuery**, **`glGenQueries`**

    **/
    static function isQuery(id:Int):Bool return ExtensionsNative.isQuery(id);
    static function isQueryARB(id:Int):Bool return ExtensionsNative.isQueryARB(id);
    static function isQueryEXT(id:Int):Bool return ExtensionsNative.isQueryEXT(id);
    /**
    * - #### Purpose:
    * determine if a name corresponds to a renderbuffer object
    * ### Description:
    * **glIsRenderbuffer** returns `GL_TRUE` if **renderbuffer** is currently the name of a renderbuffer object. If **renderbuffer** is zero, or if **renderbuffer** is not the name of a renderbuffer object, or if an error occurs, **glIsRenderbuffer** returns `GL_FALSE`. If **renderbuffer** is a name returned by **`glGenRenderbuffers`**, by that has not yet been bound through a call to **`glBindRenderbuffer`** or **`glFramebufferRenderbuffer`**, then the name is not a renderbuffer object and **glIsRenderbuffer** returns `GL_FALSE`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param renderbuffer Specifies a value that may be the name of a renderbuffer object.

    * @see **`glGenRenderbuffers`**, **`glBindRenderbuffer`**, **`glFramebufferRenderbuffer`**, **`glDeleteRenderbuffers`**

    **/
    static function isRenderbuffer(renderbuffer:Int):Bool return ExtensionsNative.isRenderbuffer(renderbuffer);
    static function isRenderbufferEXT(renderbuffer:Int):Bool return ExtensionsNative.isRenderbufferEXT(renderbuffer);
    static function isRenderbufferOES(renderbuffer:Int):Bool return ExtensionsNative.isRenderbufferOES(renderbuffer);
    static function isSemaphoreEXT(semaphore:Int):Bool return ExtensionsNative.isSemaphoreEXT(semaphore);
    /**
    * - #### Purpose:
    * determine if a name corresponds to a sampler object
    * ### Description:
    * **glIsSampler** returns `GL_TRUE` if **id** is currently the name of a sampler object. If **id** is zero, or is a non-zero value that is not currently the name of a sampler object, or if an error occurs, **glIsSampler** returns `GL_FALSE`.
    * 
    * A name returned by **`glGenSamplers`**, is the name of a sampler object.
    * 
    * 
    * ### Notes:
    * **glIsSampler** is available only if the GL version is 3.3 or higher.
    * 
    * 
    * ### Errors:
    * @param id Specifies a value that may be the name of a sampler object.

    * @see **`glGenSamplers`**, **`glBindSampler`**, **`glDeleteSamplers`**

    **/
    static function isSampler(sampler:Int):Bool return ExtensionsNative.isSampler(sampler);
    /**
    * - #### Purpose:
    * Determines if a name corresponds to a shader object
    * ### Description:
    * **glIsShader** returns `GL_TRUE` if **shader** is the name of a shader object previously created with **`glCreateShader`** and not yet deleted with **`glDeleteShader`**. If **shader** is zero or a non-zero value that is not the name of a shader object, or if an error occurs, **glIsShader** returns `GL_FALSE`.
    * 
    * 
    * ### Notes:
    * No error is generated if **shader** is not a valid shader object name.
    * 
    * A shader object marked for deletion with **`glDeleteShader`** but still attached to a program object is still considered a shader object and **glIsShader** will return `GL_TRUE`.
    * 
    * 
    * ### Errors:
    * @param shader Specifies a potential shader object.

    * @see **`glAttachShader`**, **`glCompileShader`**, **`glCreateShader`**, **`glDeleteShader`**, **`glDetachShader`**, **`glLinkProgram`**, **`glShaderSource`**

    **/
    static function isShader(shader:Int):Bool return ExtensionsNative.isShader(shader);
    static function isStateNV(state:Int):Bool return ExtensionsNative.isStateNV(state);
    /**
    * - #### Purpose:
    * determine if a name corresponds to a sync object
    * ### Description:
    * **glIsSync** returns `GL_TRUE` if **sync** is currently the name of a sync object. If **sync** is not the name of a sync object, or if an error occurs, **glIsSync** returns `GL_FALSE`. Note that zero is not the name of a sync object.
    * 
    * 
    * ### Notes:
    * **glIsSync** is available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * @param sync Specifies a value that may be the name of a sync object.

    * @see **`glFenceSync`**, **`glWaitSync`**, **`glClientWaitSync`**, **`glDeleteSync`**

    **/
    static function isSync(sync:DataPointer):Bool return ExtensionsNative.isSync(sync);
    static function isSyncAPPLE(sync:DataPointer):Bool return ExtensionsNative.isSyncAPPLE(sync);
    /**
    * - #### Purpose:
    * determine if a name corresponds to a texture
    * ### Description:
    * **glIsTexture** returns `GL_TRUE` if **texture** is currently the name of a texture. If **texture** is zero, or is a non-zero value that is not currently the name of a texture, or if an error occurs, **glIsTexture** returns `GL_FALSE`.
    * 
    * A name returned by **`glGenTextures`**, but not yet associated with a texture by calling **`glBindTexture`**, is not the name of a texture.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param texture Specifies a value that may be the name of a texture.

    * @see **`glBindTexture`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glDeleteTextures`**, **`glGenTextures`**, **`glGet`**, **`glGetTexParameter`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexParameter`**

    **/
    static function isTexture(texture:Int):Bool return ExtensionsNative.isTexture(texture);
    static function isTextureEXT(texture:Int):Bool return ExtensionsNative.isTextureEXT(texture);
    static function isTextureHandleResidentARB(handle:Int):Bool return ExtensionsNative.isTextureHandleResidentARB(handle);
    static function isTextureHandleResidentNV(handle:Int):Bool return ExtensionsNative.isTextureHandleResidentNV(handle);
    /**
    * - #### Purpose:
    * determine if a name corresponds to a transform feedback object
    * ### Description:
    * **glIsTransformFeedback** returns `GL_TRUE` if **id** is currently the name of a transform feedback object. If **id** is zero, or if `id` is not the name of a transform feedback object, or if an error occurs, **glIsTransformFeedback** returns `GL_FALSE`. If **id** is a name returned by **`glGenTransformFeedbacks`**, but that has not yet been bound through a call to **`glBindTransformFeedback`**, then the name is not a transform feedback object and **glIsTransformFeedback** returns `GL_FALSE`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param id Specifies a value that may be the name of a transform feedback object.

    * @see **`glGenTransformFeedbacks`**, **`glBindTransformFeedback`**, **`glDeleteTransformFeedbacks`**

    **/
    static function isTransformFeedback(id:Int):Bool return ExtensionsNative.isTransformFeedback(id);
    static function isTransformFeedbackNV(id:Int):Bool return ExtensionsNative.isTransformFeedbackNV(id);
    static function isVariantEnabledEXT(id:Int, cap:Int):Bool return ExtensionsNative.isVariantEnabledEXT(id, cap);
    /**
    * - #### Purpose:
    * determine if a name corresponds to a vertex array object
    * ### Description:
    * **glIsVertexArray** returns `GL_TRUE` if **array** is currently the name of a vertex array object. If **array** is zero, or if **array** is not the name of a vertex array object, or if an error occurs, **glIsVertexArray** returns `GL_FALSE`. If **array** is a name returned by **`glGenVertexArrays`**, by that has not yet been bound through a call to **`glBindVertexArray`**, then the name is not a vertex array object and **glIsVertexArray** returns `GL_FALSE`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param array Specifies a value that may be the name of a vertex array object.

    * @see **`glGenVertexArrays`**, **`glBindVertexArray`**, **`glDeleteVertexArrays`**

    **/
    static function isVertexArray(array:Int):Bool return ExtensionsNative.isVertexArray(array);
    static function isVertexArrayAPPLE(array:Int):Bool return ExtensionsNative.isVertexArrayAPPLE(array);
    static function isVertexArrayOES(array:Int):Bool return ExtensionsNative.isVertexArrayOES(array);
    static function isVertexAttribEnabledAPPLE(in_dex:Int, pname:Int):Bool return ExtensionsNative.isVertexAttribEnabledAPPLE(in_dex, pname);
    static function lGPUCopyImageSubDataNVX(sourceGpu:Int, destin_ationGpuMask:Int, srcName:Int, srcTarget:Int, srcLevel:Int, srcX:Int, srxY:Int, srcZ:Int, dstName:Int, dstTarget:Int, dstLevel:Int, dstX:Int, dstY:Int, dstZ:Int, width:Int, height:Int, depth:Int):Void return ExtensionsNative.lGPUCopyImageSubDataNVX(sourceGpu, destin_ationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    static function lGPUInterlockNVX():Void return ExtensionsNative.lGPUInterlockNVX();
    static function lGPUNamedBufferSubDataNVX(gpuMask:Int, buffer:Int, offset:Int, size:Int, data:DataPointer):Void return ExtensionsNative.lGPUNamedBufferSubDataNVX(gpuMask, buffer, offset, size, data);
    static function labelObjectEXT(type:Int, object:Int, length:Int, label:String):Void return ExtensionsNative.labelObjectEXT(type, object, length, label);
    static function lightEnviSGIX(pname:Int, param:Int):Void return ExtensionsNative.lightEnviSGIX(pname, param);
    static function lightModelf(pname:Int, param:Float):Void return ExtensionsNative.lightModelf(pname, param);
    static function lightModelfv(pname:Int, params:DataPointer):Void return ExtensionsNative.lightModelfv(pname, params);
    static function lightModeli(pname:Int, param:Int):Void return ExtensionsNative.lightModeli(pname, param);
    static function lightModeliv(pname:Int, params:DataPointer):Void return ExtensionsNative.lightModeliv(pname, params);
    static function lightModelx(pname:Int, param:Int):Void return ExtensionsNative.lightModelx(pname, param);
    static function lightModelxOES(pname:Int, param:Int):Void return ExtensionsNative.lightModelxOES(pname, param);
    static function lightModelxv(pname:Int, param:DataPointer):Void return ExtensionsNative.lightModelxv(pname, param);
    static function lightModelxvOES(pname:Int, param:DataPointer):Void return ExtensionsNative.lightModelxvOES(pname, param);
    static function lightf(light:Int, pname:Int, param:Float):Void return ExtensionsNative.lightf(light, pname, param);
    static function lightfv(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.lightfv(light, pname, params);
    static function lighti(light:Int, pname:Int, param:Int):Void return ExtensionsNative.lighti(light, pname, param);
    static function lightiv(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.lightiv(light, pname, params);
    static function lightx(light:Int, pname:Int, param:Int):Void return ExtensionsNative.lightx(light, pname, param);
    static function lightxOES(light:Int, pname:Int, param:Int):Void return ExtensionsNative.lightxOES(light, pname, param);
    static function lightxv(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.lightxv(light, pname, params);
    static function lightxvOES(light:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.lightxvOES(light, pname, params);
    static function lineStipple(factor:Int, pattern:Int):Void return ExtensionsNative.lineStipple(factor, pattern);
    /**
    * - #### Purpose:
    * specify the width of rasterized lines
    * ### Description:
    * **glLineWidth** specifies the rasterized width of both aliased and antialiased lines. Using a line width other than 1 has different effects, depending on whether line antialiasing is enabled. To enable and disable line antialiasing, call **`glEnable`** and **glDisable** with argument `GL_LINE_SMOOTH`. Line antialiasing is initially disabled.
    * 
    * If line antialiasing is disabled, the actual width is determined by rounding the supplied width to the nearest integer. (If the rounding results in the value 0, it is as if the line width were 1.) If = | DELTA y |:--> Δ x &gt;= Δ y, i pixels are filled in each column that is rasterized, where i is the rounded value of **width**. Otherwise, i pixels are filled in each row that is rasterized.
    * 
    * If antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the region lying within the rectangle having width equal to the current line width, length equal to the actual length of the line, and centered on the mathematical line segment. The coverage value for each fragment is the window coordinate area of the intersection of the rectangular region with the corresponding pixel square. This value is saved and used in the final rasterization step.
    * 
    * Not all widths can be supported when line antialiasing is enabled. If an unsupported width is requested, the nearest supported width is used. Only width 1 is guaranteed to be supported; others depend on the implementation. Likewise, there is a range for aliased line widths as well. To query the range of supported widths and the size difference between supported widths within the range, call **`glGet`** with arguments `GL_ALIASED_LINE_WIDTH_RANGE`, `GL_SMOOTH_LINE_WIDTH_RANGE`, and `GL_SMOOTH_LINE_WIDTH_GRANULARITY`.
    * 
    * 
    * ### Notes:
    * The line width specified by **glLineWidth** is always returned when `GL_LINE_WIDTH` is queried. Clamping and rounding for aliased and antialiased lines have no effect on the specified value.
    * 
    * Nonantialiased line width may be clamped to an implementation-dependent maximum. Call **`glGet`** with `GL_ALIASED_LINE_WIDTH_RANGE` to determine the maximum width.
    * 
    * In OpenGL 1.2, the tokens `GL_LINE_WIDTH_RANGE` and `GL_LINE_WIDTH_GRANULARITY` were replaced by `GL_ALIASED_LINE_WIDTH_RANGE`, `GL_SMOOTH_LINE_WIDTH_RANGE`, and `GL_SMOOTH_LINE_WIDTH_GRANULARITY`. The old names are retained for backward compatibility, but should not be used in new code.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **width** is less than or equal to 0.
    * 
    * @param width Specifies the width of rasterized lines. The initial value is 1.

    * @see **`glEnable`**

    **/
    static function lineWidth(width:Float):Void return ExtensionsNative.lineWidth(width);
    static function lineWidthx(width:Int):Void return ExtensionsNative.lineWidthx(width);
    static function lineWidthxOES(width:Int):Void return ExtensionsNative.lineWidthxOES(width);
    /**
    * - #### Purpose:
    * Links a program object
    * ### Description:
    * **glLinkProgram** links the program object specified by **program**. If any shader objects of type `GL_VERTEX_SHADER` are attached to **program**, they will be used to create an executable that will run on the programmable vertex processor. If any shader objects of type `GL_GEOMETRY_SHADER` are attached to **program**, they will be used to create an executable that will run on the programmable geometry processor. If any shader objects of type `GL_FRAGMENT_SHADER` are attached to **program**, they will be used to create an executable that will run on the programmable fragment processor.
    * 
    * The status of the link operation will be stored as part of the program object's state. This value will be set to `GL_TRUE` if the program object was linked without errors and is ready for use, and `GL_FALSE` otherwise. It can be queried by calling **`glGetProgram`** with arguments **program** and `GL_LINK_STATUS`.
    * 
    * As a result of a successful link operation, all active user-defined uniform variables belonging to **program** will be initialized to 0, and each of the program object's active uniform variables will be assigned a location that can be queried by calling **`glGetUniformLocation`**. Also, any active user-defined attribute variables that have not been bound to a generic vertex attribute index will be bound to one at this time.
    * 
    * Linking of a program object can fail for a number of reasons as specified in the OpenGL Shading Language Specification. The following lists some of the conditions that will cause a link error.
    * 
    * When a program object has been successfully linked, the program object can be made part of current state by calling **`glUseProgram`**. Whether or not the link operation was successful, the program object's information log will be overwritten. The information log can be retrieved by calling **`glGetProgramInfoLog`**.
    * 
    * **glLinkProgram** will also install the generated executables as part of the current rendering state if the link operation was successful and the specified program object is already currently in use as a result of a previous call to **`glUseProgram`**. If the program object currently in use is relinked unsuccessfully, its link status will be set to `GL_FALSE` , but the executables and associated state will remain part of the current state until a subsequent call to **glUseProgram** removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked.
    * 
    * If **program** contains shader objects of type `GL_VERTEX_SHADER`, and optionally of type `GL_GEOMETRY_SHADER`, but does not contain shader objects of type `GL_FRAGMENT_SHADER`, the vertex shader executable will be installed on the programmable vertex processor, the geometry shader executable, if present, will be installed on the programmable geometry processor, but no executable will be installed on the fragment processor. The results of rasterizing primitives with such a program will be undefined.
    * 
    * The program object's information log is updated and the program is generated at the time of the link operation. After the link operation, applications are free to modify attached shader objects, compile attached shader objects, detach shader objects, delete shader objects, and attach additional shader objects. None of these operations affects the information log or the program that is part of the program object.
    * 
    * 
    * ### Notes:
    * If the link operation is unsuccessful, any information about a previous link operation on **program** is lost (i.e., a failed link does not restore the old state of **program** ). Certain information can still be retrieved from **program** even after an unsuccessful link operation. See for instance **`glGetActiveAttrib`** and **`glGetActiveUniform`**.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is the currently active program object and transform feedback mode is active.
    * 
    * @param program Specifies the handle of the program object to be linked.

    * @see **`glAttachShader`**, **`glBindAttribLocation`**, **`glCompileShader`**, **`glCreateProgram`**, **`glDeleteProgram`**, **`glDetachShader`**, **`glUniform`**, **`glUseProgram`**, **`glValidateProgram`**

    **/
    static function linkProgram(program:Int):Void return ExtensionsNative.linkProgram(program);
    static function linkProgramARB(programObj:Int):Void return ExtensionsNative.linkProgramARB(programObj);
    static function listBase(base:Int):Void return ExtensionsNative.listBase(base);
    static function listDrawCommandsStatesClientNV(list:Int, segment:Int, in_directs:DataPointer, sizes:DataPointer, states:DataPointer, fbos:DataPointer, count:Int):Void return ExtensionsNative.listDrawCommandsStatesClientNV(list, segment, in_directs, sizes, states, fbos, count);
    static function listParameterfSGIX(list:Int, pname:Int, param:Float):Void return ExtensionsNative.listParameterfSGIX(list, pname, param);
    static function listParameterfvSGIX(list:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.listParameterfvSGIX(list, pname, params);
    static function listParameteriSGIX(list:Int, pname:Int, param:Int):Void return ExtensionsNative.listParameteriSGIX(list, pname, param);
    static function listParameterivSGIX(list:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.listParameterivSGIX(list, pname, params);
    static function loadIdentity():Void return ExtensionsNative.loadIdentity();
    static function loadIdentityDeformationMapSGIX(mask:Int):Void return ExtensionsNative.loadIdentityDeformationMapSGIX(mask);
    static function loadMatrixd(m:DataPointer):Void return ExtensionsNative.loadMatrixd(m);
    static function loadMatrixf(m:DataPointer):Void return ExtensionsNative.loadMatrixf(m);
    static function loadMatrixx(m:DataPointer):Void return ExtensionsNative.loadMatrixx(m);
    static function loadMatrixxOES(m:DataPointer):Void return ExtensionsNative.loadMatrixxOES(m);
    static function loadName(name:Int):Void return ExtensionsNative.loadName(name);
    static function loadPaletteFromModelViewMatrixOES():Void return ExtensionsNative.loadPaletteFromModelViewMatrixOES();
    static function loadProgramNV(target:Int, id:Int, len:Int, program:DataPointer):Void return ExtensionsNative.loadProgramNV(target, id, len, program);
    static function loadTransposeMatrixd(m:DataPointer):Void return ExtensionsNative.loadTransposeMatrixd(m);
    static function loadTransposeMatrixdARB(m:DataPointer):Void return ExtensionsNative.loadTransposeMatrixdARB(m);
    static function loadTransposeMatrixf(m:DataPointer):Void return ExtensionsNative.loadTransposeMatrixf(m);
    static function loadTransposeMatrixfARB(m:DataPointer):Void return ExtensionsNative.loadTransposeMatrixfARB(m);
    static function loadTransposeMatrixxOES(m:DataPointer):Void return ExtensionsNative.loadTransposeMatrixxOES(m);
    static function lockArraysEXT(first:Int, count:Int):Void return ExtensionsNative.lockArraysEXT(first, count);
    /**
    * - #### Purpose:
    * specify a logical pixel operation for rendering
    * ### Description:
    * **glLogicOp** specifies a logical operation that, when enabled, is applied between the incoming RGBA color and the RGBA color at the corresponding location in the frame buffer. To enable or disable the logical operation, call **`glEnable`** and **glDisable** using the symbolic constant `GL_COLOR_LOGIC_OP`. The initial value is disabled.
    * 
    * 
    * 
    * **opcode** is a symbolic constant chosen from the list above. In the explanation of the logical operations, s represents the incoming color and d represents the color in the frame buffer. Standard C-language operators are used. As these bitwise operators suggest, the logical operation is applied independently to each bit pair of the source and destination colors.
    * 
    * 
    * ### Notes:
    * When more than one RGBA color buffer is enabled for drawing, logical operations are performed separately for each enabled buffer, using for the destination value the contents of that buffer (see **`glDrawBuffer`**).
    * 
    * Logic operations have no effect on floating point draw buffers. However, if `GL_COLOR_LOGIC_OP` is enabled, blending is still disabled in this case.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **opcode** is not an accepted value.
    * 
    * @param opcode Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: `GL_CLEAR`, `GL_SET`, `GL_COPY`, `GL_COPY_INVERTED`, `GL_NOOP`, `GL_INVERT`, `GL_AND`, `GL_NAND`, `GL_OR`, `GL_NOR`, `GL_XOR`, `GL_EQUIV`, `GL_AND_REVERSE`, `GL_AND_INVERTED`, `GL_OR_REVERSE`, and `GL_OR_INVERTED`. The initial value is `GL_COPY`.

    * @see **`glBlendFunc`**, **`glDrawBuffer`**, **`glEnable`**, **`glStencilOp`**

    **/
    static function logicOp(opcode:Int):Void return ExtensionsNative.logicOp(opcode);
    static function makeBufferNonResidentNV(target:Int):Void return ExtensionsNative.makeBufferNonResidentNV(target);
    static function makeBufferResidentNV(target:Int, access:Int):Void return ExtensionsNative.makeBufferResidentNV(target, access);
    static function makeImageHandleNonResidentARB(handle:Int):Void return ExtensionsNative.makeImageHandleNonResidentARB(handle);
    static function makeImageHandleNonResidentNV(handle:Int):Void return ExtensionsNative.makeImageHandleNonResidentNV(handle);
    static function makeImageHandleResidentARB(handle:Int, access:Int):Void return ExtensionsNative.makeImageHandleResidentARB(handle, access);
    static function makeImageHandleResidentNV(handle:Int, access:Int):Void return ExtensionsNative.makeImageHandleResidentNV(handle, access);
    static function makeNamedBufferNonResidentNV(buffer:Int):Void return ExtensionsNative.makeNamedBufferNonResidentNV(buffer);
    static function makeNamedBufferResidentNV(buffer:Int, access:Int):Void return ExtensionsNative.makeNamedBufferResidentNV(buffer, access);
    static function makeTextureHandleNonResidentARB(handle:Int):Void return ExtensionsNative.makeTextureHandleNonResidentARB(handle);
    static function makeTextureHandleNonResidentNV(handle:Int):Void return ExtensionsNative.makeTextureHandleNonResidentNV(handle);
    static function makeTextureHandleResidentARB(handle:Int):Void return ExtensionsNative.makeTextureHandleResidentARB(handle);
    static function makeTextureHandleResidentNV(handle:Int):Void return ExtensionsNative.makeTextureHandleResidentNV(handle);
    static function map1d(target:Int, u1:DataPointer, u2:DataPointer, stride:Int, order:Int, poin_ts:DataPointer):Void return ExtensionsNative.map1d(target, u1, u2, stride, order, poin_ts);
    static function map1f(target:Int, u1:Float, u2:Float, stride:Int, order:Int, poin_ts:DataPointer):Void return ExtensionsNative.map1f(target, u1, u2, stride, order, poin_ts);
    static function map1xOES(target:Int, u1:Int, u2:Int, stride:Int, order:Int, poin_ts:Int):Void return ExtensionsNative.map1xOES(target, u1, u2, stride, order, poin_ts);
    static function map2d(target:Int, u1:DataPointer, u2:DataPointer, ustride:Int, uorder:Int, v1:DataPointer, v2:DataPointer, vstride:Int, vorder:Int, poin_ts:DataPointer):Void return ExtensionsNative.map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, poin_ts);
    static function map2f(target:Int, u1:Float, u2:Float, ustride:Int, uorder:Int, v1:Float, v2:Float, vstride:Int, vorder:Int, poin_ts:DataPointer):Void return ExtensionsNative.map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, poin_ts);
    static function map2xOES(target:Int, u1:Int, u2:Int, ustride:Int, uorder:Int, v1:Int, v2:Int, vstride:Int, vorder:Int, poin_ts:Int):Void return ExtensionsNative.map2xOES(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, poin_ts);
    /**
    * - #### Purpose:
    * map all of a buffer object's data store into the client's address space
    * ### Description:
    * **glMapBuffer** and **glMapNamedBuffer** map the entire data store of a specified buffer object into the client's address space. The data can then be directly read and/or written relative to the returned pointer, depending on the specified **access** policy.
    * 
    * A pointer to the beginning of the mapped range is returned once all pending operations on that buffer object have completed, and may be used to modify and/or query the corresponding range of the data store according to the value of **access**: `GL_READ_ONLY` indicates that the returned pointer may be used to read buffer object data. `GL_WRITE_ONLY` indicates that the returned pointer may be used to modify buffer object data. `GL_READ_WRITE` indicates that the returned pointer may be used to read and to modify buffer object data.
    * 
    * If an error is generated, a NULL pointer is returned.
    * 
    * If no error occurs, the returned pointer will reflect an allocation aligned to the value of `GL_MIN_MAP_BUFFER_ALIGNMENT` basic machine units.
    * 
    * The returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although implementations may not check for such behavior for performance reasons.
    * 
    * No GL error is generated if the returned pointer is accessed in a way inconsistent with **access** (e.g. used to read from a mapping made with **access** `GL_WRITE_ONLY` or write to a mapping made with **access** `GL_READ_ONLY`), but the result is undefined and system errors (possibly including program termination) may occur.
    * 
    * Mappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal performance, the client should use the mapping in a fashion consistent with the values of `GL_BUFFER_USAGE` for the buffer object and of **access**. Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of magnitude slower than using normal memory.
    * 
    * 
    * ### Notes:
    * Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or greater.
    * 
    * The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.
    * 
    * The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glMapBuffer** if **target** is not one of the buffer binding targets listed above.
    * 
    * `GL_INVALID_OPERATION` is generated by **glMapBuffer** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glMapNamedBuffer** if **buffer** is not the name of an existing buffer object.
    * 
    * `GL_INVALID_ENUM` is generated if **access** is not `GL_READ_ONLY`, `GL_WRITE_ONLY`, or `GL_READ_WRITE`.
    * 
    * `GL_OUT_OF_MEMORY` is generated if the GL is unable to map the buffer object's data store. This may occur for a variety of system-specific reasons, such as the absence of sufficient remaining virtual memory.
    * 
    * `GL_INVALID_OPERATION` is generated if the buffer object is in a mapped state.
    * 
    * @param target Specifies the target to which the buffer object is bound for **glMapBuffer**, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of the buffer object for **glMapNamedBuffer**.
    * @param access Specifies the access policy for **glMapBuffer** and **glMapNamedBuffer**, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be `GL_READ_ONLY`, `GL_WRITE_ONLY`, or `GL_READ_WRITE`.

    * @see **`glBindBuffer`**, **`glBindBufferBase`**, **`glBindBufferRange`**, **`glBufferData`**, **`glBufferSubData`**, **`glDeleteBuffers`**, **`glMapBufferRange`**, **`glUnmapBuffer`**

    **/
    static function mapBuffer(target:Int, access:Int):DataPointer return ExtensionsNative.mapBuffer(target, access);
    static function mapBufferARB(target:Int, access:Int):DataPointer return ExtensionsNative.mapBufferARB(target, access);
    static function mapBufferOES(target:Int, access:Int):DataPointer return ExtensionsNative.mapBufferOES(target, access);
    /**
    * - #### Purpose:
    * map all or part of a buffer object's data store into the client's address space
    * ### Description:
    * **glMapBufferRange** and **glMapNamedBufferRange** map all or part of the data store of a specified buffer object into the client's address space. **offset** and **length** indicate the range of data in the buffer object that is to be mapped, in terms of basic machine units. **access** is a bitfield containing flags which describe the requested mapping. These flags are described below.
    * 
    * A pointer to the beginning of the mapped range is returned once all pending operations on the buffer object have completed, and may be used to modify and/or query the corresponding range of the data store according to the following flag bits set in **access**: `GL_MAP_READ_BIT` indicates that the returned pointer may be used to read buffer object data. No GL error is generated if the pointer is used to query a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur. `GL_MAP_WRITE_BIT` indicates that the returned pointer may be used to modify buffer object data. No GL error is generated if the pointer is used to modify a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur. `GL_MAP_PERSISTENT_BIT` indicates that the mapping is to be made in a persistent fashion and that the client intends to hold and use the returned pointer during subsequent GL operation. It is not an error to call drawing commands (render) while buffers are mapped using this flag. It is an error to specify this flag if the buffer's data store was not allocated through a call to the **`glBufferStorage`** command in which the `GL_MAP_PERSISTENT_BIT` was also set. `GL_MAP_COHERENT_BIT` indicates that a persistent mapping is also to be coherent. Coherent maps guarantee that the effect of writes to a buffer's data store by either the client or server will eventually become visible to the other without further intervention from the application. In the absence of this bit, persistent mappings are not coherent and modified ranges of the buffer store must be explicitly communicated to the GL, either by unmapping the buffer, or through a call to **`glFlushMappedBufferRange`** or **`glMemoryBarrier`**.
    * 
    * The following optional flag bits in **access** may be used to modify the mapping: `GL_MAP_INVALIDATE_RANGE_BIT` indicates that the previous contents of the specified range may be discarded. Data within this range are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL operations access unwritten data, but the result is undefined and system errors (possibly including program termination) may occur. This flag may not be used in combination with `GL_MAP_READ_BIT`. `GL_MAP_INVALIDATE_BUFFER_BIT` indicates that the previous contents of the entire buffer may be discarded. Data within the entire buffer are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL operations access unwritten data, but the result is undefined and system errors (possibly including program termination) may occur. This flag may not be used in combination with `GL_MAP_READ_BIT`. `GL_MAP_FLUSH_EXPLICIT_BIT` indicates that one or more discrete subranges of the mapping may be modified. When this flag is set, modifications to each subrange must be explicitly flushed by calling **`glFlushMappedBufferRange`**. No GL error is set if a subrange of the mapping is modified and not flushed, but data within the corresponding subrange of the buffer are undefined. This flag may only be used in conjunction with `GL_MAP_WRITE_BIT`. When this option is selected, flushing is strictly limited to regions that are explicitly indicated with calls to **`glFlushMappedBufferRange`** prior to unmap; if this option is not selected **`glUnmapBuffer`** will automatically flush the entire mapped range when called. `GL_MAP_UNSYNCHRONIZED_BIT` indicates that the GL should not attempt to synchronize pending operations on the buffer prior to returning from **glMapBufferRange** or **glMapNamedBufferRange**. No GL error is generated if pending operations which source or modify the buffer overlap the mapped region, but the result of such previous and any subsequent operations is undefined.
    * 
    * If an error occurs, a NULL pointer is returned.
    * 
    * If no error occurs, the returned pointer will reflect an allocation aligned to the value of `GL_MIN_MAP_BUFFER_ALIGNMENT` basic machine units. Subtracting **offset** from this returned pointer will always produce a multiple of the value of `GL_MIN_MAP_BUFFER_ALIGNMENT`.
    * 
    * The returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although implementations may not check for such behavior for performance reasons.
    * 
    * Mappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal performance, the client should use the mapping in a fashion consistent with the values of `GL_BUFFER_USAGE` for the buffer object and of **access**. Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of magnitude slower than using normal memory.
    * 
    * 
    * ### Notes:
    * Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or greater.
    * 
    * The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are accepted only if the GL version is 4.3 or greater.
    * 
    * The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
    * 
    * The `GL_MAP_PERSISTENT_BIT` and `GL_MAP_COHERENT_BIT` flags are available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glMapBufferRange** if **target** is not one of the buffer binding targets listed above.
    * 
    * `GL_INVALID_OPERATION` is generated by **glMapBufferRange** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glMapNamedBufferRange** if **buffer** is not the name of an existing buffer object.
    * 
    * `GL_INVALID_VALUE` is generated if **offset** or **length** is negative, if $offset + length$ is greater than the value of `GL_BUFFER_SIZE` for the buffer object, or if **access** has any bits set other than those defined above.
    * 
    * `GL_INVALID_OPERATION` is generated for any of the following conditions: **length** is zero. The buffer object is already in a mapped state. Neither `GL_MAP_READ_BIT` nor `GL_MAP_WRITE_BIT` is set. `GL_MAP_READ_BIT` is set and any of `GL_MAP_INVALIDATE_RANGE_BIT`, `GL_MAP_INVALIDATE_BUFFER_BIT` or `GL_MAP_UNSYNCHRONIZED_BIT` is set. `GL_MAP_FLUSH_EXPLICIT_BIT` is set and `GL_MAP_WRITE_BIT` is not set. Any of `GL_MAP_READ_BIT`, `GL_MAP_WRITE_BIT`, `GL_MAP_PERSISTENT_BIT`, or `GL_MAP_COHERENT_BIT` are set, but the same bit is not included in the buffer's storage flags.
    * 
    * No error is generated if memory outside the mapped range is modified or queried, but the result is undefined and system errors (possibly including program termination) may occur.
    * 
    * @param target Specifies the target to which the buffer object is bound for **glMapBufferRange**, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of the buffer object for **glMapNamedBufferRange**.
    * @param offset Specifies the starting offset within the buffer of the range to be mapped.
    * @param length Specifies the length of the range to be mapped.
    * @param access Specifies a combination of access flags indicating the desired access to the mapped range.

    * @see **`glMapBuffer`**, **`glUnmapBuffer`**, **`glFlushMappedBufferRange`**, **`glBindBuffer`**, **`glBufferStorage`**

    **/
    static function mapBufferRange(target:Int, offset:Int, length:Int, access:Int):DataPointer return ExtensionsNative.mapBufferRange(target, offset, length, access);
    static function mapBufferRangeEXT(target:Int, offset:Int, length:Int, access:Int):DataPointer return ExtensionsNative.mapBufferRangeEXT(target, offset, length, access);
    static function mapControlPointsNV(target:Int, in_dex:Int, type:Int, ustride:Int, vstride:Int, uorder:Int, vorder:Int, packed:Bool, poin_ts:DataPointer):Void return ExtensionsNative.mapControlPointsNV(target, in_dex, type, ustride, vstride, uorder, vorder, packed, poin_ts);
    static function mapGrid1d(un:Int, u1:DataPointer, u2:DataPointer):Void return ExtensionsNative.mapGrid1d(un, u1, u2);
    static function mapGrid1f(un:Int, u1:Float, u2:Float):Void return ExtensionsNative.mapGrid1f(un, u1, u2);
    static function mapGrid1xOES(n:Int, u1:Int, u2:Int):Void return ExtensionsNative.mapGrid1xOES(n, u1, u2);
    static function mapGrid2d(un:Int, u1:DataPointer, u2:DataPointer, vn:Int, v1:DataPointer, v2:DataPointer):Void return ExtensionsNative.mapGrid2d(un, u1, u2, vn, v1, v2);
    static function mapGrid2f(un:Int, u1:Float, u2:Float, vn:Int, v1:Float, v2:Float):Void return ExtensionsNative.mapGrid2f(un, u1, u2, vn, v1, v2);
    static function mapGrid2xOES(n:Int, u1:Int, u2:Int, v1:Int, v2:Int):Void return ExtensionsNative.mapGrid2xOES(n, u1, u2, v1, v2);
    static function mapNamedBuffer(buffer:Int, access:Int):DataPointer return ExtensionsNative.mapNamedBuffer(buffer, access);
    static function mapNamedBufferEXT(buffer:Int, access:Int):DataPointer return ExtensionsNative.mapNamedBufferEXT(buffer, access);
    static function mapNamedBufferRange(buffer:Int, offset:Int, length:Int, access:Int):DataPointer return ExtensionsNative.mapNamedBufferRange(buffer, offset, length, access);
    static function mapNamedBufferRangeEXT(buffer:Int, offset:Int, length:Int, access:Int):DataPointer return ExtensionsNative.mapNamedBufferRangeEXT(buffer, offset, length, access);
    static function mapObjectBufferATI(buffer:Int):DataPointer return ExtensionsNative.mapObjectBufferATI(buffer);
    static function mapParameterfvNV(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.mapParameterfvNV(target, pname, params);
    static function mapParameterivNV(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.mapParameterivNV(target, pname, params);
    static function mapTexture2DINTEL(texture:Int, level:Int, access:Int, stride:DataPointer, layout:DataPointer):DataPointer return ExtensionsNative.mapTexture2DINTEL(texture, level, access, stride, layout);
    static function mapVertexAttrib1dAPPLE(in_dex:Int, size:Int, u1:DataPointer, u2:DataPointer, stride:Int, order:Int, poin_ts:DataPointer):Void return ExtensionsNative.mapVertexAttrib1dAPPLE(in_dex, size, u1, u2, stride, order, poin_ts);
    static function mapVertexAttrib1fAPPLE(in_dex:Int, size:Int, u1:Float, u2:Float, stride:Int, order:Int, poin_ts:DataPointer):Void return ExtensionsNative.mapVertexAttrib1fAPPLE(in_dex, size, u1, u2, stride, order, poin_ts);
    static function mapVertexAttrib2dAPPLE(in_dex:Int, size:Int, u1:DataPointer, u2:DataPointer, ustride:Int, uorder:Int, v1:DataPointer, v2:DataPointer, vstride:Int, vorder:Int, poin_ts:DataPointer):Void return ExtensionsNative.mapVertexAttrib2dAPPLE(in_dex, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, poin_ts);
    static function mapVertexAttrib2fAPPLE(in_dex:Int, size:Int, u1:Float, u2:Float, ustride:Int, uorder:Int, v1:Float, v2:Float, vstride:Int, vorder:Int, poin_ts:DataPointer):Void return ExtensionsNative.mapVertexAttrib2fAPPLE(in_dex, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, poin_ts);
    static function materialf(face:Int, pname:Int, param:Float):Void return ExtensionsNative.materialf(face, pname, param);
    static function materialfv(face:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.materialfv(face, pname, params);
    static function materiali(face:Int, pname:Int, param:Int):Void return ExtensionsNative.materiali(face, pname, param);
    static function materialiv(face:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.materialiv(face, pname, params);
    static function materialx(face:Int, pname:Int, param:Int):Void return ExtensionsNative.materialx(face, pname, param);
    static function materialxOES(face:Int, pname:Int, param:Int):Void return ExtensionsNative.materialxOES(face, pname, param);
    static function materialxv(face:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.materialxv(face, pname, param);
    static function materialxvOES(face:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.materialxvOES(face, pname, param);
    static function matrixFrustumEXT(mode:Int, left:DataPointer, right:DataPointer, bottom:DataPointer, top:DataPointer, zNear:DataPointer, zFar:DataPointer):Void return ExtensionsNative.matrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
    static function matrixIndexPointerARB(size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.matrixIndexPointerARB(size, type, stride, poin_ter);
    static function matrixIndexPointerOES(size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.matrixIndexPointerOES(size, type, stride, poin_ter);
    static function matrixIndexubvARB(size:Int, in_dices:DataPointer):Void return ExtensionsNative.matrixIndexubvARB(size, in_dices);
    static function matrixIndexuivARB(size:Int, in_dices:DataPointer):Void return ExtensionsNative.matrixIndexuivARB(size, in_dices);
    static function matrixIndexusvARB(size:Int, in_dices:DataPointer):Void return ExtensionsNative.matrixIndexusvARB(size, in_dices);
    static function matrixLoad3x2fNV(matrixMode:Int, m:DataPointer):Void return ExtensionsNative.matrixLoad3x2fNV(matrixMode, m);
    static function matrixLoad3x3fNV(matrixMode:Int, m:DataPointer):Void return ExtensionsNative.matrixLoad3x3fNV(matrixMode, m);
    static function matrixLoadIdentityEXT(mode:Int):Void return ExtensionsNative.matrixLoadIdentityEXT(mode);
    static function matrixLoadTranspose3x3fNV(matrixMode:Int, m:DataPointer):Void return ExtensionsNative.matrixLoadTranspose3x3fNV(matrixMode, m);
    static function matrixLoadTransposedEXT(mode:Int, m:DataPointer):Void return ExtensionsNative.matrixLoadTransposedEXT(mode, m);
    static function matrixLoadTransposefEXT(mode:Int, m:DataPointer):Void return ExtensionsNative.matrixLoadTransposefEXT(mode, m);
    static function matrixLoaddEXT(mode:Int, m:DataPointer):Void return ExtensionsNative.matrixLoaddEXT(mode, m);
    static function matrixLoadfEXT(mode:Int, m:DataPointer):Void return ExtensionsNative.matrixLoadfEXT(mode, m);
    static function matrixMode(mode:Int):Void return ExtensionsNative.matrixMode(mode);
    static function matrixMult3x2fNV(matrixMode:Int, m:DataPointer):Void return ExtensionsNative.matrixMult3x2fNV(matrixMode, m);
    static function matrixMult3x3fNV(matrixMode:Int, m:DataPointer):Void return ExtensionsNative.matrixMult3x3fNV(matrixMode, m);
    static function matrixMultTranspose3x3fNV(matrixMode:Int, m:DataPointer):Void return ExtensionsNative.matrixMultTranspose3x3fNV(matrixMode, m);
    static function matrixMultTransposedEXT(mode:Int, m:DataPointer):Void return ExtensionsNative.matrixMultTransposedEXT(mode, m);
    static function matrixMultTransposefEXT(mode:Int, m:DataPointer):Void return ExtensionsNative.matrixMultTransposefEXT(mode, m);
    static function matrixMultdEXT(mode:Int, m:DataPointer):Void return ExtensionsNative.matrixMultdEXT(mode, m);
    static function matrixMultfEXT(mode:Int, m:DataPointer):Void return ExtensionsNative.matrixMultfEXT(mode, m);
    static function matrixOrthoEXT(mode:Int, left:DataPointer, right:DataPointer, bottom:DataPointer, top:DataPointer, zNear:DataPointer, zFar:DataPointer):Void return ExtensionsNative.matrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
    static function matrixPopEXT(mode:Int):Void return ExtensionsNative.matrixPopEXT(mode);
    static function matrixPushEXT(mode:Int):Void return ExtensionsNative.matrixPushEXT(mode);
    static function matrixRotatedEXT(mode:Int, angle:DataPointer, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.matrixRotatedEXT(mode, angle, x, y, z);
    static function matrixRotatefEXT(mode:Int, angle:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.matrixRotatefEXT(mode, angle, x, y, z);
    static function matrixScaledEXT(mode:Int, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.matrixScaledEXT(mode, x, y, z);
    static function matrixScalefEXT(mode:Int, x:Float, y:Float, z:Float):Void return ExtensionsNative.matrixScalefEXT(mode, x, y, z);
    static function matrixTranslatedEXT(mode:Int, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.matrixTranslatedEXT(mode, x, y, z);
    static function matrixTranslatefEXT(mode:Int, x:Float, y:Float, z:Float):Void return ExtensionsNative.matrixTranslatefEXT(mode, x, y, z);
    static function maxActiveShaderCoresARM(count:Int):Void return ExtensionsNative.maxActiveShaderCoresARM(count);
    static function maxShaderCompilerThreadsKHR(count:Int):Void return ExtensionsNative.maxShaderCompilerThreadsKHR(count);
    static function maxShaderCompilerThreadsARB(count:Int):Void return ExtensionsNative.maxShaderCompilerThreadsARB(count);
    /**
    * - #### Purpose:
    * defines a barrier ordering memory transactions
    * ### Description:
    * **glMemoryBarrier** defines a barrier ordering the memory transactions issued prior to the command relative to those issued after the barrier. For the purposes of this ordering, memory transactions performed by shaders are considered to be issued by the rendering command that triggered the execution of the shader. **barriers** is a bitfield indicating the set of operations that are synchronized with shader stores; the bits used in **barriers** are as follows:
    * 
    * *``GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT``* If set, vertex data sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier. The set of buffer objects affected by this bit is derived from the buffer object bindings used for generic vertex attributes derived from the `GL_VERTEX_ATTRIB_ARRAY_BUFFER` bindings. *``GL_ELEMENT_ARRAY_BARRIER_BIT``* If set, vertex array indices sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier. The buffer objects affected by this bit are derived from the `GL_ELEMENT_ARRAY_BUFFER` binding. *``GL_UNIFORM_BARRIER_BIT``* Shader uniforms sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier. *``GL_TEXTURE_FETCH_BARRIER_BIT``* Texture fetches from shaders, including fetches from buffer object memory via buffer textures, after the barrier will reflect data written by shaders prior to the barrier. *``GL_SHADER_IMAGE_ACCESS_BARRIER_BIT``* Memory accesses using shader image load, store, and atomic built-in functions issued after the barrier will reflect data written by shaders prior to the barrier. Additionally, image stores and atomics issued after the barrier will not execute until all memory accesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to the barrier complete. *``GL_COMMAND_BARRIER_BIT``* Command data sourced from buffer objects by Draw*Indirect commands after the barrier will reflect data written by shaders prior to the barrier. The buffer objects affected by this bit are derived from the `GL_DRAW_INDIRECT_BUFFER` binding. *``GL_PIXEL_BUFFER_BARRIER_BIT``* Reads and writes of buffer objects via the `GL_PIXEL_PACK_BUFFER` and `GL_PIXEL_UNPACK_BUFFER` bindings (via **`glReadPixels`**, **`glTexSubImage1D`**, etc.) after the barrier will reflect data written by shaders prior to the barrier. Additionally, buffer object writes issued after the barrier will wait on the completion of all shader writes initiated prior to the barrier. *``GL_TEXTURE_UPDATE_BARRIER_BIT``* Writes to a texture via **glTex(Sub)Image***, **glCopyTex(Sub)Image***, **glCompressedTex(Sub)Image***, and reads via **`glGetTexImage`** after the barrier will reflect data written by shaders prior to the barrier. Additionally, texture writes from these commands issued after the barrier will not execute until all shader writes initiated prior to the barrier complete. *``GL_BUFFER_UPDATE_BARRIER_BIT``* Reads or writes via **`glBufferSubData`**, **`glCopyBufferSubData`**, or **`glGetBufferSubData`**, or to buffer object memory mapped by **`glMapBuffer`** or **`glMapBufferRange`** after the barrier will reflect data written by shaders prior to the barrier. Additionally, writes via these commands issued after the barrier will wait on the completion of any shader writes to the same memory initiated prior to the barrier. *``GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT``* Access by the client to persistent mapped regions of buffer objects will reflect data written by shaders prior to the barrier. Note that this may cause additional synchronization operations. *``GL_FRAMEBUFFER_BARRIER_BIT``* Reads and writes via framebuffer object attachments after the barrier will reflect data written by shaders prior to the barrier. Additionally, framebuffer writes issued after the barrier will wait on the completion of all shader writes issued prior to the barrier. *``GL_TRANSFORM_FEEDBACK_BARRIER_BIT``* Writes via transform feedback bindings after the barrier will reflect data written by shaders prior to the barrier. Additionally, transform feedback writes issued after the barrier will wait on the completion of all shader writes issued prior to the barrier. *``GL_ATOMIC_COUNTER_BARRIER_BIT``* Accesses to atomic counters after the barrier will reflect writes prior to the barrier. *``GL_SHADER_STORAGE_BARRIER_BIT``* Accesses to shader storage blocks after the barrier will reflect writes prior to the barrier. *``GL_QUERY_BUFFER_BARRIER_BIT``* Writes of buffer objects via the `GL_QUERY_BUFFER` binding after the barrier will reflect data written by shaders prior to the barrier. Additionally, buffer object writes issued after the barrier will wait on the completion of all shader writes initiated prior to the barrier.
    * 
    * If **barriers** is `GL_ALL_BARRIER_BITS`, shader memory accesses will be synchronized relative to all the operations described above.
    * 
    * Implementations may cache buffer object and texture image memory that could be written by shaders in multiple caches; for example, there may be separate caches for texture, vertex fetching, and one or more caches for shader memory accesses. Implementations are not required to keep these caches coherent with shader memory writes. Stores issued by one invocation may not be immediately observable by other pipeline stages or other shader invocations because the value stored may remain in a cache local to the processor executing the store, or because data overwritten by the store is still in a cache elsewhere in the system. When **glMemoryBarrier** is called, the GL flushes and/or invalidates any caches relevant to the operations specified by the **barriers** parameter to ensure consistent ordering of operations across the barrier.
    * 
    * To allow for independent shader invocations to communicate by reads and writes to a common memory address, image variables in the OpenGL Shading Language may be declared as "coherent". Buffer object or texture image memory accessed through such variables may be cached only if caches are automatically updated due to stores issued by any other shader invocation. If the same address is accessed using both coherent and non-coherent variables, the accesses using variables declared as coherent will observe the results stored using coherent variables in other invocations. Using variables declared as "coherent" guarantees only that the results of stores will be immediately visible to shader invocations using similarly-declared variables; calling **glMemoryBarrier** is required to ensure that the stores are visible to other operations.
    * 
    * The following guidelines may be helpful in choosing when to use coherent memory accesses and when to use barriers.
    * 
    * Data that are read-only or constant may be accessed without using coherent variables or calling **MemoryBarrier**(). Updates to the read-only data via API calls such as **glBufferSubData** will invalidate shader caches implicitly as required. Data that are shared between shader invocations at a fine granularity (e.g., written by one invocation, consumed by another invocation) should use coherent variables to read and write the shared data. Data written by one shader invocation and consumed by other shader invocations launched as a result of its execution ("dependent invocations") should use coherent variables in the producing shader invocation and call **memoryBarrier**() after the last write. The consuming shader invocation should also use coherent variables. Data written to image variables in one rendering pass and read by the shader in a later pass need not use coherent variables or memoryBarrier(). Calling **glMemoryBarrier** with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in **barriers** between passes is necessary. Data written by the shader in one rendering pass and read by another mechanism (e.g., vertex or index buffer pulling) in a later pass need not use coherent variables or **memoryBarrier**(). Calling **glMemoryBarrier** with the appropriate bits set in **barriers** between passes is necessary.
    * 
    * 
    * ### Notes:
    * `GL_SHADER_STORAGE_BARRIER_BIT` is available only if the GL version is 4.3 or higher.
    * 
    * `GL_QUERY_BUFFER_BARRIER_BIT` is available only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **barriers** is not the special value `GL_ALL_BARRIER_BITS`, and has any bits set other than those described above for **glMemoryBarrier** or **glMemoryBarrierByRegion** respectively.
    * 
    * @param barriers Specifies the barriers to insert. For **glMemoryBarrier**, must be a bitwise combination of any of `GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`, `GL_ELEMENT_ARRAY_BARRIER_BIT`, `GL_UNIFORM_BARRIER_BIT`, `GL_TEXTURE_FETCH_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_COMMAND_BARRIER_BIT`, `GL_PIXEL_BUFFER_BARRIER_BIT`, `GL_TEXTURE_UPDATE_BARRIER_BIT`, `GL_BUFFER_UPDATE_BARRIER_BIT`, `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_TRANSFORM_FEEDBACK_BARRIER_BIT`, `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_SHADER_STORAGE_BARRIER_BIT`. For **glMemoryBarrier**, must be a bitwise combination of any of `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_SHADER_STORAGE_BARRIER_BIT`. `GL_TEXTURE_FETCH_BARRIER_BIT`, or `GL_UNIFORM_BARRIER_BIT`. If the special value `GL_ALL_BARRIER_BITS` is specified, all supported barriers for the corresponding command will be inserted.

    * @see **`glBindImageTexture`**, **`glBufferData`**, **`glMapBuffer`**, **`glMapBufferRange`**, **`glFlushMappedBufferRange`**, **`memoryBarrier`**

    **/
    static function memoryBarrier(barriers:Int):Void return ExtensionsNative.memoryBarrier(barriers);
    static function memoryBarrierByRegion(barriers:Int):Void return ExtensionsNative.memoryBarrierByRegion(barriers);
    static function memoryBarrierEXT(barriers:Int):Void return ExtensionsNative.memoryBarrierEXT(barriers);
    static function memoryObjectParameterivEXT(memoryObject:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.memoryObjectParameterivEXT(memoryObject, pname, params);
    /**
    * - #### Purpose:
    * specifies minimum rate at which sample shading takes place
    * ### Description:
    * **glMinSampleShading** specifies the rate at which samples are shaded within a covered pixel. Sample-rate shading is enabled by calling **`glEnable`** with the parameter `GL_SAMPLE_SHADING`. If `GL_MULTISAMPLE` or `GL_SAMPLE_SHADING` is disabled, sample shading has no effect. Otherwise, an implementation must provide at least as many unique color values for each covered fragment as specified by **value** times **samples** where **samples** is the value of `GL_SAMPLES` for the current framebuffer. At least 1 sample for each covered fragment is generated.
    * 
    * A **value** of 1.0 indicates that each sample in the framebuffer should be independently shaded. A **value** of 0.0 effectively allows the GL to ignore sample rate shading. Any value between 0.0 and 1.0 allows the GL to shade only a subset of the total samples within each covered fragment. Which samples are shaded and the algorithm used to select that subset of the fragment's samples is implementation dependent.
    * 
    * 
    * ### Notes:
    * The type of the **value** parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the **`removedTypes`** page.
    * 
    * 
    * ### Errors:
    * None.
    * 
    * @param value Specifies the rate at which samples are shaded within each covered pixel.

    * @see **`removedTypes`**

    **/
    static function minSampleShading(value:Float):Void return ExtensionsNative.minSampleShading(value);
    static function minSampleShadingARB(value:Float):Void return ExtensionsNative.minSampleShadingARB(value);
    static function minSampleShadingOES(value:Float):Void return ExtensionsNative.minSampleShadingOES(value);
    static function minmax(target:Int, in_ternalformat:Int, sin_k:Bool):Void return ExtensionsNative.minmax(target, in_ternalformat, sin_k);
    static function minmaxEXT(target:Int, in_ternalformat:Int, sin_k:Bool):Void return ExtensionsNative.minmaxEXT(target, in_ternalformat, sin_k);
    static function multMatrixd(m:DataPointer):Void return ExtensionsNative.multMatrixd(m);
    static function multMatrixf(m:DataPointer):Void return ExtensionsNative.multMatrixf(m);
    static function multMatrixx(m:DataPointer):Void return ExtensionsNative.multMatrixx(m);
    static function multMatrixxOES(m:DataPointer):Void return ExtensionsNative.multMatrixxOES(m);
    static function multTransposeMatrixd(m:DataPointer):Void return ExtensionsNative.multTransposeMatrixd(m);
    static function multTransposeMatrixdARB(m:DataPointer):Void return ExtensionsNative.multTransposeMatrixdARB(m);
    static function multTransposeMatrixf(m:DataPointer):Void return ExtensionsNative.multTransposeMatrixf(m);
    static function multTransposeMatrixfARB(m:DataPointer):Void return ExtensionsNative.multTransposeMatrixfARB(m);
    static function multTransposeMatrixxOES(m:DataPointer):Void return ExtensionsNative.multTransposeMatrixxOES(m);
    /**
    * - #### Purpose:
    * render multiple sets of primitives from array data
    * ### Description:
    * **glMultiDrawArrays** specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to **glMultiDrawArrays**.
    * 
    * **glMultiDrawArrays** behaves identically to **`glDrawArrays`** except that **drawcount** separate ranges of elements are specified instead.
    * 
    * When **glMultiDrawArrays** is called, it uses **count** sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element **first**. **mode** specifies what kind of primitives are constructed, and how the array elements construct those primitives.
    * 
    * Vertex attributes that are modified by **glMultiDrawArrays** have an unspecified value after **glMultiDrawArrays** returns. Attributes that aren't modified remain well defined.
    * 
    * 
    * ### Notes:
    * `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **drawcount** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param first Points to an array of starting indices in the enabled arrays.
    * @param count Points to an array of the number of indices to be rendered.
    * @param drawcount Specifies the size of the first and count

    * @see **`glDrawElements`**, **`glDrawRangeElements`**

    **/
    static function multiDrawArrays(mode:Int, first:DataPointer, count:DataPointer, drawcount:Int):Void return ExtensionsNative.multiDrawArrays(mode, first, count, drawcount);
    static function multiDrawArraysEXT(mode:Int, first:DataPointer, count:DataPointer, primcount:Int):Void return ExtensionsNative.multiDrawArraysEXT(mode, first, count, primcount);
    /**
    * - #### Purpose:
    * render multiple sets of primitives from array data, taking parameters from memory
    * ### Description:
    * **glMultiDrawArraysIndirect** specifies multiple geometric primitives with very few subroutine calls. **glMultiDrawArraysIndirect** behaves similarly to a multitude of calls to **`glDrawArraysInstancedBaseInstance`**, execept that the parameters to each call to **`glDrawArraysInstancedBaseInstance`** are stored in an array in memory at the address given by **indirect**, separated by the stride, in basic machine units, specified by **stride**. If **stride** is zero, then the array is assumed to be tightly packed in memory.
    * 
    * The parameters addressed by **indirect** are packed into an array of structures, each element of which takes the form (in C): typedef struct { uint count; uint instanceCount; uint first; uint baseInstance; } DrawArraysIndirectCommand;
    * 
    * A single call to **glMultiDrawArraysIndirect** is equivalent, assuming no errors are generated to: GLsizei n; for (n = 0; n &lt; drawcount; n++) { const DrawArraysIndirectCommand *cmd; if (stride != 0) { cmd = (const DrawArraysIndirectCommand *)((uintptr)indirect + n * stride); } else { cmd = (const DrawArraysIndirectCommand *)indirect + n; } glDrawArraysInstancedBaseInstance(mode, cmd-&gt;first, cmd-&gt;count, cmd-&gt;instanceCount, cmd-&gt;baseInstance); }
    * 
    * If a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to **glMultiDrawArraysIndirect**, **indirect** is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory.
    * 
    * In contrast to **`glDrawArraysInstancedBaseInstance`**, the first member of the parameter structure is unsigned, and out-of-range indices do not generate an error.
    * 
    * Vertex attributes that are modified by **glMultiDrawArraysIndirect** have an unspecified value after **glMultiDrawArraysIndirect** returns. Attributes that aren't modified remain well defined.
    * 
    * 
    * ### Notes:
    * The **baseInstance** member of the **DrawArraysIndirectCommand** structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.
    * 
    * **glMultiDrawArraysIndirect** is available only if the GL version is 4.3 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **stride** is not a multiple of four.
    * 
    * `GL_INVALID_VALUE` is generated if **drawcount** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **mode** is `GL_PATCHES` and no tessellation control shader is active.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.
    * @param indirect Specifies the address of an array of structures containing the draw parameters.
    * @param drawcount Specifies the number of elements in the array of draw parameter structures.
    * @param stride Specifies the distance in basic machine units between elements of the draw parameter array.

    * @see **`glDrawArrays`**, **`glDrawArraysInstanced`**, **`glDrawElements`**, **`glDrawRangeElements`**, **`glDrawArraysIndirect`**, **`glMultiDrawElementsIndirect`**

    **/
    static function multiDrawArraysIndirect(mode:Int, in_direct:DataPointer, drawcount:Int, stride:Int):Void return ExtensionsNative.multiDrawArraysIndirect(mode, in_direct, drawcount, stride);
    static function multiDrawArraysIndirectAMD(mode:Int, in_direct:DataPointer, primcount:Int, stride:Int):Void return ExtensionsNative.multiDrawArraysIndirectAMD(mode, in_direct, primcount, stride);
    static function multiDrawArraysIndirectBindlessCountNV(mode:Int, in_direct:DataPointer, drawCount:Int, maxDrawCount:Int, stride:Int, vertexBufferCount:Int):Void return ExtensionsNative.multiDrawArraysIndirectBindlessCountNV(mode, in_direct, drawCount, maxDrawCount, stride, vertexBufferCount);
    static function multiDrawArraysIndirectBindlessNV(mode:Int, in_direct:DataPointer, drawCount:Int, stride:Int, vertexBufferCount:Int):Void return ExtensionsNative.multiDrawArraysIndirectBindlessNV(mode, in_direct, drawCount, stride, vertexBufferCount);
    static function multiDrawArraysIndirectCount(mode:Int, in_direct:DataPointer, drawcount:Int, maxdrawcount:Int, stride:Int):Void return ExtensionsNative.multiDrawArraysIndirectCount(mode, in_direct, drawcount, maxdrawcount, stride);
    static function multiDrawArraysIndirectCountARB(mode:Int, in_direct:DataPointer, drawcount:Int, maxdrawcount:Int, stride:Int):Void return ExtensionsNative.multiDrawArraysIndirectCountARB(mode, in_direct, drawcount, maxdrawcount, stride);
    static function multiDrawArraysIndirectEXT(mode:Int, in_direct:DataPointer, drawcount:Int, stride:Int):Void return ExtensionsNative.multiDrawArraysIndirectEXT(mode, in_direct, drawcount, stride);
    static function multiDrawElementArrayAPPLE(mode:Int, first:DataPointer, count:DataPointer, primcount:Int):Void return ExtensionsNative.multiDrawElementArrayAPPLE(mode, first, count, primcount);
    /**
    * - #### Purpose:
    * render multiple sets of primitives by specifying indices of array data elements
    * ### Description:
    * **glMultiDrawElements** specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to **glMultiDrawElements**.
    * 
    * **glMultiDrawElements** is identical in operation to **`glDrawElements`** except that **drawcount** separate lists of elements are specified.
    * 
    * Vertex attributes that are modified by **glMultiDrawElements** have an unspecified value after **glMultiDrawElements** returns. Attributes that aren't modified maintain their previous values.
    * 
    * 
    * ### Notes:
    * `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **drawcount** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param count Points to an array of the elements counts.
    * @param type Specifies the type of the values in **indices**. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.
    * @param indices Specifies a pointer to the location where the indices are stored.
    * @param drawcount Specifies the size of the **count** and **indices** arrays.

    * @see **`glDrawArrays`**, **`glDrawRangeElements`**

    **/
    static function multiDrawElements(mode:Int, count:DataPointer, type:Int, in_dices:DataPointer, drawcount:Int):Void return ExtensionsNative.multiDrawElements(mode, count, type, in_dices, drawcount);
    /**
    * - #### Purpose:
    * render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
    * ### Description:
    * **glMultiDrawElementsBaseVertex** behaves identically to **`glDrawElementsBaseVertex`**, except that **drawcount** separate lists of elements are specifried instead.
    * 
    * It has the same effect as: for (int i = 0; i &lt; **drawcount**; i++) if (**count**[i] &gt; 0) glDrawElementsBaseVertex(**mode**, **count**[i], **type**, **indices[i]**, **basevertex[i]**);
    * 
    * 
    * ### Notes:
    * **glMultiDrawElementsBaseVertex** is available only if the GL version is 3.1 or greater.
    * 
    * `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **drawcount** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.
    * @param count Points to an array of the elements counts.
    * @param type Specifies the type of the values in **indices**. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.
    * @param indices Specifies a pointer to the location where the indices are stored.
    * @param drawcount Specifies the size of the **count**, **indices** and **basevertex** arrays.
    * @param basevertex Specifies a pointer to the location where the base vertices are stored.

    * @see **`glMultiDrawElements`**, **`glDrawElementsBaseVertex`**, **`glDrawArrays`**, **`glVertexAttribPointer`**

    **/
    static function multiDrawElementsBaseVertex(mode:Int, count:DataPointer, type:Int, in_dices:DataPointer, drawcount:Int, basevertex:DataPointer):Void return ExtensionsNative.multiDrawElementsBaseVertex(mode, count, type, in_dices, drawcount, basevertex);
    static function multiDrawElementsBaseVertexEXT(mode:Int, count:DataPointer, type:Int, in_dices:DataPointer, drawcount:Int, basevertex:DataPointer):Void return ExtensionsNative.multiDrawElementsBaseVertexEXT(mode, count, type, in_dices, drawcount, basevertex);
    static function multiDrawElementsEXT(mode:Int, count:DataPointer, type:Int, in_dices:DataPointer, primcount:Int):Void return ExtensionsNative.multiDrawElementsEXT(mode, count, type, in_dices, primcount);
    /**
    * - #### Purpose:
    * render indexed primitives from array data, taking parameters from memory
    * ### Description:
    * **glMultiDrawElementsIndirect** specifies multiple indexed geometric primitives with very few subroutine calls. **glMultiDrawElementsIndirect** behaves similarly to a multitude of calls to **`glDrawElementsInstancedBaseVertexBaseInstance`**, execpt that the parameters to **`glDrawElementsInstancedBaseVertexBaseInstance`** are stored in an array in memory at the address given by **indirect**, separated by the stride, in basic machine units, specified by **stride**. If **stride** is zero, then the array is assumed to be tightly packed in memory.
    * 
    * The parameters addressed by **indirect** are packed into a structure that takes the form (in C): typedef struct { uint count; uint instanceCount; uint firstIndex; int baseVertex; uint baseInstance; } DrawElementsIndirectCommand;
    * 
    * A single call to **glMultiDrawElementsIndirect** is equivalent, assuming no errors are generated to: GLsizei n; for (n = 0; n &lt; drawcount; n++) { const DrawElementsIndirectCommand *cmd; if (stride != 0) { cmd = (const DrawElementsIndirectCommand *)((uintptr)indirect + n * stride); } else { cmd = (const DrawElementsIndirectCommand *)indirect + n; } glDrawElementsInstancedBaseVertexBaseInstance(mode, cmd-&gt;count, type, cmd-&gt;firstIndex * size-of-type, cmd-&gt;instanceCount, cmd-&gt;baseVertex, cmd-&gt;baseInstance); }
    * 
    * If a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to **glDrawElementsIndirect**, **indirect** is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory.
    * 
    * Note that indices stored in client memory are not supported. If no buffer is bound to the `GL_ELEMENT_ARRAY_BUFFER` binding, an error will be generated.
    * 
    * The results of the operation are undefined if the reservedMustBeZero member of the parameter structure is non-zero. However, no error is generated in this case.
    * 
    * Vertex attributes that are modified by **glDrawElementsIndirect** have an unspecified value after **glDrawElementsIndirect** returns. Attributes that aren't modified remain well defined.
    * 
    * 
    * ### Notes:
    * The **baseInstance** member of the **DrawElementsIndirectCommand** structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **stride** is not a multiple of four.
    * 
    * `GL_INVALID_VALUE` is generated if **drawcount** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if no buffer is bound to the `GL_ELEMENT_ARRAY_BUFFER` binding, or if such a buffer's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a geometry shader is active and **mode** is incompatible with the input primitive type of the geometry shader in the currently installed program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **mode** is `GL_PATCHES` and no tessellation control shader is active.
    * 
    * @param mode Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.
    * @param type Specifies the type of data in the buffer bound to the `GL_ELEMENT_ARRAY_BUFFER` binding.
    * @param indirect Specifies the address of a structure containing an array of draw parameters.
    * @param drawcount Specifies the number of elements in the array addressed by **indirect**.
    * @param stride Specifies the distance in basic machine units between elements of the draw parameter array.

    * @see **`glDrawArrays`**, **`glDrawArraysInstanced`**, **`glDrawArraysIndirect`**, **`glDrawElements`**, **`glDrawRangeElements`**, **`glDrawElementsIndirect`**, **`glMultiDrawArraysIndirect`**

    **/
    static function multiDrawElementsIndirect(mode:Int, type:Int, in_direct:DataPointer, drawcount:Int, stride:Int):Void return ExtensionsNative.multiDrawElementsIndirect(mode, type, in_direct, drawcount, stride);
    static function multiDrawElementsIndirectAMD(mode:Int, type:Int, in_direct:DataPointer, primcount:Int, stride:Int):Void return ExtensionsNative.multiDrawElementsIndirectAMD(mode, type, in_direct, primcount, stride);
    static function multiDrawElementsIndirectBindlessCountNV(mode:Int, type:Int, in_direct:DataPointer, drawCount:Int, maxDrawCount:Int, stride:Int, vertexBufferCount:Int):Void return ExtensionsNative.multiDrawElementsIndirectBindlessCountNV(mode, type, in_direct, drawCount, maxDrawCount, stride, vertexBufferCount);
    static function multiDrawElementsIndirectBindlessNV(mode:Int, type:Int, in_direct:DataPointer, drawCount:Int, stride:Int, vertexBufferCount:Int):Void return ExtensionsNative.multiDrawElementsIndirectBindlessNV(mode, type, in_direct, drawCount, stride, vertexBufferCount);
    static function multiDrawElementsIndirectCount(mode:Int, type:Int, in_direct:DataPointer, drawcount:Int, maxdrawcount:Int, stride:Int):Void return ExtensionsNative.multiDrawElementsIndirectCount(mode, type, in_direct, drawcount, maxdrawcount, stride);
    static function multiDrawElementsIndirectCountARB(mode:Int, type:Int, in_direct:DataPointer, drawcount:Int, maxdrawcount:Int, stride:Int):Void return ExtensionsNative.multiDrawElementsIndirectCountARB(mode, type, in_direct, drawcount, maxdrawcount, stride);
    static function multiDrawElementsIndirectEXT(mode:Int, type:Int, in_direct:DataPointer, drawcount:Int, stride:Int):Void return ExtensionsNative.multiDrawElementsIndirectEXT(mode, type, in_direct, drawcount, stride);
    static function multiDrawMeshTasksIndirectNV(in_direct:Int, drawcount:Int, stride:Int):Void return ExtensionsNative.multiDrawMeshTasksIndirectNV(in_direct, drawcount, stride);
    static function multiDrawMeshTasksIndirectCountNV(in_direct:Int, drawcount:Int, maxdrawcount:Int, stride:Int):Void return ExtensionsNative.multiDrawMeshTasksIndirectCountNV(in_direct, drawcount, maxdrawcount, stride);
    static function multiDrawRangeElementArrayAPPLE(mode:Int, start:Int, end:Int, first:DataPointer, count:DataPointer, primcount:Int):Void return ExtensionsNative.multiDrawRangeElementArrayAPPLE(mode, start, end, first, count, primcount);
    static function multiModeDrawArraysIBM(mode:DataPointer, first:DataPointer, count:DataPointer, primcount:Int, modestride:Int):Void return ExtensionsNative.multiModeDrawArraysIBM(mode, first, count, primcount, modestride);
    static function multiModeDrawElementsIBM(mode:DataPointer, count:DataPointer, type:Int, in_dices:DataPointer, primcount:Int, modestride:Int):Void return ExtensionsNative.multiModeDrawElementsIBM(mode, count, type, in_dices, primcount, modestride);
    static function multiTexBufferEXT(texunit:Int, target:Int, in_ternalformat:Int, buffer:Int):Void return ExtensionsNative.multiTexBufferEXT(texunit, target, in_ternalformat, buffer);
    static function multiTexCoord1bOES(texture:Int, s:Int):Void return ExtensionsNative.multiTexCoord1bOES(texture, s);
    static function multiTexCoord1bvOES(texture:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoord1bvOES(texture, coords);
    static function multiTexCoord1d(target:Int, s:DataPointer):Void return ExtensionsNative.multiTexCoord1d(target, s);
    static function multiTexCoord1dARB(target:Int, s:DataPointer):Void return ExtensionsNative.multiTexCoord1dARB(target, s);
    static function multiTexCoord1dv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord1dv(target, v);
    static function multiTexCoord1dvARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord1dvARB(target, v);
    static function multiTexCoord1f(target:Int, s:Float):Void return ExtensionsNative.multiTexCoord1f(target, s);
    static function multiTexCoord1fARB(target:Int, s:Float):Void return ExtensionsNative.multiTexCoord1fARB(target, s);
    static function multiTexCoord1fv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord1fv(target, v);
    static function multiTexCoord1fvARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord1fvARB(target, v);
    static function multiTexCoord1hNV(target:Int, s:Int):Void return ExtensionsNative.multiTexCoord1hNV(target, s);
    static function multiTexCoord1hvNV(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord1hvNV(target, v);
    static function multiTexCoord1i(target:Int, s:Int):Void return ExtensionsNative.multiTexCoord1i(target, s);
    static function multiTexCoord1iARB(target:Int, s:Int):Void return ExtensionsNative.multiTexCoord1iARB(target, s);
    static function multiTexCoord1iv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord1iv(target, v);
    static function multiTexCoord1ivARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord1ivARB(target, v);
    static function multiTexCoord1s(target:Int, s:Int):Void return ExtensionsNative.multiTexCoord1s(target, s);
    static function multiTexCoord1sARB(target:Int, s:Int):Void return ExtensionsNative.multiTexCoord1sARB(target, s);
    static function multiTexCoord1sv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord1sv(target, v);
    static function multiTexCoord1svARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord1svARB(target, v);
    static function multiTexCoord1xOES(texture:Int, s:Int):Void return ExtensionsNative.multiTexCoord1xOES(texture, s);
    static function multiTexCoord1xvOES(texture:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoord1xvOES(texture, coords);
    static function multiTexCoord2bOES(texture:Int, s:Int, t:Int):Void return ExtensionsNative.multiTexCoord2bOES(texture, s, t);
    static function multiTexCoord2bvOES(texture:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoord2bvOES(texture, coords);
    static function multiTexCoord2d(target:Int, s:DataPointer, t:DataPointer):Void return ExtensionsNative.multiTexCoord2d(target, s, t);
    static function multiTexCoord2dARB(target:Int, s:DataPointer, t:DataPointer):Void return ExtensionsNative.multiTexCoord2dARB(target, s, t);
    static function multiTexCoord2dv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord2dv(target, v);
    static function multiTexCoord2dvARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord2dvARB(target, v);
    static function multiTexCoord2f(target:Int, s:Float, t:Float):Void return ExtensionsNative.multiTexCoord2f(target, s, t);
    static function multiTexCoord2fARB(target:Int, s:Float, t:Float):Void return ExtensionsNative.multiTexCoord2fARB(target, s, t);
    static function multiTexCoord2fv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord2fv(target, v);
    static function multiTexCoord2fvARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord2fvARB(target, v);
    static function multiTexCoord2hNV(target:Int, s:Int, t:Int):Void return ExtensionsNative.multiTexCoord2hNV(target, s, t);
    static function multiTexCoord2hvNV(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord2hvNV(target, v);
    static function multiTexCoord2i(target:Int, s:Int, t:Int):Void return ExtensionsNative.multiTexCoord2i(target, s, t);
    static function multiTexCoord2iARB(target:Int, s:Int, t:Int):Void return ExtensionsNative.multiTexCoord2iARB(target, s, t);
    static function multiTexCoord2iv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord2iv(target, v);
    static function multiTexCoord2ivARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord2ivARB(target, v);
    static function multiTexCoord2s(target:Int, s:Int, t:Int):Void return ExtensionsNative.multiTexCoord2s(target, s, t);
    static function multiTexCoord2sARB(target:Int, s:Int, t:Int):Void return ExtensionsNative.multiTexCoord2sARB(target, s, t);
    static function multiTexCoord2sv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord2sv(target, v);
    static function multiTexCoord2svARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord2svARB(target, v);
    static function multiTexCoord2xOES(texture:Int, s:Int, t:Int):Void return ExtensionsNative.multiTexCoord2xOES(texture, s, t);
    static function multiTexCoord2xvOES(texture:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoord2xvOES(texture, coords);
    static function multiTexCoord3bOES(texture:Int, s:Int, t:Int, r:Int):Void return ExtensionsNative.multiTexCoord3bOES(texture, s, t, r);
    static function multiTexCoord3bvOES(texture:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoord3bvOES(texture, coords);
    static function multiTexCoord3d(target:Int, s:DataPointer, t:DataPointer, r:DataPointer):Void return ExtensionsNative.multiTexCoord3d(target, s, t, r);
    static function multiTexCoord3dARB(target:Int, s:DataPointer, t:DataPointer, r:DataPointer):Void return ExtensionsNative.multiTexCoord3dARB(target, s, t, r);
    static function multiTexCoord3dv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord3dv(target, v);
    static function multiTexCoord3dvARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord3dvARB(target, v);
    static function multiTexCoord3f(target:Int, s:Float, t:Float, r:Float):Void return ExtensionsNative.multiTexCoord3f(target, s, t, r);
    static function multiTexCoord3fARB(target:Int, s:Float, t:Float, r:Float):Void return ExtensionsNative.multiTexCoord3fARB(target, s, t, r);
    static function multiTexCoord3fv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord3fv(target, v);
    static function multiTexCoord3fvARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord3fvARB(target, v);
    static function multiTexCoord3hNV(target:Int, s:Int, t:Int, r:Int):Void return ExtensionsNative.multiTexCoord3hNV(target, s, t, r);
    static function multiTexCoord3hvNV(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord3hvNV(target, v);
    static function multiTexCoord3i(target:Int, s:Int, t:Int, r:Int):Void return ExtensionsNative.multiTexCoord3i(target, s, t, r);
    static function multiTexCoord3iARB(target:Int, s:Int, t:Int, r:Int):Void return ExtensionsNative.multiTexCoord3iARB(target, s, t, r);
    static function multiTexCoord3iv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord3iv(target, v);
    static function multiTexCoord3ivARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord3ivARB(target, v);
    static function multiTexCoord3s(target:Int, s:Int, t:Int, r:Int):Void return ExtensionsNative.multiTexCoord3s(target, s, t, r);
    static function multiTexCoord3sARB(target:Int, s:Int, t:Int, r:Int):Void return ExtensionsNative.multiTexCoord3sARB(target, s, t, r);
    static function multiTexCoord3sv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord3sv(target, v);
    static function multiTexCoord3svARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord3svARB(target, v);
    static function multiTexCoord3xOES(texture:Int, s:Int, t:Int, r:Int):Void return ExtensionsNative.multiTexCoord3xOES(texture, s, t, r);
    static function multiTexCoord3xvOES(texture:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoord3xvOES(texture, coords);
    static function multiTexCoord4bOES(texture:Int, s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.multiTexCoord4bOES(texture, s, t, r, q);
    static function multiTexCoord4bvOES(texture:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoord4bvOES(texture, coords);
    static function multiTexCoord4d(target:Int, s:DataPointer, t:DataPointer, r:DataPointer, q:DataPointer):Void return ExtensionsNative.multiTexCoord4d(target, s, t, r, q);
    static function multiTexCoord4dARB(target:Int, s:DataPointer, t:DataPointer, r:DataPointer, q:DataPointer):Void return ExtensionsNative.multiTexCoord4dARB(target, s, t, r, q);
    static function multiTexCoord4dv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord4dv(target, v);
    static function multiTexCoord4dvARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord4dvARB(target, v);
    static function multiTexCoord4f(target:Int, s:Float, t:Float, r:Float, q:Float):Void return ExtensionsNative.multiTexCoord4f(target, s, t, r, q);
    static function multiTexCoord4fARB(target:Int, s:Float, t:Float, r:Float, q:Float):Void return ExtensionsNative.multiTexCoord4fARB(target, s, t, r, q);
    static function multiTexCoord4fv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord4fv(target, v);
    static function multiTexCoord4fvARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord4fvARB(target, v);
    static function multiTexCoord4hNV(target:Int, s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.multiTexCoord4hNV(target, s, t, r, q);
    static function multiTexCoord4hvNV(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord4hvNV(target, v);
    static function multiTexCoord4i(target:Int, s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.multiTexCoord4i(target, s, t, r, q);
    static function multiTexCoord4iARB(target:Int, s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.multiTexCoord4iARB(target, s, t, r, q);
    static function multiTexCoord4iv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord4iv(target, v);
    static function multiTexCoord4ivARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord4ivARB(target, v);
    static function multiTexCoord4s(target:Int, s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.multiTexCoord4s(target, s, t, r, q);
    static function multiTexCoord4sARB(target:Int, s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.multiTexCoord4sARB(target, s, t, r, q);
    static function multiTexCoord4sv(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord4sv(target, v);
    static function multiTexCoord4svARB(target:Int, v:DataPointer):Void return ExtensionsNative.multiTexCoord4svARB(target, v);
    static function multiTexCoord4x(texture:Int, s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.multiTexCoord4x(texture, s, t, r, q);
    static function multiTexCoord4xOES(texture:Int, s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.multiTexCoord4xOES(texture, s, t, r, q);
    static function multiTexCoord4xvOES(texture:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoord4xvOES(texture, coords);
    static function multiTexCoordP1ui(texture:Int, type:Int, coords:Int):Void return ExtensionsNative.multiTexCoordP1ui(texture, type, coords);
    static function multiTexCoordP1uiv(texture:Int, type:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoordP1uiv(texture, type, coords);
    static function multiTexCoordP2ui(texture:Int, type:Int, coords:Int):Void return ExtensionsNative.multiTexCoordP2ui(texture, type, coords);
    static function multiTexCoordP2uiv(texture:Int, type:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoordP2uiv(texture, type, coords);
    static function multiTexCoordP3ui(texture:Int, type:Int, coords:Int):Void return ExtensionsNative.multiTexCoordP3ui(texture, type, coords);
    static function multiTexCoordP3uiv(texture:Int, type:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoordP3uiv(texture, type, coords);
    static function multiTexCoordP4ui(texture:Int, type:Int, coords:Int):Void return ExtensionsNative.multiTexCoordP4ui(texture, type, coords);
    static function multiTexCoordP4uiv(texture:Int, type:Int, coords:DataPointer):Void return ExtensionsNative.multiTexCoordP4uiv(texture, type, coords);
    static function multiTexCoordPointerEXT(texunit:Int, size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.multiTexCoordPointerEXT(texunit, size, type, stride, poin_ter);
    static function multiTexEnvfEXT(texunit:Int, target:Int, pname:Int, param:Float):Void return ExtensionsNative.multiTexEnvfEXT(texunit, target, pname, param);
    static function multiTexEnvfvEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multiTexEnvfvEXT(texunit, target, pname, params);
    static function multiTexEnviEXT(texunit:Int, target:Int, pname:Int, param:Int):Void return ExtensionsNative.multiTexEnviEXT(texunit, target, pname, param);
    static function multiTexEnvivEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multiTexEnvivEXT(texunit, target, pname, params);
    static function multiTexGendEXT(texunit:Int, coord:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.multiTexGendEXT(texunit, coord, pname, param);
    static function multiTexGendvEXT(texunit:Int, coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multiTexGendvEXT(texunit, coord, pname, params);
    static function multiTexGenfEXT(texunit:Int, coord:Int, pname:Int, param:Float):Void return ExtensionsNative.multiTexGenfEXT(texunit, coord, pname, param);
    static function multiTexGenfvEXT(texunit:Int, coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multiTexGenfvEXT(texunit, coord, pname, params);
    static function multiTexGeniEXT(texunit:Int, coord:Int, pname:Int, param:Int):Void return ExtensionsNative.multiTexGeniEXT(texunit, coord, pname, param);
    static function multiTexGenivEXT(texunit:Int, coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multiTexGenivEXT(texunit, coord, pname, params);
    static function multiTexImage1DEXT(texunit:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.multiTexImage1DEXT(texunit, target, level, in_ternalformat, width, border, format, type, pixels);
    static function multiTexImage2DEXT(texunit:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.multiTexImage2DEXT(texunit, target, level, in_ternalformat, width, height, border, format, type, pixels);
    static function multiTexImage3DEXT(texunit:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.multiTexImage3DEXT(texunit, target, level, in_ternalformat, width, height, depth, border, format, type, pixels);
    static function multiTexParameterIivEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multiTexParameterIivEXT(texunit, target, pname, params);
    static function multiTexParameterIuivEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multiTexParameterIuivEXT(texunit, target, pname, params);
    static function multiTexParameterfEXT(texunit:Int, target:Int, pname:Int, param:Float):Void return ExtensionsNative.multiTexParameterfEXT(texunit, target, pname, param);
    static function multiTexParameterfvEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multiTexParameterfvEXT(texunit, target, pname, params);
    static function multiTexParameteriEXT(texunit:Int, target:Int, pname:Int, param:Int):Void return ExtensionsNative.multiTexParameteriEXT(texunit, target, pname, param);
    static function multiTexParameterivEXT(texunit:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multiTexParameterivEXT(texunit, target, pname, params);
    static function multiTexRenderbufferEXT(texunit:Int, target:Int, renderbuffer:Int):Void return ExtensionsNative.multiTexRenderbufferEXT(texunit, target, renderbuffer);
    static function multiTexSubImage1DEXT(texunit:Int, target:Int, level:Int, xoffset:Int, width:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.multiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels);
    static function multiTexSubImage2DEXT(texunit:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.multiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
    static function multiTexSubImage3DEXT(texunit:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.multiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    static function multicastBarrierNV():Void return ExtensionsNative.multicastBarrierNV();
    static function multicastBlitFramebufferNV(srcGpu:Int, dstGpu:Int, srcX0:Int, srcY0:Int, srcX1:Int, srcY1:Int, dstX0:Int, dstY0:Int, dstX1:Int, dstY1:Int, mask:Int, filter:Int):Void return ExtensionsNative.multicastBlitFramebufferNV(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    static function multicastBufferSubDataNV(gpuMask:Int, buffer:Int, offset:Int, size:Int, data:DataPointer):Void return ExtensionsNative.multicastBufferSubDataNV(gpuMask, buffer, offset, size, data);
    static function multicastCopyBufferSubDataNV(readGpu:Int, writeGpuMask:Int, readBuffer:Int, writeBuffer:Int, readOffset:Int, writeOffset:Int, size:Int):Void return ExtensionsNative.multicastCopyBufferSubDataNV(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
    static function multicastCopyImageSubDataNV(srcGpu:Int, dstGpuMask:Int, srcName:Int, srcTarget:Int, srcLevel:Int, srcX:Int, srcY:Int, srcZ:Int, dstName:Int, dstTarget:Int, dstLevel:Int, dstX:Int, dstY:Int, dstZ:Int, srcWidth:Int, srcHeight:Int, srcDepth:Int):Void return ExtensionsNative.multicastCopyImageSubDataNV(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    static function multicastFramebufferSampleLocationsfvNV(gpu:Int, framebuffer:Int, start:Int, count:Int, v:DataPointer):Void return ExtensionsNative.multicastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, v);
    static function multicastGetQueryObjecti64vNV(gpu:Int, id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multicastGetQueryObjecti64vNV(gpu, id, pname, params);
    static function multicastGetQueryObjectivNV(gpu:Int, id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multicastGetQueryObjectivNV(gpu, id, pname, params);
    static function multicastGetQueryObjectui64vNV(gpu:Int, id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multicastGetQueryObjectui64vNV(gpu, id, pname, params);
    static function multicastGetQueryObjectuivNV(gpu:Int, id:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.multicastGetQueryObjectuivNV(gpu, id, pname, params);
    static function multicastScissorArrayvNVX(gpu:Int, first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.multicastScissorArrayvNVX(gpu, first, count, v);
    static function multicastViewportArrayvNVX(gpu:Int, first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.multicastViewportArrayvNVX(gpu, first, count, v);
    static function multicastViewportPositionWScaleNVX(gpu:Int, in_dex:Int, xcoeff:Float, ycoeff:Float):Void return ExtensionsNative.multicastViewportPositionWScaleNVX(gpu, in_dex, xcoeff, ycoeff);
    static function multicastWaitSyncNV(signalGpu:Int, waitGpuMask:Int):Void return ExtensionsNative.multicastWaitSyncNV(signalGpu, waitGpuMask);
    static function namedBufferAttachMemoryNV(buffer:Int, memory:Int, offset:Int):Void return ExtensionsNative.namedBufferAttachMemoryNV(buffer, memory, offset);
    static function namedBufferData(buffer:Int, size:Int, data:DataPointer, usage:Int):Void return ExtensionsNative.namedBufferData(buffer, size, data, usage);
    static function namedBufferDataEXT(buffer:Int, size:Int, data:DataPointer, usage:Int):Void return ExtensionsNative.namedBufferDataEXT(buffer, size, data, usage);
    static function namedBufferPageCommitmentARB(buffer:Int, offset:Int, size:Int, commit:Bool):Void return ExtensionsNative.namedBufferPageCommitmentARB(buffer, offset, size, commit);
    static function namedBufferPageCommitmentEXT(buffer:Int, offset:Int, size:Int, commit:Bool):Void return ExtensionsNative.namedBufferPageCommitmentEXT(buffer, offset, size, commit);
    static function namedBufferPageCommitmentMemNV(buffer:Int, offset:Int, size:Int, memory:Int, memOffset:Int, commit:Bool):Void return ExtensionsNative.namedBufferPageCommitmentMemNV(buffer, offset, size, memory, memOffset, commit);
    static function namedBufferStorage(buffer:Int, size:Int, data:DataPointer, flags:Int):Void return ExtensionsNative.namedBufferStorage(buffer, size, data, flags);
    static function namedBufferStorageExternalEXT(buffer:Int, offset:Int, size:Int, clientBuffer:DataPointer, flags:Int):Void return ExtensionsNative.namedBufferStorageExternalEXT(buffer, offset, size, clientBuffer, flags);
    static function namedBufferStorageEXT(buffer:Int, size:Int, data:DataPointer, flags:Int):Void return ExtensionsNative.namedBufferStorageEXT(buffer, size, data, flags);
    static function namedBufferStorageMemEXT(buffer:Int, size:Int, memory:Int, offset:Int):Void return ExtensionsNative.namedBufferStorageMemEXT(buffer, size, memory, offset);
    static function namedBufferSubData(buffer:Int, offset:Int, size:Int, data:DataPointer):Void return ExtensionsNative.namedBufferSubData(buffer, offset, size, data);
    static function namedBufferSubDataEXT(buffer:Int, offset:Int, size:Int, data:DataPointer):Void return ExtensionsNative.namedBufferSubDataEXT(buffer, offset, size, data);
    static function namedCopyBufferSubDataEXT(readBuffer:Int, writeBuffer:Int, readOffset:Int, writeOffset:Int, size:Int):Void return ExtensionsNative.namedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
    static function namedFramebufferDrawBuffer(framebuffer:Int, buf:Int):Void return ExtensionsNative.namedFramebufferDrawBuffer(framebuffer, buf);
    static function namedFramebufferDrawBuffers(framebuffer:Int, n:Int, bufs:DataPointer):Void return ExtensionsNative.namedFramebufferDrawBuffers(framebuffer, n, bufs);
    static function namedFramebufferParameteri(framebuffer:Int, pname:Int, param:Int):Void return ExtensionsNative.namedFramebufferParameteri(framebuffer, pname, param);
    static function namedFramebufferParameteriEXT(framebuffer:Int, pname:Int, param:Int):Void return ExtensionsNative.namedFramebufferParameteriEXT(framebuffer, pname, param);
    static function namedFramebufferReadBuffer(framebuffer:Int, src:Int):Void return ExtensionsNative.namedFramebufferReadBuffer(framebuffer, src);
    static function namedFramebufferRenderbuffer(framebuffer:Int, attachment:Int, renderbuffertarget:Int, renderbuffer:Int):Void return ExtensionsNative.namedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);
    static function namedFramebufferRenderbufferEXT(framebuffer:Int, attachment:Int, renderbuffertarget:Int, renderbuffer:Int):Void return ExtensionsNative.namedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer);
    static function namedFramebufferSampleLocationsfvARB(framebuffer:Int, start:Int, count:Int, v:DataPointer):Void return ExtensionsNative.namedFramebufferSampleLocationsfvARB(framebuffer, start, count, v);
    static function namedFramebufferSampleLocationsfvNV(framebuffer:Int, start:Int, count:Int, v:DataPointer):Void return ExtensionsNative.namedFramebufferSampleLocationsfvNV(framebuffer, start, count, v);
    static function namedFramebufferTexture(framebuffer:Int, attachment:Int, texture:Int, level:Int):Void return ExtensionsNative.namedFramebufferTexture(framebuffer, attachment, texture, level);
    static function namedFramebufferSamplePositionsfvAMD(framebuffer:Int, numsamples:Int, pixelin_dex:Int, values:DataPointer):Void return ExtensionsNative.namedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelin_dex, values);
    static function namedFramebufferTexture1DEXT(framebuffer:Int, attachment:Int, textarget:Int, texture:Int, level:Int):Void return ExtensionsNative.namedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);
    static function namedFramebufferTexture2DEXT(framebuffer:Int, attachment:Int, textarget:Int, texture:Int, level:Int):Void return ExtensionsNative.namedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);
    static function namedFramebufferTexture3DEXT(framebuffer:Int, attachment:Int, textarget:Int, texture:Int, level:Int, zoffset:Int):Void return ExtensionsNative.namedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);
    static function namedFramebufferTextureEXT(framebuffer:Int, attachment:Int, texture:Int, level:Int):Void return ExtensionsNative.namedFramebufferTextureEXT(framebuffer, attachment, texture, level);
    static function namedFramebufferTextureFaceEXT(framebuffer:Int, attachment:Int, texture:Int, level:Int, face:Int):Void return ExtensionsNative.namedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);
    static function namedFramebufferTextureLayer(framebuffer:Int, attachment:Int, texture:Int, level:Int, layer:Int):Void return ExtensionsNative.namedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);
    static function namedFramebufferTextureLayerEXT(framebuffer:Int, attachment:Int, texture:Int, level:Int, layer:Int):Void return ExtensionsNative.namedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer);
    static function namedFramebufferTextureMultiviewOVR(framebuffer:Int, attachment:Int, texture:Int, level:Int, baseViewIndex:Int, numViews:Int):Void return ExtensionsNative.namedFramebufferTextureMultiviewOVR(framebuffer, attachment, texture, level, baseViewIndex, numViews);
    static function namedProgramLocalParameter4dEXT(program:Int, target:Int, in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.namedProgramLocalParameter4dEXT(program, target, in_dex, x, y, z, w);
    static function namedProgramLocalParameter4dvEXT(program:Int, target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.namedProgramLocalParameter4dvEXT(program, target, in_dex, params);
    static function namedProgramLocalParameter4fEXT(program:Int, target:Int, in_dex:Int, x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.namedProgramLocalParameter4fEXT(program, target, in_dex, x, y, z, w);
    static function namedProgramLocalParameter4fvEXT(program:Int, target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.namedProgramLocalParameter4fvEXT(program, target, in_dex, params);
    static function namedProgramLocalParameterI4iEXT(program:Int, target:Int, in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.namedProgramLocalParameterI4iEXT(program, target, in_dex, x, y, z, w);
    static function namedProgramLocalParameterI4ivEXT(program:Int, target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.namedProgramLocalParameterI4ivEXT(program, target, in_dex, params);
    static function namedProgramLocalParameterI4uiEXT(program:Int, target:Int, in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.namedProgramLocalParameterI4uiEXT(program, target, in_dex, x, y, z, w);
    static function namedProgramLocalParameterI4uivEXT(program:Int, target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.namedProgramLocalParameterI4uivEXT(program, target, in_dex, params);
    static function namedProgramLocalParameters4fvEXT(program:Int, target:Int, in_dex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.namedProgramLocalParameters4fvEXT(program, target, in_dex, count, params);
    static function namedProgramLocalParametersI4ivEXT(program:Int, target:Int, in_dex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.namedProgramLocalParametersI4ivEXT(program, target, in_dex, count, params);
    static function namedProgramLocalParametersI4uivEXT(program:Int, target:Int, in_dex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.namedProgramLocalParametersI4uivEXT(program, target, in_dex, count, params);
    static function namedProgramStringEXT(program:Int, target:Int, format:Int, len:Int, strin_g:DataPointer):Void return ExtensionsNative.namedProgramStringEXT(program, target, format, len, strin_g);
    static function namedRenderbufferStorage(renderbuffer:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.namedRenderbufferStorage(renderbuffer, in_ternalformat, width, height);
    static function namedRenderbufferStorageEXT(renderbuffer:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.namedRenderbufferStorageEXT(renderbuffer, in_ternalformat, width, height);
    static function namedRenderbufferStorageMultisample(renderbuffer:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.namedRenderbufferStorageMultisample(renderbuffer, samples, in_ternalformat, width, height);
    static function namedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer:Int, samples:Int, storageSamples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.namedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer, samples, storageSamples, in_ternalformat, width, height);
    static function namedRenderbufferStorageMultisampleCoverageEXT(renderbuffer:Int, coverageSamples:Int, colorSamples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.namedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, in_ternalformat, width, height);
    static function namedRenderbufferStorageMultisampleEXT(renderbuffer:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.namedRenderbufferStorageMultisampleEXT(renderbuffer, samples, in_ternalformat, width, height);
    static function namedStringARB(type:Int, namelen:Int, name:String, strin_glen:Int, strin_g:String):Void return ExtensionsNative.namedStringARB(type, namelen, name, strin_glen, strin_g);
    static function newList(list:Int, mode:Int):Void return ExtensionsNative.newList(list, mode);
    static function newObjectBufferATI(size:Int, poin_ter:DataPointer, usage:Int):Int return ExtensionsNative.newObjectBufferATI(size, poin_ter, usage);
    static function normal3b(nx:Int, ny:Int, nz:Int):Void return ExtensionsNative.normal3b(nx, ny, nz);
    static function normal3bv(v:DataPointer):Void return ExtensionsNative.normal3bv(v);
    static function normal3d(nx:DataPointer, ny:DataPointer, nz:DataPointer):Void return ExtensionsNative.normal3d(nx, ny, nz);
    static function normal3dv(v:DataPointer):Void return ExtensionsNative.normal3dv(v);
    static function normal3f(nx:Float, ny:Float, nz:Float):Void return ExtensionsNative.normal3f(nx, ny, nz);
    static function normal3fVertex3fSUN(nx:Float, ny:Float, nz:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.normal3fVertex3fSUN(nx, ny, nz, x, y, z);
    static function normal3fVertex3fvSUN(n:DataPointer, v:DataPointer):Void return ExtensionsNative.normal3fVertex3fvSUN(n, v);
    static function normal3fv(v:DataPointer):Void return ExtensionsNative.normal3fv(v);
    static function normal3hNV(nx:Int, ny:Int, nz:Int):Void return ExtensionsNative.normal3hNV(nx, ny, nz);
    static function normal3hvNV(v:DataPointer):Void return ExtensionsNative.normal3hvNV(v);
    static function normal3i(nx:Int, ny:Int, nz:Int):Void return ExtensionsNative.normal3i(nx, ny, nz);
    static function normal3iv(v:DataPointer):Void return ExtensionsNative.normal3iv(v);
    static function normal3s(nx:Int, ny:Int, nz:Int):Void return ExtensionsNative.normal3s(nx, ny, nz);
    static function normal3sv(v:DataPointer):Void return ExtensionsNative.normal3sv(v);
    static function normal3x(nx:Int, ny:Int, nz:Int):Void return ExtensionsNative.normal3x(nx, ny, nz);
    static function normal3xOES(nx:Int, ny:Int, nz:Int):Void return ExtensionsNative.normal3xOES(nx, ny, nz);
    static function normal3xvOES(coords:DataPointer):Void return ExtensionsNative.normal3xvOES(coords);
    static function normalFormatNV(type:Int, stride:Int):Void return ExtensionsNative.normalFormatNV(type, stride);
    static function normalP3ui(type:Int, coords:Int):Void return ExtensionsNative.normalP3ui(type, coords);
    static function normalP3uiv(type:Int, coords:DataPointer):Void return ExtensionsNative.normalP3uiv(type, coords);
    static function normalPointer(type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.normalPointer(type, stride, poin_ter);
    static function normalPointerEXT(type:Int, stride:Int, count:Int, poin_ter:DataPointer):Void return ExtensionsNative.normalPointerEXT(type, stride, count, poin_ter);
    static function normalPointerListIBM(type:Int, stride:Int, poin_ter:DataPointer, ptrstride:Int):Void return ExtensionsNative.normalPointerListIBM(type, stride, poin_ter, ptrstride);
    static function normalPointervINTEL(type:Int, poin_ter:DataPointer):Void return ExtensionsNative.normalPointervINTEL(type, poin_ter);
    static function normalStream3bATI(stream:Int, nx:Int, ny:Int, nz:Int):Void return ExtensionsNative.normalStream3bATI(stream, nx, ny, nz);
    static function normalStream3bvATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.normalStream3bvATI(stream, coords);
    static function normalStream3dATI(stream:Int, nx:DataPointer, ny:DataPointer, nz:DataPointer):Void return ExtensionsNative.normalStream3dATI(stream, nx, ny, nz);
    static function normalStream3dvATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.normalStream3dvATI(stream, coords);
    static function normalStream3fATI(stream:Int, nx:Float, ny:Float, nz:Float):Void return ExtensionsNative.normalStream3fATI(stream, nx, ny, nz);
    static function normalStream3fvATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.normalStream3fvATI(stream, coords);
    static function normalStream3iATI(stream:Int, nx:Int, ny:Int, nz:Int):Void return ExtensionsNative.normalStream3iATI(stream, nx, ny, nz);
    static function normalStream3ivATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.normalStream3ivATI(stream, coords);
    static function normalStream3sATI(stream:Int, nx:Int, ny:Int, nz:Int):Void return ExtensionsNative.normalStream3sATI(stream, nx, ny, nz);
    static function normalStream3svATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.normalStream3svATI(stream, coords);
    /**
    * - #### Purpose:
    * label a named object identified within a namespace
    * ### Description:
    * **glObjectLabel** labels the object identified by **name** within the namespace given by **identifier**. **identifier** must be one of `GL_BUFFER`, `GL_SHADER`, `GL_PROGRAM`, `GL_VERTEX_ARRAY`, `GL_QUERY`, `GL_PROGRAM_PIPELINE`, `GL_TRANSFORM_FEEDBACK`, `GL_SAMPLER`, `GL_TEXTURE`, `GL_RENDERBUFFER`, `GL_FRAMEBUFFER`, to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame buffers, respectively.
    * 
    * **label** is the address of a string that will be used to label an object. **length** contains the number of characters in **label**. If **length** is negative, it is implied that **label** contains a null-terminated string. If **label** is NULL, any debug label is effectively removed from the object.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **identifier** is not one of the accepted object types.
    * 
    * `GL_INVALID_OPERATION` is generated if **name** is not the name of an existing object of the type specified by **identifier**.
    * 
    * `GL_INVALID_VALUE` is generated if the number of characters in **label**, excluding the null terminator when **length** is negative, is greater than the value of `GL_MAX_LABEL_LENGTH`.
    * 
    * @param identifier The namespace from which the name of the object is allocated.
    * @param name The name of the object to label.
    * @param length The length of the label to be used for the object.
    * @param label The address of a string containing the label to assign to the object.

    * @see **`glPushDebugGroup`**, **`glPopDebugGroup`**, **`glObjectPtrLabel`**.

    **/
    static function objectLabel(identifier:Int, name:Int, length:Int, label:String):Void return ExtensionsNative.objectLabel(identifier, name, length, label);
    static function objectLabelKHR(identifier:Int, name:Int, length:Int, label:String):Void return ExtensionsNative.objectLabelKHR(identifier, name, length, label);
    /**
    * - #### Purpose:
    * label a sync object identified by a pointer
    * ### Description:
    * **glObjectPtrLabel** labels the sync object identified by **ptr**.
    * 
    * **label** is the address of a string that will be used to label the object. **length** contains the number of characters in **label**. If **length** is negative, it is implied that **label** contains a null-terminated string. If **label** is NULL, any debug label is effectively removed from the object.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **ptr** is not a valid sync object.
    * 
    * `GL_INVALID_VALUE` is generated if the number of characters in **label**, excluding the null terminator when **length** is negative, is greater than the value of `GL_MAX_LABEL_LENGTH`.
    * 
    * @param ptr A pointer identifying a sync object.
    * @param length The length of the label to be used for the object.
    * @param label The address of a string containing the label to assign to the object.

    * @see **`glPushDebugGroup`**, **`glPopDebugGroup`**, **`glObjectLabel`**.

    **/
    static function objectPtrLabel(ptr:DataPointer, length:Int, label:String):Void return ExtensionsNative.objectPtrLabel(ptr, length, label);
    static function objectPtrLabelKHR(ptr:DataPointer, length:Int, label:String):Void return ExtensionsNative.objectPtrLabelKHR(ptr, length, label);
    static function objectPurgeableAPPLE(objectType:Int, name:Int, option:Int):Int return ExtensionsNative.objectPurgeableAPPLE(objectType, name, option);
    static function objectUnpurgeableAPPLE(objectType:Int, name:Int, option:Int):Int return ExtensionsNative.objectUnpurgeableAPPLE(objectType, name, option);
    static function ortho(left:DataPointer, right:DataPointer, bottom:DataPointer, top:DataPointer, zNear:DataPointer, zFar:DataPointer):Void return ExtensionsNative.ortho(left, right, bottom, top, zNear, zFar);
    static function orthof(l:Float, r:Float, b:Float, t:Float, n:Float, f:Float):Void return ExtensionsNative.orthof(l, r, b, t, n, f);
    static function orthofOES(l:Float, r:Float, b:Float, t:Float, n:Float, f:Float):Void return ExtensionsNative.orthofOES(l, r, b, t, n, f);
    static function orthox(l:Int, r:Int, b:Int, t:Int, n:Int, f:Int):Void return ExtensionsNative.orthox(l, r, b, t, n, f);
    static function orthoxOES(l:Int, r:Int, b:Int, t:Int, n:Int, f:Int):Void return ExtensionsNative.orthoxOES(l, r, b, t, n, f);
    static function pNTrianglesfATI(pname:Int, param:Float):Void return ExtensionsNative.pNTrianglesfATI(pname, param);
    static function pNTrianglesiATI(pname:Int, param:Int):Void return ExtensionsNative.pNTrianglesiATI(pname, param);
    static function passTexCoordATI(dst:Int, coord:Int, swizzle:Int):Void return ExtensionsNative.passTexCoordATI(dst, coord, swizzle);
    static function passThrough(token:Float):Void return ExtensionsNative.passThrough(token);
    static function passThroughxOES(token:Int):Void return ExtensionsNative.passThroughxOES(token);
    static function patchParameterfv(pname:Int, values:DataPointer):Void return ExtensionsNative.patchParameterfv(pname, values);
    static function patchParameteri(pname:Int, value:Int):Void return ExtensionsNative.patchParameteri(pname, value);
    static function patchParameteriEXT(pname:Int, value:Int):Void return ExtensionsNative.patchParameteriEXT(pname, value);
    static function patchParameteriOES(pname:Int, value:Int):Void return ExtensionsNative.patchParameteriOES(pname, value);
    static function pathColorGenNV(color:Int, genMode:Int, colorFormat:Int, coeffs:DataPointer):Void return ExtensionsNative.pathColorGenNV(color, genMode, colorFormat, coeffs);
    static function pathCommandsNV(path:Int, numCommands:Int, commands:DataPointer, numCoords:Int, coordType:Int, coords:DataPointer):Void return ExtensionsNative.pathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
    static function pathCoordsNV(path:Int, numCoords:Int, coordType:Int, coords:DataPointer):Void return ExtensionsNative.pathCoordsNV(path, numCoords, coordType, coords);
    static function pathCoverDepthFuncNV(func:Int):Void return ExtensionsNative.pathCoverDepthFuncNV(func);
    static function pathDashArrayNV(path:Int, dashCount:Int, dashArray:DataPointer):Void return ExtensionsNative.pathDashArrayNV(path, dashCount, dashArray);
    static function pathFogGenNV(genMode:Int):Void return ExtensionsNative.pathFogGenNV(genMode);
    static function pathGlyphIndexArrayNV(firstPathName:Int, fontTarget:Int, fontName:DataPointer, fontStyle:Int, firstGlyphIndex:Int, numGlyphs:Int, pathParameterTemplate:Int, emScale:Float):Int return ExtensionsNative.pathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    static function pathGlyphIndexRangeNV(fontTarget:Int, fontName:DataPointer, fontStyle:Int, pathParameterTemplate:Int, emScale:Float, baseAndCount:DataPointer):Int return ExtensionsNative.pathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
    static function pathGlyphRangeNV(firstPathName:Int, fontTarget:Int, fontName:DataPointer, fontStyle:Int, firstGlyph:Int, numGlyphs:Int, handleMissin_gGlyphs:Int, pathParameterTemplate:Int, emScale:Float):Void return ExtensionsNative.pathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissin_gGlyphs, pathParameterTemplate, emScale);
    static function pathGlyphsNV(firstPathName:Int, fontTarget:Int, fontName:DataPointer, fontStyle:Int, numGlyphs:Int, type:Int, charcodes:DataPointer, handleMissin_gGlyphs:Int, pathParameterTemplate:Int, emScale:Float):Void return ExtensionsNative.pathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissin_gGlyphs, pathParameterTemplate, emScale);
    static function pathMemoryGlyphIndexArrayNV(firstPathName:Int, fontTarget:Int, fontSize:Int, fontData:DataPointer, faceIndex:Int, firstGlyphIndex:Int, numGlyphs:Int, pathParameterTemplate:Int, emScale:Float):Int return ExtensionsNative.pathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    static function pathParameterfNV(path:Int, pname:Int, value:Float):Void return ExtensionsNative.pathParameterfNV(path, pname, value);
    static function pathParameterfvNV(path:Int, pname:Int, value:DataPointer):Void return ExtensionsNative.pathParameterfvNV(path, pname, value);
    static function pathParameteriNV(path:Int, pname:Int, value:Int):Void return ExtensionsNative.pathParameteriNV(path, pname, value);
    static function pathParameterivNV(path:Int, pname:Int, value:DataPointer):Void return ExtensionsNative.pathParameterivNV(path, pname, value);
    static function pathStencilDepthOffsetNV(factor:Float, units:Float):Void return ExtensionsNative.pathStencilDepthOffsetNV(factor, units);
    static function pathStencilFuncNV(func:Int, ref:Int, mask:Int):Void return ExtensionsNative.pathStencilFuncNV(func, ref, mask);
    static function pathStringNV(path:Int, format:Int, length:Int, pathStrin_g:DataPointer):Void return ExtensionsNative.pathStringNV(path, format, length, pathStrin_g);
    static function pathSubCommandsNV(path:Int, commandStart:Int, commandsToDelete:Int, numCommands:Int, commands:DataPointer, numCoords:Int, coordType:Int, coords:DataPointer):Void return ExtensionsNative.pathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    static function pathSubCoordsNV(path:Int, coordStart:Int, numCoords:Int, coordType:Int, coords:DataPointer):Void return ExtensionsNative.pathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
    static function pathTexGenNV(texCoordSet:Int, genMode:Int, components:Int, coeffs:DataPointer):Void return ExtensionsNative.pathTexGenNV(texCoordSet, genMode, components, coeffs);
    /**
    * - #### Purpose:
    * pause transform feedback operations
    * ### Description:
    * **glPauseTransformFeedback** pauses transform feedback operations on the currently active transform feedback object. When transform feedback operations are paused, transform feedback is still considered active and changing most transform feedback state related to the object results in an error. However, a new transform feedback object may be bound while transform feedback is paused.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if the currently bound transform feedback object is not active or is paused.
    * 
    * * @see **`glGenTransformFeedbacks`**, **`glBindTransformFeedback`**, **`glBeginTransformFeedback`**, **`glResumeTransformFeedback`**, **glEndTransformFeedback**, **`glDeleteTransformFeedbacks`**

    **/
    static function pauseTransformFeedback():Void return ExtensionsNative.pauseTransformFeedback();
    static function pauseTransformFeedbackNV():Void return ExtensionsNative.pauseTransformFeedbackNV();
    static function pixelDataRangeNV(target:Int, length:Int, poin_ter:DataPointer):Void return ExtensionsNative.pixelDataRangeNV(target, length, poin_ter);
    static function pixelMapfv(map:Int, mapsize:Int, values:DataPointer):Void return ExtensionsNative.pixelMapfv(map, mapsize, values);
    static function pixelMapuiv(map:Int, mapsize:Int, values:DataPointer):Void return ExtensionsNative.pixelMapuiv(map, mapsize, values);
    static function pixelMapusv(map:Int, mapsize:Int, values:DataPointer):Void return ExtensionsNative.pixelMapusv(map, mapsize, values);
    static function pixelMapx(map:Int, size:Int, values:DataPointer):Void return ExtensionsNative.pixelMapx(map, size, values);
    static function pixelStoref(pname:Int, param:Float):Void return ExtensionsNative.pixelStoref(pname, param);
    static function pixelStorei(pname:Int, param:Int):Void return ExtensionsNative.pixelStorei(pname, param);
    static function pixelStorex(pname:Int, param:Int):Void return ExtensionsNative.pixelStorex(pname, param);
    static function pixelTexGenParameterfSGIS(pname:Int, param:Float):Void return ExtensionsNative.pixelTexGenParameterfSGIS(pname, param);
    static function pixelTexGenParameterfvSGIS(pname:Int, params:DataPointer):Void return ExtensionsNative.pixelTexGenParameterfvSGIS(pname, params);
    static function pixelTexGenParameteriSGIS(pname:Int, param:Int):Void return ExtensionsNative.pixelTexGenParameteriSGIS(pname, param);
    static function pixelTexGenParameterivSGIS(pname:Int, params:DataPointer):Void return ExtensionsNative.pixelTexGenParameterivSGIS(pname, params);
    static function pixelTexGenSGIX(mode:Int):Void return ExtensionsNative.pixelTexGenSGIX(mode);
    static function pixelTransferf(pname:Int, param:Float):Void return ExtensionsNative.pixelTransferf(pname, param);
    static function pixelTransferi(pname:Int, param:Int):Void return ExtensionsNative.pixelTransferi(pname, param);
    static function pixelTransferxOES(pname:Int, param:Int):Void return ExtensionsNative.pixelTransferxOES(pname, param);
    static function pixelTransformParameterfEXT(target:Int, pname:Int, param:Float):Void return ExtensionsNative.pixelTransformParameterfEXT(target, pname, param);
    static function pixelTransformParameterfvEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.pixelTransformParameterfvEXT(target, pname, params);
    static function pixelTransformParameteriEXT(target:Int, pname:Int, param:Int):Void return ExtensionsNative.pixelTransformParameteriEXT(target, pname, param);
    static function pixelTransformParameterivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.pixelTransformParameterivEXT(target, pname, params);
    static function pixelZoom(xfactor:Float, yfactor:Float):Void return ExtensionsNative.pixelZoom(xfactor, yfactor);
    static function pixelZoomxOES(xfactor:Int, yfactor:Int):Void return ExtensionsNative.pixelZoomxOES(xfactor, yfactor);
    static function pointAlongPathNV(path:Int, startSegment:Int, numSegments:Int, distance:Float, x:DataPointer, y:DataPointer, tangentX:DataPointer, tangentY:DataPointer):Bool return ExtensionsNative.pointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    static function pointParameterf(pname:Int, param:Float):Void return ExtensionsNative.pointParameterf(pname, param);
    static function pointParameterfARB(pname:Int, param:Float):Void return ExtensionsNative.pointParameterfARB(pname, param);
    static function pointParameterfEXT(pname:Int, param:Float):Void return ExtensionsNative.pointParameterfEXT(pname, param);
    static function pointParameterfSGIS(pname:Int, param:Float):Void return ExtensionsNative.pointParameterfSGIS(pname, param);
    static function pointParameterfv(pname:Int, params:DataPointer):Void return ExtensionsNative.pointParameterfv(pname, params);
    static function pointParameterfvARB(pname:Int, params:DataPointer):Void return ExtensionsNative.pointParameterfvARB(pname, params);
    static function pointParameterfvEXT(pname:Int, params:DataPointer):Void return ExtensionsNative.pointParameterfvEXT(pname, params);
    static function pointParameterfvSGIS(pname:Int, params:DataPointer):Void return ExtensionsNative.pointParameterfvSGIS(pname, params);
    static function pointParameteri(pname:Int, param:Int):Void return ExtensionsNative.pointParameteri(pname, param);
    static function pointParameteriNV(pname:Int, param:Int):Void return ExtensionsNative.pointParameteriNV(pname, param);
    static function pointParameteriv(pname:Int, params:DataPointer):Void return ExtensionsNative.pointParameteriv(pname, params);
    static function pointParameterivNV(pname:Int, params:DataPointer):Void return ExtensionsNative.pointParameterivNV(pname, params);
    static function pointParameterx(pname:Int, param:Int):Void return ExtensionsNative.pointParameterx(pname, param);
    static function pointParameterxOES(pname:Int, param:Int):Void return ExtensionsNative.pointParameterxOES(pname, param);
    static function pointParameterxv(pname:Int, params:DataPointer):Void return ExtensionsNative.pointParameterxv(pname, params);
    static function pointParameterxvOES(pname:Int, params:DataPointer):Void return ExtensionsNative.pointParameterxvOES(pname, params);
    /**
    * - #### Purpose:
    * specify the diameter of rasterized points
    * ### Description:
    * **glPointSize** specifies the rasterized diameter of points. If point size mode is disabled (see **`glEnable`** with parameter `GL_PROGRAM_POINT_SIZE`), this value will be used to rasterize points. Otherwise, the value written to the shading language built-in variable gl_PointSize will be used.
    * 
    * 
    * ### Notes:
    * The point size specified by **glPointSize** is always returned when `GL_POINT_SIZE` is queried. Clamping and rounding for points have no effect on the specified value.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **size** is less than or equal to 0.
    * 
    * @param size Specifies the diameter of rasterized points. The initial value is 1.

    * @see **`glEnable`**, **`glPointParameter`**

    **/
    static function pointSize(size:Float):Void return ExtensionsNative.pointSize(size);
    static function pointSizePointerOES(type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.pointSizePointerOES(type, stride, poin_ter);
    static function pointSizex(size:Int):Void return ExtensionsNative.pointSizex(size);
    static function pointSizexOES(size:Int):Void return ExtensionsNative.pointSizexOES(size);
    static function pollAsyncSGIX(markerp:DataPointer):Int return ExtensionsNative.pollAsyncSGIX(markerp);
    static function pollInstrumentsSGIX(marker_p:DataPointer):Int return ExtensionsNative.pollInstrumentsSGIX(marker_p);
    /**
    * - #### Purpose:
    * select a polygon rasterization mode
    * ### Description:
    * **glPolygonMode** controls the interpretation of polygons for rasterization. **face** describes which polygons **mode** applies to: both front and back-facing polygons (`GL_FRONT_AND_BACK`). The polygon mode affects only the final rasterization of polygons. In particular, a polygon's vertices are lit and the polygon is clipped and possibly culled before these modes are applied.
    * 
    * Three modes are defined and can be specified in **mode**:
    * 
    * *``GL_POINT``* Polygon vertices that are marked as the start of a boundary edge are drawn as points. Point attributes such as `GL_POINT_SIZE` and `GL_POINT_SMOOTH` control the rasterization of the points. Polygon rasterization attributes other than `GL_POLYGON_MODE` have no effect.
    * 
    * *``GL_LINE``* Boundary edges of the polygon are drawn as line segments. Line attributes such as `GL_LINE_WIDTH` and `GL_LINE_SMOOTH` control the rasterization of the lines. Polygon rasterization attributes other than `GL_POLYGON_MODE` have no effect.
    * 
    * *``GL_FILL``* The interior of the polygon is filled. Polygon attributes such as `GL_POLYGON_SMOOTH` control the rasterization of the polygon.
    * 
    * 
    * ### Notes:
    * Vertices are marked as boundary or nonboundary with an edge flag. Edge flags are generated internally by the GL when it decomposes triangle stips and fans.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if either **face** or **mode** is not an accepted value.
    * 
    * @param face Specifies the polygons that **mode** applies to. Must be `GL_FRONT_AND_BACK` for front- and back-facing polygons.
    * @param mode Specifies how polygons will be rasterized. Accepted values are `GL_POINT`, `GL_LINE`, and `GL_FILL`. The initial value is `GL_FILL` for both front- and back-facing polygons.

    * @see **`glLineWidth`**, **`glPointSize`**

    **/
    static function polygonMode(face:Int, mode:Int):Void return ExtensionsNative.polygonMode(face, mode);
    static function polygonModeNV(face:Int, mode:Int):Void return ExtensionsNative.polygonModeNV(face, mode);
    /**
    * - #### Purpose:
    * set the scale and units used to calculate depth values
    * ### Description:
    * When `GL_POLYGON_OFFSET_FILL`, `GL_POLYGON_OFFSET_LINE`, or `GL_POLYGON_OFFSET_POINT` is enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The value of the offset is factor &amp;times; DZ + r &amp;times; units, where DZ is a measurement of the change in depth relative to the screen area of the polygon, and r is the smallest value that is guaranteed to produce a resolvable offset for a given implementation. The offset is added before the depth test is performed and before the value is written into the depth buffer.
    * 
    * **glPolygonOffset** is useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * @param factor Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
    * @param units Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.

    * @see **`glDepthFunc`**, **`glEnable`**, **`glGet`**, **`glIsEnabled`**

    **/
    static function polygonOffset(factor:Float, units:Float):Void return ExtensionsNative.polygonOffset(factor, units);
    static function polygonOffsetClamp(factor:Float, units:Float, clamp:Float):Void return ExtensionsNative.polygonOffsetClamp(factor, units, clamp);
    static function polygonOffsetClampEXT(factor:Float, units:Float, clamp:Float):Void return ExtensionsNative.polygonOffsetClampEXT(factor, units, clamp);
    static function polygonOffsetEXT(factor:Float, bias:Float):Void return ExtensionsNative.polygonOffsetEXT(factor, bias);
    static function polygonOffsetx(factor:Int, units:Int):Void return ExtensionsNative.polygonOffsetx(factor, units);
    static function polygonOffsetxOES(factor:Int, units:Int):Void return ExtensionsNative.polygonOffsetxOES(factor, units);
    static function polygonStipple(mask:DataPointer):Void return ExtensionsNative.polygonStipple(mask);
    static function popAttrib():Void return ExtensionsNative.popAttrib();
    static function popClientAttrib():Void return ExtensionsNative.popClientAttrib();
    /**
    * - #### Purpose:
    * pop the active debug group
    * ### Description:
    * **glPopDebugGroup** pops the active debug group. After popping a debug group, the GL will also generate a debug output message describing its cause based on the **message** string, the source **source**, and an ID **id** submitted to the corresponding **`glPushDebugGroup`** command. `GL_DEBUG_TYPE_PUSH_GROUP` and `GL_DEBUG_TYPE_POP_GROUP` share a single namespace for message **id**. **severity** has the value `GL_DEBUG_SEVERITY_NOTIFICATION`. The **type** has the value `GL_DEBUG_TYPE_POP_GROUP`. Popping a debug group restores the debug output volume control of the parent debug group.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_STACK_UNDERFLOW` is generated if an attempt is made to pop the default debug group from the stack.
    * 
    * * @see **`glPushDebugGroup`**, **`glObjectLabel`**, **`glObjectPtrLabel`**.

    **/
    static function popDebugGroup():Void return ExtensionsNative.popDebugGroup();
    static function popDebugGroupKHR():Void return ExtensionsNative.popDebugGroupKHR();
    static function popGroupMarkerEXT():Void return ExtensionsNative.popGroupMarkerEXT();
    static function popMatrix():Void return ExtensionsNative.popMatrix();
    static function popName():Void return ExtensionsNative.popName();
    static function presentFrameDualFillNV(video_slot:Int, min_PresentTime:Int, begin_PresentTimeId:Int, presentDurationId:Int, type:Int, target0:Int, fill0:Int, target1:Int, fill1:Int, target2:Int, fill2:Int, target3:Int, fill3:Int):Void return ExtensionsNative.presentFrameDualFillNV(video_slot, min_PresentTime, begin_PresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
    static function presentFrameKeyedNV(video_slot:Int, min_PresentTime:Int, begin_PresentTimeId:Int, presentDurationId:Int, type:Int, target0:Int, fill0:Int, key0:Int, target1:Int, fill1:Int, key1:Int):Void return ExtensionsNative.presentFrameKeyedNV(video_slot, min_PresentTime, begin_PresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
    static function primitiveBoundingBox(min_X:Float, min_Y:Float, min_Z:Float, min_W:Float, maxX:Float, maxY:Float, maxZ:Float, maxW:Float):Void return ExtensionsNative.primitiveBoundingBox(min_X, min_Y, min_Z, min_W, maxX, maxY, maxZ, maxW);
    static function primitiveBoundingBoxARB(min_X:Float, min_Y:Float, min_Z:Float, min_W:Float, maxX:Float, maxY:Float, maxZ:Float, maxW:Float):Void return ExtensionsNative.primitiveBoundingBoxARB(min_X, min_Y, min_Z, min_W, maxX, maxY, maxZ, maxW);
    static function primitiveBoundingBoxEXT(min_X:Float, min_Y:Float, min_Z:Float, min_W:Float, maxX:Float, maxY:Float, maxZ:Float, maxW:Float):Void return ExtensionsNative.primitiveBoundingBoxEXT(min_X, min_Y, min_Z, min_W, maxX, maxY, maxZ, maxW);
    static function primitiveBoundingBoxOES(min_X:Float, min_Y:Float, min_Z:Float, min_W:Float, maxX:Float, maxY:Float, maxZ:Float, maxW:Float):Void return ExtensionsNative.primitiveBoundingBoxOES(min_X, min_Y, min_Z, min_W, maxX, maxY, maxZ, maxW);
    /**
    * - #### Purpose:
    * specify the primitive restart index
    * ### Description:
    * **glPrimitiveRestartIndex** specifies a vertex array element that is treated specially when primitive restarting is enabled. This is known as the primitive restart index.
    * 
    * When one of the **Draw*** commands transfers a set of generic attribute array elements to the GL, if the index within the vertex arrays corresponding to that set is equal to the primitive restart index, then the GL does not process those elements as a vertex. Instead, it is as if the drawing command ended with the immediately preceding transfer, and another drawing command is immediately started with the same parameters, but only transferring the immediately following element through the end of the originally specified elements.
    * 
    * When either **`glDrawElementsBaseVertex`**, **`glDrawElementsInstancedBaseVertex`** or **`glMultiDrawElementsBaseVertex`** is used, the primitive restart comparison occurs before the basevertex offset is added to the array index.
    * 
    * 
    * ### Notes:
    * **glPrimitiveRestartIndex** is available only if the GL version is 3.1 or greater.
    * 
    * 
    * ### Errors:
    * @param index Specifies the value to be interpreted as the primitive restart index.

    * @see **`glDrawArrays`**, **`glDrawElements`**, **`glDrawElementsBaseVertex`**, **`glDrawElementsInstancedBaseVertex`**

    **/
    static function primitiveRestartIndex(in_dex:Int):Void return ExtensionsNative.primitiveRestartIndex(in_dex);
    static function primitiveRestartIndexNV(in_dex:Int):Void return ExtensionsNative.primitiveRestartIndexNV(in_dex);
    static function primitiveRestartNV():Void return ExtensionsNative.primitiveRestartNV();
    static function prioritizeTextures(n:Int, textures:DataPointer, priorities:DataPointer):Void return ExtensionsNative.prioritizeTextures(n, textures, priorities);
    static function prioritizeTexturesEXT(n:Int, textures:DataPointer, priorities:DataPointer):Void return ExtensionsNative.prioritizeTexturesEXT(n, textures, priorities);
    static function prioritizeTexturesxOES(n:Int, textures:DataPointer, priorities:DataPointer):Void return ExtensionsNative.prioritizeTexturesxOES(n, textures, priorities);
    /**
    * - #### Purpose:
    * load a program object with a program binary
    * ### Description:
    * **glProgramBinary** loads a program object with a program binary previously returned from **`glGetProgramBinary`**. **binaryFormat** and **binary** must be those returned by a previous call to **`glGetProgramBinary`**, and **length** must be the length returned by **`glGetProgramBinary`**, or by **`glGetProgram`** when called with **pname** set to `GL_PROGRAM_BINARY_LENGTH`. If these conditions are not met, loading the program binary will fail and **program**'s `GL_LINK_STATUS` will be set to `GL_FALSE`.
    * 
    * A program object's program binary is replaced by calls to **`glLinkProgram`** or **glProgramBinary**. When linking success or failure is concerned, **glProgramBinary** can be considered to perform an implicit linking operation. **`glLinkProgram`** and **glProgramBinary** both set the program object's `GL_LINK_STATUS` to `GL_TRUE` or `GL_FALSE`.
    * 
    * A successful call to **glProgramBinary** will reset all uniform variables to their initial values. The initial value is either the value of the variable's initializer as specified in the original shader source, or zero if no initializer was present. Additionally, all vertex shader input and fragment shader output assignments that were in effect when the program was linked before saving are restored with **glProgramBinary** is called.
    * 
    * 
    * ### Notes:
    * A program binary may fail to load if the implementation determines that there has been a change in hardware or software configuration from when the program binary was produced such as having been compiled with an incompatible or outdated version of the compiler.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **program** is not the name of an existing program object.
    * 
    * `GL_INVALID_ENUM` is generated if **binaryFormat** is not a value recognized by the implementation.
    * 
    * @param program Specifies the name of a program object into which to load a program binary.
    * @param binaryFormat Specifies the format of the binary data in binary.
    * @param binary Specifies the address an array containing the binary to be loaded into **program**.
    * @param length Specifies the number of bytes contained in **binary**.

    * @see **`glGetProgram`**, **`glGetProgramBinary`**

    **/
    static function programBinary(program:Int, bin_aryFormat:Int, bin_ary:DataPointer, length:Int):Void return ExtensionsNative.programBinary(program, bin_aryFormat, bin_ary, length);
    static function programBinaryOES(program:Int, bin_aryFormat:Int, bin_ary:DataPointer, length:Int):Void return ExtensionsNative.programBinaryOES(program, bin_aryFormat, bin_ary, length);
    static function programBufferParametersIivNV(target:Int, bin_din_gIndex:Int, wordIndex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.programBufferParametersIivNV(target, bin_din_gIndex, wordIndex, count, params);
    static function programBufferParametersIuivNV(target:Int, bin_din_gIndex:Int, wordIndex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.programBufferParametersIuivNV(target, bin_din_gIndex, wordIndex, count, params);
    static function programBufferParametersfvNV(target:Int, bin_din_gIndex:Int, wordIndex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.programBufferParametersfvNV(target, bin_din_gIndex, wordIndex, count, params);
    static function programEnvParameter4dARB(target:Int, in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.programEnvParameter4dARB(target, in_dex, x, y, z, w);
    static function programEnvParameter4dvARB(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.programEnvParameter4dvARB(target, in_dex, params);
    static function programEnvParameter4fARB(target:Int, in_dex:Int, x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.programEnvParameter4fARB(target, in_dex, x, y, z, w);
    static function programEnvParameter4fvARB(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.programEnvParameter4fvARB(target, in_dex, params);
    static function programEnvParameterI4iNV(target:Int, in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.programEnvParameterI4iNV(target, in_dex, x, y, z, w);
    static function programEnvParameterI4ivNV(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.programEnvParameterI4ivNV(target, in_dex, params);
    static function programEnvParameterI4uiNV(target:Int, in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.programEnvParameterI4uiNV(target, in_dex, x, y, z, w);
    static function programEnvParameterI4uivNV(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.programEnvParameterI4uivNV(target, in_dex, params);
    static function programEnvParameters4fvEXT(target:Int, in_dex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.programEnvParameters4fvEXT(target, in_dex, count, params);
    static function programEnvParametersI4ivNV(target:Int, in_dex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.programEnvParametersI4ivNV(target, in_dex, count, params);
    static function programEnvParametersI4uivNV(target:Int, in_dex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.programEnvParametersI4uivNV(target, in_dex, count, params);
    static function programLocalParameter4dARB(target:Int, in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.programLocalParameter4dARB(target, in_dex, x, y, z, w);
    static function programLocalParameter4dvARB(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.programLocalParameter4dvARB(target, in_dex, params);
    static function programLocalParameter4fARB(target:Int, in_dex:Int, x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.programLocalParameter4fARB(target, in_dex, x, y, z, w);
    static function programLocalParameter4fvARB(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.programLocalParameter4fvARB(target, in_dex, params);
    static function programLocalParameterI4iNV(target:Int, in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.programLocalParameterI4iNV(target, in_dex, x, y, z, w);
    static function programLocalParameterI4ivNV(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.programLocalParameterI4ivNV(target, in_dex, params);
    static function programLocalParameterI4uiNV(target:Int, in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.programLocalParameterI4uiNV(target, in_dex, x, y, z, w);
    static function programLocalParameterI4uivNV(target:Int, in_dex:Int, params:DataPointer):Void return ExtensionsNative.programLocalParameterI4uivNV(target, in_dex, params);
    static function programLocalParameters4fvEXT(target:Int, in_dex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.programLocalParameters4fvEXT(target, in_dex, count, params);
    static function programLocalParametersI4ivNV(target:Int, in_dex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.programLocalParametersI4ivNV(target, in_dex, count, params);
    static function programLocalParametersI4uivNV(target:Int, in_dex:Int, count:Int, params:DataPointer):Void return ExtensionsNative.programLocalParametersI4uivNV(target, in_dex, count, params);
    static function programNamedParameter4dNV(id:Int, len:Int, name:DataPointer, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.programNamedParameter4dNV(id, len, name, x, y, z, w);
    static function programNamedParameter4dvNV(id:Int, len:Int, name:DataPointer, v:DataPointer):Void return ExtensionsNative.programNamedParameter4dvNV(id, len, name, v);
    static function programNamedParameter4fNV(id:Int, len:Int, name:DataPointer, x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.programNamedParameter4fNV(id, len, name, x, y, z, w);
    static function programNamedParameter4fvNV(id:Int, len:Int, name:DataPointer, v:DataPointer):Void return ExtensionsNative.programNamedParameter4fvNV(id, len, name, v);
    static function programParameter4dNV(target:Int, in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.programParameter4dNV(target, in_dex, x, y, z, w);
    static function programParameter4dvNV(target:Int, in_dex:Int, v:DataPointer):Void return ExtensionsNative.programParameter4dvNV(target, in_dex, v);
    static function programParameter4fNV(target:Int, in_dex:Int, x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.programParameter4fNV(target, in_dex, x, y, z, w);
    static function programParameter4fvNV(target:Int, in_dex:Int, v:DataPointer):Void return ExtensionsNative.programParameter4fvNV(target, in_dex, v);
    static function programParameteri(program:Int, pname:Int, value:Int):Void return ExtensionsNative.programParameteri(program, pname, value);
    static function programParameteriARB(program:Int, pname:Int, value:Int):Void return ExtensionsNative.programParameteriARB(program, pname, value);
    static function programParameteriEXT(program:Int, pname:Int, value:Int):Void return ExtensionsNative.programParameteriEXT(program, pname, value);
    static function programParameters4dvNV(target:Int, in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.programParameters4dvNV(target, in_dex, count, v);
    static function programParameters4fvNV(target:Int, in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.programParameters4fvNV(target, in_dex, count, v);
    static function programPathFragmentInputGenNV(program:Int, location:Int, genMode:Int, components:Int, coeffs:DataPointer):Void return ExtensionsNative.programPathFragmentInputGenNV(program, location, genMode, components, coeffs);
    static function programStringARB(target:Int, format:Int, len:Int, strin_g:DataPointer):Void return ExtensionsNative.programStringARB(target, format, len, strin_g);
    static function programSubroutineParametersuivNV(target:Int, count:Int, params:DataPointer):Void return ExtensionsNative.programSubroutineParametersuivNV(target, count, params);
    static function programUniform1d(program:Int, location:Int, v0:DataPointer):Void return ExtensionsNative.programUniform1d(program, location, v0);
    static function programUniform1dEXT(program:Int, location:Int, x:DataPointer):Void return ExtensionsNative.programUniform1dEXT(program, location, x);
    static function programUniform1dv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1dv(program, location, count, value);
    static function programUniform1dvEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1dvEXT(program, location, count, value);
    static function programUniform1f(program:Int, location:Int, v0:Float):Void return ExtensionsNative.programUniform1f(program, location, v0);
    static function programUniform1fEXT(program:Int, location:Int, v0:Float):Void return ExtensionsNative.programUniform1fEXT(program, location, v0);
    static function programUniform1fv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1fv(program, location, count, value);
    static function programUniform1fvEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1fvEXT(program, location, count, value);
    static function programUniform1i(program:Int, location:Int, v0:Int):Void return ExtensionsNative.programUniform1i(program, location, v0);
    static function programUniform1i64ARB(program:Int, location:Int, x:Int):Void return ExtensionsNative.programUniform1i64ARB(program, location, x);
    static function programUniform1i64NV(program:Int, location:Int, x:Int):Void return ExtensionsNative.programUniform1i64NV(program, location, x);
    static function programUniform1i64vARB(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1i64vARB(program, location, count, value);
    static function programUniform1i64vNV(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1i64vNV(program, location, count, value);
    static function programUniform1iEXT(program:Int, location:Int, v0:Int):Void return ExtensionsNative.programUniform1iEXT(program, location, v0);
    static function programUniform1iv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1iv(program, location, count, value);
    static function programUniform1ivEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1ivEXT(program, location, count, value);
    static function programUniform1ui(program:Int, location:Int, v0:Int):Void return ExtensionsNative.programUniform1ui(program, location, v0);
    static function programUniform1ui64ARB(program:Int, location:Int, x:Int):Void return ExtensionsNative.programUniform1ui64ARB(program, location, x);
    static function programUniform1ui64NV(program:Int, location:Int, x:Int):Void return ExtensionsNative.programUniform1ui64NV(program, location, x);
    static function programUniform1ui64vARB(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1ui64vARB(program, location, count, value);
    static function programUniform1ui64vNV(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1ui64vNV(program, location, count, value);
    static function programUniform1uiEXT(program:Int, location:Int, v0:Int):Void return ExtensionsNative.programUniform1uiEXT(program, location, v0);
    static function programUniform1uiv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1uiv(program, location, count, value);
    static function programUniform1uivEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform1uivEXT(program, location, count, value);
    static function programUniform2d(program:Int, location:Int, v0:DataPointer, v1:DataPointer):Void return ExtensionsNative.programUniform2d(program, location, v0, v1);
    static function programUniform2dEXT(program:Int, location:Int, x:DataPointer, y:DataPointer):Void return ExtensionsNative.programUniform2dEXT(program, location, x, y);
    static function programUniform2dv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2dv(program, location, count, value);
    static function programUniform2dvEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2dvEXT(program, location, count, value);
    static function programUniform2f(program:Int, location:Int, v0:Float, v1:Float):Void return ExtensionsNative.programUniform2f(program, location, v0, v1);
    static function programUniform2fEXT(program:Int, location:Int, v0:Float, v1:Float):Void return ExtensionsNative.programUniform2fEXT(program, location, v0, v1);
    static function programUniform2fv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2fv(program, location, count, value);
    static function programUniform2fvEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2fvEXT(program, location, count, value);
    static function programUniform2i(program:Int, location:Int, v0:Int, v1:Int):Void return ExtensionsNative.programUniform2i(program, location, v0, v1);
    static function programUniform2i64ARB(program:Int, location:Int, x:Int, y:Int):Void return ExtensionsNative.programUniform2i64ARB(program, location, x, y);
    static function programUniform2i64NV(program:Int, location:Int, x:Int, y:Int):Void return ExtensionsNative.programUniform2i64NV(program, location, x, y);
    static function programUniform2i64vARB(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2i64vARB(program, location, count, value);
    static function programUniform2i64vNV(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2i64vNV(program, location, count, value);
    static function programUniform2iEXT(program:Int, location:Int, v0:Int, v1:Int):Void return ExtensionsNative.programUniform2iEXT(program, location, v0, v1);
    static function programUniform2iv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2iv(program, location, count, value);
    static function programUniform2ivEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2ivEXT(program, location, count, value);
    static function programUniform2ui(program:Int, location:Int, v0:Int, v1:Int):Void return ExtensionsNative.programUniform2ui(program, location, v0, v1);
    static function programUniform2ui64ARB(program:Int, location:Int, x:Int, y:Int):Void return ExtensionsNative.programUniform2ui64ARB(program, location, x, y);
    static function programUniform2ui64NV(program:Int, location:Int, x:Int, y:Int):Void return ExtensionsNative.programUniform2ui64NV(program, location, x, y);
    static function programUniform2ui64vARB(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2ui64vARB(program, location, count, value);
    static function programUniform2ui64vNV(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2ui64vNV(program, location, count, value);
    static function programUniform2uiEXT(program:Int, location:Int, v0:Int, v1:Int):Void return ExtensionsNative.programUniform2uiEXT(program, location, v0, v1);
    static function programUniform2uiv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2uiv(program, location, count, value);
    static function programUniform2uivEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform2uivEXT(program, location, count, value);
    static function programUniform3d(program:Int, location:Int, v0:DataPointer, v1:DataPointer, v2:DataPointer):Void return ExtensionsNative.programUniform3d(program, location, v0, v1, v2);
    static function programUniform3dEXT(program:Int, location:Int, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.programUniform3dEXT(program, location, x, y, z);
    static function programUniform3dv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3dv(program, location, count, value);
    static function programUniform3dvEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3dvEXT(program, location, count, value);
    static function programUniform3f(program:Int, location:Int, v0:Float, v1:Float, v2:Float):Void return ExtensionsNative.programUniform3f(program, location, v0, v1, v2);
    static function programUniform3fEXT(program:Int, location:Int, v0:Float, v1:Float, v2:Float):Void return ExtensionsNative.programUniform3fEXT(program, location, v0, v1, v2);
    static function programUniform3fv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3fv(program, location, count, value);
    static function programUniform3fvEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3fvEXT(program, location, count, value);
    static function programUniform3i(program:Int, location:Int, v0:Int, v1:Int, v2:Int):Void return ExtensionsNative.programUniform3i(program, location, v0, v1, v2);
    static function programUniform3i64ARB(program:Int, location:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.programUniform3i64ARB(program, location, x, y, z);
    static function programUniform3i64NV(program:Int, location:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.programUniform3i64NV(program, location, x, y, z);
    static function programUniform3i64vARB(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3i64vARB(program, location, count, value);
    static function programUniform3i64vNV(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3i64vNV(program, location, count, value);
    static function programUniform3iEXT(program:Int, location:Int, v0:Int, v1:Int, v2:Int):Void return ExtensionsNative.programUniform3iEXT(program, location, v0, v1, v2);
    static function programUniform3iv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3iv(program, location, count, value);
    static function programUniform3ivEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3ivEXT(program, location, count, value);
    static function programUniform3ui(program:Int, location:Int, v0:Int, v1:Int, v2:Int):Void return ExtensionsNative.programUniform3ui(program, location, v0, v1, v2);
    static function programUniform3ui64ARB(program:Int, location:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.programUniform3ui64ARB(program, location, x, y, z);
    static function programUniform3ui64NV(program:Int, location:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.programUniform3ui64NV(program, location, x, y, z);
    static function programUniform3ui64vARB(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3ui64vARB(program, location, count, value);
    static function programUniform3ui64vNV(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3ui64vNV(program, location, count, value);
    static function programUniform3uiEXT(program:Int, location:Int, v0:Int, v1:Int, v2:Int):Void return ExtensionsNative.programUniform3uiEXT(program, location, v0, v1, v2);
    static function programUniform3uiv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3uiv(program, location, count, value);
    static function programUniform3uivEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform3uivEXT(program, location, count, value);
    static function programUniform4d(program:Int, location:Int, v0:DataPointer, v1:DataPointer, v2:DataPointer, v3:DataPointer):Void return ExtensionsNative.programUniform4d(program, location, v0, v1, v2, v3);
    static function programUniform4dEXT(program:Int, location:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.programUniform4dEXT(program, location, x, y, z, w);
    static function programUniform4dv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4dv(program, location, count, value);
    static function programUniform4dvEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4dvEXT(program, location, count, value);
    static function programUniform4f(program:Int, location:Int, v0:Float, v1:Float, v2:Float, v3:Float):Void return ExtensionsNative.programUniform4f(program, location, v0, v1, v2, v3);
    static function programUniform4fEXT(program:Int, location:Int, v0:Float, v1:Float, v2:Float, v3:Float):Void return ExtensionsNative.programUniform4fEXT(program, location, v0, v1, v2, v3);
    static function programUniform4fv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4fv(program, location, count, value);
    static function programUniform4fvEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4fvEXT(program, location, count, value);
    static function programUniform4i(program:Int, location:Int, v0:Int, v1:Int, v2:Int, v3:Int):Void return ExtensionsNative.programUniform4i(program, location, v0, v1, v2, v3);
    static function programUniform4i64ARB(program:Int, location:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.programUniform4i64ARB(program, location, x, y, z, w);
    static function programUniform4i64NV(program:Int, location:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.programUniform4i64NV(program, location, x, y, z, w);
    static function programUniform4i64vARB(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4i64vARB(program, location, count, value);
    static function programUniform4i64vNV(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4i64vNV(program, location, count, value);
    static function programUniform4iEXT(program:Int, location:Int, v0:Int, v1:Int, v2:Int, v3:Int):Void return ExtensionsNative.programUniform4iEXT(program, location, v0, v1, v2, v3);
    static function programUniform4iv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4iv(program, location, count, value);
    static function programUniform4ivEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4ivEXT(program, location, count, value);
    static function programUniform4ui(program:Int, location:Int, v0:Int, v1:Int, v2:Int, v3:Int):Void return ExtensionsNative.programUniform4ui(program, location, v0, v1, v2, v3);
    static function programUniform4ui64ARB(program:Int, location:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.programUniform4ui64ARB(program, location, x, y, z, w);
    static function programUniform4ui64NV(program:Int, location:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.programUniform4ui64NV(program, location, x, y, z, w);
    static function programUniform4ui64vARB(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4ui64vARB(program, location, count, value);
    static function programUniform4ui64vNV(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4ui64vNV(program, location, count, value);
    static function programUniform4uiEXT(program:Int, location:Int, v0:Int, v1:Int, v2:Int, v3:Int):Void return ExtensionsNative.programUniform4uiEXT(program, location, v0, v1, v2, v3);
    static function programUniform4uiv(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4uiv(program, location, count, value);
    static function programUniform4uivEXT(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniform4uivEXT(program, location, count, value);
    static function programUniformHandleui64ARB(program:Int, location:Int, value:Int):Void return ExtensionsNative.programUniformHandleui64ARB(program, location, value);
    static function programUniformHandleui64IMG(program:Int, location:Int, value:Int):Void return ExtensionsNative.programUniformHandleui64IMG(program, location, value);
    static function programUniformHandleui64NV(program:Int, location:Int, value:Int):Void return ExtensionsNative.programUniformHandleui64NV(program, location, value);
    static function programUniformHandleui64vARB(program:Int, location:Int, count:Int, values:DataPointer):Void return ExtensionsNative.programUniformHandleui64vARB(program, location, count, values);
    static function programUniformHandleui64vIMG(program:Int, location:Int, count:Int, values:DataPointer):Void return ExtensionsNative.programUniformHandleui64vIMG(program, location, count, values);
    static function programUniformHandleui64vNV(program:Int, location:Int, count:Int, values:DataPointer):Void return ExtensionsNative.programUniformHandleui64vNV(program, location, count, values);
    static function programUniformMatrix2dv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2dv(program, location, count, transpose, value);
    static function programUniformMatrix2dvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2dvEXT(program, location, count, transpose, value);
    static function programUniformMatrix2fv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2fv(program, location, count, transpose, value);
    static function programUniformMatrix2fvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2fvEXT(program, location, count, transpose, value);
    static function programUniformMatrix2x3dv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2x3dv(program, location, count, transpose, value);
    static function programUniformMatrix2x3dvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2x3dvEXT(program, location, count, transpose, value);
    static function programUniformMatrix2x3fv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2x3fv(program, location, count, transpose, value);
    static function programUniformMatrix2x3fvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2x3fvEXT(program, location, count, transpose, value);
    static function programUniformMatrix2x4dv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2x4dv(program, location, count, transpose, value);
    static function programUniformMatrix2x4dvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2x4dvEXT(program, location, count, transpose, value);
    static function programUniformMatrix2x4fv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2x4fv(program, location, count, transpose, value);
    static function programUniformMatrix2x4fvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix2x4fvEXT(program, location, count, transpose, value);
    static function programUniformMatrix3dv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3dv(program, location, count, transpose, value);
    static function programUniformMatrix3dvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3dvEXT(program, location, count, transpose, value);
    static function programUniformMatrix3fv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3fv(program, location, count, transpose, value);
    static function programUniformMatrix3fvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3fvEXT(program, location, count, transpose, value);
    static function programUniformMatrix3x2dv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3x2dv(program, location, count, transpose, value);
    static function programUniformMatrix3x2dvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3x2dvEXT(program, location, count, transpose, value);
    static function programUniformMatrix3x2fv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3x2fv(program, location, count, transpose, value);
    static function programUniformMatrix3x2fvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3x2fvEXT(program, location, count, transpose, value);
    static function programUniformMatrix3x4dv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3x4dv(program, location, count, transpose, value);
    static function programUniformMatrix3x4dvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3x4dvEXT(program, location, count, transpose, value);
    static function programUniformMatrix3x4fv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3x4fv(program, location, count, transpose, value);
    static function programUniformMatrix3x4fvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix3x4fvEXT(program, location, count, transpose, value);
    static function programUniformMatrix4dv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4dv(program, location, count, transpose, value);
    static function programUniformMatrix4dvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4dvEXT(program, location, count, transpose, value);
    static function programUniformMatrix4fv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4fv(program, location, count, transpose, value);
    static function programUniformMatrix4fvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4fvEXT(program, location, count, transpose, value);
    static function programUniformMatrix4x2dv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4x2dv(program, location, count, transpose, value);
    static function programUniformMatrix4x2dvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4x2dvEXT(program, location, count, transpose, value);
    static function programUniformMatrix4x2fv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4x2fv(program, location, count, transpose, value);
    static function programUniformMatrix4x2fvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4x2fvEXT(program, location, count, transpose, value);
    static function programUniformMatrix4x3dv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4x3dv(program, location, count, transpose, value);
    static function programUniformMatrix4x3dvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4x3dvEXT(program, location, count, transpose, value);
    static function programUniformMatrix4x3fv(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4x3fv(program, location, count, transpose, value);
    static function programUniformMatrix4x3fvEXT(program:Int, location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.programUniformMatrix4x3fvEXT(program, location, count, transpose, value);
    static function programUniformui64NV(program:Int, location:Int, value:Int):Void return ExtensionsNative.programUniformui64NV(program, location, value);
    static function programUniformui64vNV(program:Int, location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.programUniformui64vNV(program, location, count, value);
    static function programVertexLimitNV(target:Int, limit:Int):Void return ExtensionsNative.programVertexLimitNV(target, limit);
    /**
    * - #### Purpose:
    * specifiy the vertex to be used as the source of data for flat shaded varyings
    * ### Description:
    * Flatshading a vertex shader varying output means to assign all vetices of the primitive the same value for that output. The vertex from which these values is derived is known as the provoking vertex and **glProvokingVertex** specifies which vertex is to be used as the source of data for flat shaded varyings.
    * 
    * **provokeMode** must be either `GL_FIRST_VERTEX_CONVENTION` or `GL_LAST_VERTEX_CONVENTION`, and controls the selection of the vertex whose values are assigned to flatshaded varying outputs. The interpretation of these values for the supported primitive types is: Primitive Type of Polygon i First Vertex Convention Last Vertex Convention point i i independent line 2i - 1 2i line loop i i + 1, if i &lt; n 1, if i = n line strip i i + 1 independent triangle 3i - 2 3i triangle strip i i + 2 triangle fan i + 1 i + 2 line adjacency 4i - 2 4i - 1 line strip adjacency i + 1 i + 2 triangle adjacency 6i - 5 6i - 1 triangle strip adjacency 2i - 1 2i + 3
    * 
    * If a vertex or geometry shader is active, user-defined varying outputs may be flatshaded by using the flat qualifier when declaring the output.
    * 
    * 
    * ### Notes:
    * **glProvokingVertex** is available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **provokeMode** is not an accepted value.
    * 
    * @param provokeMode Specifies the vertex to be used as the source of data for flat shaded varyings.

    * @see **/
    static function provokingVertex(mode:Int):Void return ExtensionsNative.provokingVertex(mode);
    static function provokingVertexEXT(mode:Int):Void return ExtensionsNative.provokingVertexEXT(mode);
    static function pushAttrib(mask:Int):Void return ExtensionsNative.pushAttrib(mask);
    static function pushClientAttrib(mask:Int):Void return ExtensionsNative.pushClientAttrib(mask);
    static function pushClientAttribDefaultEXT(mask:Int):Void return ExtensionsNative.pushClientAttribDefaultEXT(mask);
    /**
    * - #### Purpose:
    * push a named debug group into the command stream
    * ### Description:
    * **glPushDebugGroup** pushes a debug group described by the string **message** into the command stream. The value of **id** specifies the ID of messages generated. The parameter **length** contains the number of characters in **message**. If **length** is negative, it is implied that **message** contains a null terminated string. The message has the specified **source** and **id**, the **type** `GL_DEBUG_TYPE_PUSH_GROUP`, and **severity** `GL_DEBUG_SEVERITY_NOTIFICATION`. The GL will put a new debug group on top of the debug group stack which inherits the control of the volume of debug output of the debug group previously residing on the top of the debug group stack. Because debug groups are strictly hierarchical, any additional control of the debug output volume will only apply within the active debug group and the debug groups pushed on top of the active debug group.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if the value of **source** is neither `GL_DEBUG_SOURCE_APPLICATION` nor `GL_DEBUG_SOURCE_THIRD_PARTY`.
    * 
    * `GL_INVALID_VALUE` is generated if **length** is negative and the number of characters in **message**, excluding the null-terminator, is not less than the value of `GL_MAX_DEBUG_MESSAGE_LENGTH`.
    * 
    * @param source The source of the debug message.
    * @param id The identifier of the message.
    * @param length The length of the message to be sent to the debug output stream.
    * @param message The a string containing the message to be sent to the debug output stream.

    * @see **`glPopDebugGroup`**, **`glObjectLabel`**, **`glObjectPtrLabel`**.

    **/
    static function pushDebugGroup(source:Int, id:Int, length:Int, message:String):Void return ExtensionsNative.pushDebugGroup(source, id, length, message);
    static function pushDebugGroupKHR(source:Int, id:Int, length:Int, message:String):Void return ExtensionsNative.pushDebugGroupKHR(source, id, length, message);
    static function pushGroupMarkerEXT(length:Int, marker:String):Void return ExtensionsNative.pushGroupMarkerEXT(length, marker);
    static function pushMatrix():Void return ExtensionsNative.pushMatrix();
    static function pushName(name:Int):Void return ExtensionsNative.pushName(name);
    /**
    * - #### Purpose:
    * record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
    * ### Description:
    * **glQueryCounter** causes the GL to record the current time into the query object named **id**. **target** must be `GL_TIMESTAMP`. The time is recorded after all previous commands on the GL client and server state and the framebuffer have been fully realized. When the time is recorded, the query result for that object is marked available. **glQueryCounter** timer queries can be used within a **`glBeginQuery`** / **glEndQuery** block where the target is `GL_TIME_ELAPSED` and it does not affect the result of that query object.
    * 
    * 
    * ### Notes:
    * **glQueryCounter** is available only if the GL version is 3.3 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **id** is the name of a query object that is already in use within a **`glBeginQuery`** / **glEndQuery** block.
    * 
    * `GL_INVALID_VALUE` is generated if **id** is not the name of a query object returned from a previous call to **`glGenQueries`**.
    * 
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_TIMESTAMP`.
    * 
    * @param id Specify the name of a query object into which to record the GL time.
    * @param target Specify the counter to query. **target** must be `GL_TIMESTAMP`.

    * @see **`glGenQueries`**, **`glBeginQuery`**, **glEndQuery**, **`glDeleteQueries`**, **`glGetQueryObject`**, **`glGetQueryiv`**, **`glGet`**

    **/
    static function queryCounter(id:Int, target:Int):Void return ExtensionsNative.queryCounter(id, target);
    static function queryCounterEXT(id:Int, target:Int):Void return ExtensionsNative.queryCounterEXT(id, target);
    static function queryMatrixxOES(mantissa:DataPointer, exponent:DataPointer):Int return ExtensionsNative.queryMatrixxOES(mantissa, exponent);
    static function queryObjectParameteruiAMD(target:Int, id:Int, pname:Int, param:Int):Void return ExtensionsNative.queryObjectParameteruiAMD(target, id, pname, param);
    static function queryResourceNV(queryType:Int, tagId:Int, count:Int, buffer:DataPointer):Int return ExtensionsNative.queryResourceNV(queryType, tagId, count, buffer);
    static function queryResourceTagNV(tagId:Int, tagStrin_g:String):Void return ExtensionsNative.queryResourceTagNV(tagId, tagStrin_g);
    static function rasterPos2d(x:DataPointer, y:DataPointer):Void return ExtensionsNative.rasterPos2d(x, y);
    static function rasterPos2dv(v:DataPointer):Void return ExtensionsNative.rasterPos2dv(v);
    static function rasterPos2f(x:Float, y:Float):Void return ExtensionsNative.rasterPos2f(x, y);
    static function rasterPos2fv(v:DataPointer):Void return ExtensionsNative.rasterPos2fv(v);
    static function rasterPos2i(x:Int, y:Int):Void return ExtensionsNative.rasterPos2i(x, y);
    static function rasterPos2iv(v:DataPointer):Void return ExtensionsNative.rasterPos2iv(v);
    static function rasterPos2s(x:Int, y:Int):Void return ExtensionsNative.rasterPos2s(x, y);
    static function rasterPos2sv(v:DataPointer):Void return ExtensionsNative.rasterPos2sv(v);
    static function rasterPos2xOES(x:Int, y:Int):Void return ExtensionsNative.rasterPos2xOES(x, y);
    static function rasterPos2xvOES(coords:DataPointer):Void return ExtensionsNative.rasterPos2xvOES(coords);
    static function rasterPos3d(x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.rasterPos3d(x, y, z);
    static function rasterPos3dv(v:DataPointer):Void return ExtensionsNative.rasterPos3dv(v);
    static function rasterPos3f(x:Float, y:Float, z:Float):Void return ExtensionsNative.rasterPos3f(x, y, z);
    static function rasterPos3fv(v:DataPointer):Void return ExtensionsNative.rasterPos3fv(v);
    static function rasterPos3i(x:Int, y:Int, z:Int):Void return ExtensionsNative.rasterPos3i(x, y, z);
    static function rasterPos3iv(v:DataPointer):Void return ExtensionsNative.rasterPos3iv(v);
    static function rasterPos3s(x:Int, y:Int, z:Int):Void return ExtensionsNative.rasterPos3s(x, y, z);
    static function rasterPos3sv(v:DataPointer):Void return ExtensionsNative.rasterPos3sv(v);
    static function rasterPos3xOES(x:Int, y:Int, z:Int):Void return ExtensionsNative.rasterPos3xOES(x, y, z);
    static function rasterPos3xvOES(coords:DataPointer):Void return ExtensionsNative.rasterPos3xvOES(coords);
    static function rasterPos4d(x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.rasterPos4d(x, y, z, w);
    static function rasterPos4dv(v:DataPointer):Void return ExtensionsNative.rasterPos4dv(v);
    static function rasterPos4f(x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.rasterPos4f(x, y, z, w);
    static function rasterPos4fv(v:DataPointer):Void return ExtensionsNative.rasterPos4fv(v);
    static function rasterPos4i(x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.rasterPos4i(x, y, z, w);
    static function rasterPos4iv(v:DataPointer):Void return ExtensionsNative.rasterPos4iv(v);
    static function rasterPos4s(x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.rasterPos4s(x, y, z, w);
    static function rasterPos4sv(v:DataPointer):Void return ExtensionsNative.rasterPos4sv(v);
    static function rasterPos4xOES(x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.rasterPos4xOES(x, y, z, w);
    static function rasterPos4xvOES(coords:DataPointer):Void return ExtensionsNative.rasterPos4xvOES(coords);
    static function rasterSamplesEXT(samples:Int, fixedsamplelocations:Bool):Void return ExtensionsNative.rasterSamplesEXT(samples, fixedsamplelocations);
    /**
    * - #### Purpose:
    * select a color buffer source for pixels
    * ### Description:
    * **glReadBuffer** specifies a color buffer as the source for subsequent **`glReadPixels`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, and **`glCopyTexSubImage3D`** commands. **mode** accepts one of twelve or more predefined values. In a fully configured system, `GL_FRONT`, `GL_LEFT`, and `GL_FRONT_LEFT` all name the front left buffer, `GL_FRONT_RIGHT` and `GL_RIGHT` name the front right buffer, and `GL_BACK_LEFT` and `GL_BACK` name the back left buffer. Further more, the constants `GL_COLOR_ATTACHMENT`i may be used to indicate the ith color attachment where i ranges from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one.
    * 
    * Nonstereo double-buffered configurations have only a front left and a back left buffer. Single-buffered configurations have a front left and a front right buffer if stereo, and only a front left buffer if nonstereo. It is an error to specify a nonexistent buffer to **glReadBuffer**.
    * 
    * **mode** is initially `GL_FRONT` in single-buffered configurations and `GL_BACK` in double-buffered configurations.
    * 
    * For **glReadBuffer**, the target framebuffer object is that bound to `GL_READ_FRAMEBUFFER`. For **glNamedFramebufferReadBuffer**, **framebuffer** must either be zero or the name of the target framebuffer object. If **framebuffer** is zero, then the default read framebuffer is affected.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **mode** is not one of the twelve (or more) accepted values.
    * 
    * `GL_INVALID_OPERATION` is generated if **mode** specifies a buffer that does not exist.
    * 
    * `GL_INVALID_OPERATION` is generated by **glNamedFramebufferReadBuffer** if **framebuffer** is not zero or the name of an existing framebuffer object.
    * 
    * @param framebuffer Specifies the name of the framebuffer object for **glNamedFramebufferReadBuffer** function.
    * @param mode Specifies a color buffer. Accepted values are `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and the constants `GL_COLOR_ATTACHMENT`i.

    * @see **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glDrawBuffer`**, **`glReadPixels`**

    **/
    static function readBuffer(src:Int):Void return ExtensionsNative.readBuffer(src);
    static function readBufferIndexedEXT(src:Int, in_dex:Int):Void return ExtensionsNative.readBufferIndexedEXT(src, in_dex);
    static function readBufferNV(mode:Int):Void return ExtensionsNative.readBufferNV(mode);
    static function readInstrumentsSGIX(marker:Int):Void return ExtensionsNative.readInstrumentsSGIX(marker);
    /**
    * - #### Purpose:
    * read a block of pixels from the frame buffer
    * ### Description:
    * **glReadPixels** and **glReadnPixels** return pixel data from the frame buffer, starting with the pixel whose lower left corner is at location (**x**, **y**), into client memory starting at location **data**. Several parameters control the processing of the pixel data before it is placed into client memory. These parameters are set with **`glPixelStore`**. This reference page describes the effects on **glReadPixels** and **glReadnPixels** of most, but not all of the parameters specified by these three commands.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target (see **`glBindBuffer`**) while a block of pixels is requested, **data** is treated as a byte offset into the buffer object's data store rather than a pointer to client memory.
    * 
    * **glReadPixels** and **glReadnPixels** return values from each pixel with lower left corner at x + i y + j for 0 &lt;= i &lt; width and 0 &lt;= j &lt; height. This pixel is said to be the ith pixel in the jth row. Pixels are returned in row order from the lowest to the highest row, left to right in each row.
    * 
    * **format** specifies the format for the returned pixel values; accepted values are:
    * 
    * *``GL_STENCIL_INDEX``* Stencil values are read from the stencil buffer.
    * 
    * *``GL_DEPTH_COMPONENT``* Depth values are read from the depth buffer. Each component is converted to floating point such that the minimum depth value maps to 0 and the maximum value maps to 1. Each component is clamped to the range 0 1.
    * 
    * *``GL_DEPTH_STENCIL``* Values are taken from both the depth and stencil buffers. The **type** parameter must be `GL_UNSIGNED_INT_24_8` or `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.
    * 
    * *``GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA``* Color values are taken from the color buffer.
    * 
    * Finally, the indices or components are converted to the proper format, as specified by **type**. If **format** is `GL_STENCIL_INDEX` and **type** is not `GL_FLOAT`, each index is masked with the mask value given in the following table. If **type** is `GL_FLOAT`, then each integer index is converted to single-precision floating-point format.
    * 
    * If **format** is `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, or `GL_BGRA` and **type** is not `GL_FLOAT`, each component is multiplied by the multiplier shown in the following table. If type is `GL_FLOAT`, then each component is passed as is (or converted to the client's single-precision floating-point format if it is different from the one used by the GL).
    * 
    * 
    * 
    * Return values are placed in memory as follows. If **format** is `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_RED`, `GL_GREEN`, or `GL_BLUE`, a single value is returned and the data for the ith pixel in the jth row is placed in location j &amp;it; width + i. `GL_RGB` and `GL_BGR` return three values, `GL_RGBA` and `GL_BGRA` return four values for each pixel, with all values corresponding to a single pixel occupying contiguous space in **data**. Storage parameters set by **`glPixelStore`**, such as `GL_PACK_LSB_FIRST` and `GL_PACK_SWAP_BYTES`, affect the way that data is written into memory. See **`glPixelStore`** for a description.
    * 
    * **glReadnPixels** function will only handle the call if **bufSize** is at least of the size required to store the requested data. Otherwise, it will generate a `GL_INVALID_OPERATION` error.
    * 
    * 
    * ### Notes:
    * Values for pixels that lie outside the window connected to the current GL context are undefined.
    * 
    * If an error is generated, no change is made to the contents of **data**.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **format** or **type** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if either **width** or **height** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if **format** is `GL_STENCIL_INDEX` and there is no stencil buffer.
    * 
    * `GL_INVALID_OPERATION` is generated if **format** is `GL_DEPTH_COMPONENT` and there is no depth buffer.
    * 
    * `GL_INVALID_OPERATION` is generated if **format** is `GL_DEPTH_STENCIL` and there is no depth buffer or if there is no stencil buffer.
    * 
    * `GL_INVALID_ENUM` is generated if **format** is `GL_DEPTH_STENCIL` and **type** is not `GL_UNSIGNED_INT_24_8` or `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and **format** is not `GL_RGB`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and **format** is neither `GL_RGBA` nor `GL_BGRA`.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and **data** is not evenly divisible into the number of bytes needed to store in memory a datum indicated by **type**.
    * 
    * `GL_INVALID_OPERATION` is generated if `GL_READ_FRAMEBUFFER_BINDING` is non-zero, the read framebuffer is complete, and the value of `GL_SAMPLE_BUFFERS` for the read framebuffer is greater than zero.
    * 
    * `GL_INVALID_OPERATION` is generated by **glReadnPixels** if the buffer size required to store the requested data is greater than **bufSize**.
    * 
    * @param x y Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
    * @param width height Specify the dimensions of the pixel rectangle. **width** and **height** of one correspond to a single pixel.
    * @param format Specifies the format of the pixel data. The following symbolic values are accepted: `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, and `GL_BGRA`.
    * @param type Specifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, or `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.
    * @param bufSize Specifies the size of the buffer **data** for **glReadnPixels** function.
    * @param data Returns the pixel data.

    * @see **`glPixelStore`**, **`glReadBuffer`**

    **/
    static function readPixels(x:Int, y:Int, width:Int, height:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.readPixels(x, y, width, height, format, type, pixels);
    static function readnPixels(x:Int, y:Int, width:Int, height:Int, format:Int, type:Int, bufSize:Int, data:DataPointer):Void return ExtensionsNative.readnPixels(x, y, width, height, format, type, bufSize, data);
    static function readnPixelsARB(x:Int, y:Int, width:Int, height:Int, format:Int, type:Int, bufSize:Int, data:DataPointer):Void return ExtensionsNative.readnPixelsARB(x, y, width, height, format, type, bufSize, data);
    static function readnPixelsEXT(x:Int, y:Int, width:Int, height:Int, format:Int, type:Int, bufSize:Int, data:DataPointer):Void return ExtensionsNative.readnPixelsEXT(x, y, width, height, format, type, bufSize, data);
    static function readnPixelsKHR(x:Int, y:Int, width:Int, height:Int, format:Int, type:Int, bufSize:Int, data:DataPointer):Void return ExtensionsNative.readnPixelsKHR(x, y, width, height, format, type, bufSize, data);
    static function releaseKeyedMutexWin32EXT(memory:Int, key:Int):Bool return ExtensionsNative.releaseKeyedMutexWin32EXT(memory, key);
    static function rectd(x1:DataPointer, y1:DataPointer, x2:DataPointer, y2:DataPointer):Void return ExtensionsNative.rectd(x1, y1, x2, y2);
    static function rectdv(v1:DataPointer, v2:DataPointer):Void return ExtensionsNative.rectdv(v1, v2);
    static function rectf(x1:Float, y1:Float, x2:Float, y2:Float):Void return ExtensionsNative.rectf(x1, y1, x2, y2);
    static function rectfv(v1:DataPointer, v2:DataPointer):Void return ExtensionsNative.rectfv(v1, v2);
    static function recti(x1:Int, y1:Int, x2:Int, y2:Int):Void return ExtensionsNative.recti(x1, y1, x2, y2);
    static function rectiv(v1:DataPointer, v2:DataPointer):Void return ExtensionsNative.rectiv(v1, v2);
    static function rects(x1:Int, y1:Int, x2:Int, y2:Int):Void return ExtensionsNative.rects(x1, y1, x2, y2);
    static function rectsv(v1:DataPointer, v2:DataPointer):Void return ExtensionsNative.rectsv(v1, v2);
    static function rectxOES(x1:Int, y1:Int, x2:Int, y2:Int):Void return ExtensionsNative.rectxOES(x1, y1, x2, y2);
    static function rectxvOES(v1:DataPointer, v2:DataPointer):Void return ExtensionsNative.rectxvOES(v1, v2);
    static function referencePlaneSGIX(equation:DataPointer):Void return ExtensionsNative.referencePlaneSGIX(equation);
    /**
    * - #### Purpose:
    * release resources consumed by the implementation's shader compiler
    * ### Description:
    * **glReleaseShaderCompiler** provides a hint to the implementation that it may free internal resources associated with its shader compiler. **`glCompileShader`** may subsequently be called and the implementation may at that time reallocate resources previously freed by the call to **glReleaseShaderCompiler**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * * @see **`glCompileShader`**, **`glLinkProgram`**

    **/
    static function releaseShaderCompiler():Void return ExtensionsNative.releaseShaderCompiler();
    static function renderGpuMaskNV(mask:Int):Void return ExtensionsNative.renderGpuMaskNV(mask);
    static function renderMode(mode:Int):Int return ExtensionsNative.renderMode(mode);
    /**
    * - #### Purpose:
    * establish data storage, format and dimensions of a
        renderbuffer object's image
    * ### Description:
    * **glRenderbufferStorage** is equivalent to calling **`glRenderbufferStorageMultisample`** with the **samples** set to zero, and **glNamedRenderbufferStorage** is equivalent to calling **glNamedRenderbufferStorageMultisample** with the samples set to zero.
    * 
    * For **glRenderbufferStorage**, the target of the operation, specified by **target** must be `GL_RENDERBUFFER`. For **glNamedRenderbufferStorage**, **renderbuffer** must be a name of an existing renderbuffer object. **internalformat** specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. **width** and **height** are the dimensions, in pixels, of the renderbuffer. Both **width** and **height** must be less than or equal to the value of `GL_MAX_RENDERBUFFER_SIZE`.
    * 
    * Upon success, **glRenderbufferStorage** and **glNamedRenderbufferStorage** delete any existing data store for the renderbuffer image and the contents of the data store after calling **glRenderbufferStorage** are undefined.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glRenderbufferStorage** if **target** is not `GL_RENDERBUFFER`.
    * 
    * `GL_INVALID_OPERATION` is generated by glNamedRenderbufferStorage if **renderbuffer** is not the name of an existing renderbuffer object.
    * 
    * `GL_INVALID_VALUE` is generated if either of **width** or **height** is negative, or greater than the value of `GL_MAX_RENDERBUFFER_SIZE`.
    * 
    * `GL_INVALID_ENUM` is generated if **internalformat** is not a color-renderable, depth-renderable, or stencil-renderable format.
    * 
    * `GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store of the requested size.
    * 
    * @param target Specifies a binding target of the allocation for **glRenderbufferStorage** function. Must be `GL_RENDERBUFFER`.
    * @param renderbuffer Specifies the name of the renderbuffer object for **glNamedRenderbufferStorage** function.
    * @param internalformat Specifies the internal format to use for the renderbuffer object's image.
    * @param width Specifies the width of the renderbuffer, in pixels.
    * @param height Specifies the height of the renderbuffer, in pixels.

    * @see **`glGenRenderbuffers`**, **`glBindRenderbuffer`**, **glNamedRenderbufferStorageMultisample**, **`glRenderbufferStorageMultisample`**, **`glFramebufferRenderbuffer`**, **`glDeleteRenderbuffers`**

    **/
    static function renderbufferStorage(target:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.renderbufferStorage(target, in_ternalformat, width, height);
    static function renderbufferStorageEXT(target:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.renderbufferStorageEXT(target, in_ternalformat, width, height);
    /**
    * - #### Purpose:
    * establish data storage, format, dimensions and sample count of
        a renderbuffer object's image
    * ### Description:
    * **glRenderbufferStorageMultisample** and **glNamedRenderbufferStorageMultisample** establish the data storage, format, dimensions and number of samples of a renderbuffer object's image.
    * 
    * For **glRenderbufferStorageMultisample**, the target of the operation, specified by **target** must be `GL_RENDERBUFFER`. For **glNamedRenderbufferStorageMultisample**, **renderbuffer** must be an ID of an existing renderbuffer object. **internalformat** specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. **width** and **height** are the dimensions, in pixels, of the renderbuffer. Both **width** and **height** must be less than or equal to the value of `GL_MAX_RENDERBUFFER_SIZE`. **samples** specifies the number of samples to be used for the renderbuffer object's image, and must be less than or equal to the value of `GL_MAX_SAMPLES`. If **internalformat** is a signed or unsigned integer format then **samples** must be less than or equal to the value of `GL_MAX_INTEGER_SAMPLES`.
    * 
    * Upon success, **glRenderbufferStorageMultisample** and **glNamedRenderbufferStorageMultisample** delete any existing data store for the renderbuffer image and the contents of the data store after calling either of the functions are undefined.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glRenderbufferStorageMultisample** function if **target** is not `GL_RENDERBUFFER`.
    * 
    * `GL_INVALID_OPERATION` is generated by **glNamedRenderbufferStorageMultisample** function if **renderbuffer** is not the name of an existing renderbuffer object.
    * 
    * `GL_INVALID_OPERATION` is generated if **samples** is greater than the maximum number of samples					supported for **internalformat**.
    * 
    * `GL_INVALID_ENUM` is generated if **internalformat** is not a color-renderable, depth-renderable, or stencil-renderable format.
    * 
    * `GL_INVALID_OPERATION` is generated if **internalformat** is a signed or unsigned integer format and **samples** is greater than the value of `GL_MAX_INTEGER_SAMPLES`
    * 
    * `GL_INVALID_VALUE` is generated if either of **width** or **height** is negative, or greater than the value of `GL_MAX_RENDERBUFFER_SIZE`.
    * 
    * `GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store of the requested size.
    * 
    * @param target Specifies a binding target of the allocation for **glRenderbufferStorageMultisample** function. Must be `GL_RENDERBUFFER`.
    * @param renderbuffer Specifies the name of the renderbuffer object for **glNamedRenderbufferStorageMultisample** function.
    * @param samples Specifies the number of samples to be used for the renderbuffer object's storage.
    * @param internalformat Specifies the internal format to use for the renderbuffer object's image.
    * @param width Specifies the width of the renderbuffer, in pixels.
    * @param height Specifies the height of the renderbuffer, in pixels.

    * @see **`glGenRenderbuffers`**, **`glBindRenderbuffer`**, **glNamedRenderbufferStorage**, **`glRenderbufferStorage`**, **`glFramebufferRenderbuffer`**, **`glDeleteRenderbuffers`**

    **/
    static function renderbufferStorageMultisample(target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.renderbufferStorageMultisample(target, samples, in_ternalformat, width, height);
    static function renderbufferStorageMultisampleANGLE(target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.renderbufferStorageMultisampleANGLE(target, samples, in_ternalformat, width, height);
    static function renderbufferStorageMultisampleAPPLE(target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.renderbufferStorageMultisampleAPPLE(target, samples, in_ternalformat, width, height);
    static function renderbufferStorageMultisampleAdvancedAMD(target:Int, samples:Int, storageSamples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.renderbufferStorageMultisampleAdvancedAMD(target, samples, storageSamples, in_ternalformat, width, height);
    static function renderbufferStorageMultisampleCoverageNV(target:Int, coverageSamples:Int, colorSamples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.renderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, in_ternalformat, width, height);
    static function renderbufferStorageMultisampleEXT(target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.renderbufferStorageMultisampleEXT(target, samples, in_ternalformat, width, height);
    static function renderbufferStorageMultisampleIMG(target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.renderbufferStorageMultisampleIMG(target, samples, in_ternalformat, width, height);
    static function renderbufferStorageMultisampleNV(target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.renderbufferStorageMultisampleNV(target, samples, in_ternalformat, width, height);
    static function renderbufferStorageOES(target:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.renderbufferStorageOES(target, in_ternalformat, width, height);
    static function replacementCodePointerSUN(type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.replacementCodePointerSUN(type, stride, poin_ter);
    static function replacementCodeubSUN(code:Int):Void return ExtensionsNative.replacementCodeubSUN(code);
    static function replacementCodeubvSUN(code:DataPointer):Void return ExtensionsNative.replacementCodeubvSUN(code);
    static function replacementCodeuiColor3fVertex3fSUN(rc:Int, r:Float, g:Float, b:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.replacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
    static function replacementCodeuiColor3fVertex3fvSUN(rc:DataPointer, c:DataPointer, v:DataPointer):Void return ExtensionsNative.replacementCodeuiColor3fVertex3fvSUN(rc, c, v);
    static function replacementCodeuiColor4fNormal3fVertex3fSUN(rc:Int, r:Float, g:Float, b:Float, a:Float, nx:Float, ny:Float, nz:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.replacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
    static function replacementCodeuiColor4fNormal3fVertex3fvSUN(rc:DataPointer, c:DataPointer, n:DataPointer, v:DataPointer):Void return ExtensionsNative.replacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
    static function replacementCodeuiColor4ubVertex3fSUN(rc:Int, r:Int, g:Int, b:Int, a:Int, x:Float, y:Float, z:Float):Void return ExtensionsNative.replacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
    static function replacementCodeuiColor4ubVertex3fvSUN(rc:DataPointer, c:DataPointer, v:DataPointer):Void return ExtensionsNative.replacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
    static function replacementCodeuiNormal3fVertex3fSUN(rc:Int, nx:Float, ny:Float, nz:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.replacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
    static function replacementCodeuiNormal3fVertex3fvSUN(rc:DataPointer, n:DataPointer, v:DataPointer):Void return ExtensionsNative.replacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
    static function replacementCodeuiSUN(code:Int):Void return ExtensionsNative.replacementCodeuiSUN(code);
    static function replacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc:Int, s:Float, t:Float, r:Float, g:Float, b:Float, a:Float, nx:Float, ny:Float, nz:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.replacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
    static function replacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc:DataPointer, tc:DataPointer, c:DataPointer, n:DataPointer, v:DataPointer):Void return ExtensionsNative.replacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
    static function replacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc:Int, s:Float, t:Float, nx:Float, ny:Float, nz:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.replacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
    static function replacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc:DataPointer, tc:DataPointer, n:DataPointer, v:DataPointer):Void return ExtensionsNative.replacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
    static function replacementCodeuiTexCoord2fVertex3fSUN(rc:Int, s:Float, t:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.replacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
    static function replacementCodeuiTexCoord2fVertex3fvSUN(rc:DataPointer, tc:DataPointer, v:DataPointer):Void return ExtensionsNative.replacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
    static function replacementCodeuiVertex3fSUN(rc:Int, x:Float, y:Float, z:Float):Void return ExtensionsNative.replacementCodeuiVertex3fSUN(rc, x, y, z);
    static function replacementCodeuiVertex3fvSUN(rc:DataPointer, v:DataPointer):Void return ExtensionsNative.replacementCodeuiVertex3fvSUN(rc, v);
    static function replacementCodeuivSUN(code:DataPointer):Void return ExtensionsNative.replacementCodeuivSUN(code);
    static function replacementCodeusSUN(code:Int):Void return ExtensionsNative.replacementCodeusSUN(code);
    static function replacementCodeusvSUN(code:DataPointer):Void return ExtensionsNative.replacementCodeusvSUN(code);
    static function requestResidentProgramsNV(n:Int, programs:DataPointer):Void return ExtensionsNative.requestResidentProgramsNV(n, programs);
    static function resetHistogram(target:Int):Void return ExtensionsNative.resetHistogram(target);
    static function resetHistogramEXT(target:Int):Void return ExtensionsNative.resetHistogramEXT(target);
    static function resetMemoryObjectParameterNV(memory:Int, pname:Int):Void return ExtensionsNative.resetMemoryObjectParameterNV(memory, pname);
    static function resetMinmax(target:Int):Void return ExtensionsNative.resetMinmax(target);
    static function resetMinmaxEXT(target:Int):Void return ExtensionsNative.resetMinmaxEXT(target);
    static function resizeBuffersMESA():Void return ExtensionsNative.resizeBuffersMESA();
    static function resolveDepthValuesNV():Void return ExtensionsNative.resolveDepthValuesNV();
    static function resolveMultisampleFramebufferAPPLE():Void return ExtensionsNative.resolveMultisampleFramebufferAPPLE();
    /**
    * - #### Purpose:
    * resume transform feedback operations
    * ### Description:
    * **glResumeTransformFeedback** resumes transform feedback operations on the currently active transform feedback object. When transform feedback operations are paused, transform feedback is still considered active and changing most transform feedback state related to the object results in an error. However, a new transform feedback object may be bound while transform feedback is paused.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if the currently bound transform feedback object is not active or is not paused.
    * 
    * * @see **`glGenTransformFeedbacks`**, **`glBindTransformFeedback`**, **`glBeginTransformFeedback`**, **`glPauseTransformFeedback`**, **glEndTransformFeedback**, **`glDeleteTransformFeedbacks`**

    **/
    static function resumeTransformFeedback():Void return ExtensionsNative.resumeTransformFeedback();
    static function resumeTransformFeedbackNV():Void return ExtensionsNative.resumeTransformFeedbackNV();
    static function rotated(angle:DataPointer, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.rotated(angle, x, y, z);
    static function rotatef(angle:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.rotatef(angle, x, y, z);
    static function rotatex(angle:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.rotatex(angle, x, y, z);
    static function rotatexOES(angle:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.rotatexOES(angle, x, y, z);
    /**
    * - #### Purpose:
    * specify multisample coverage parameters
    * ### Description:
    * Multisampling samples a pixel multiple times at various implementation-dependent subpixel locations to generate antialiasing effects. Multisampling transparently antialiases points, lines, polygons, and images if it is enabled.
    * 
    * **value** is used in constructing a temporary mask used in determining which samples will be used in resolving the final fragment color. This mask is bitwise-anded with the coverage mask generated from the multisampling computation. If the **invert** flag is set, the temporary mask is inverted (all bits flipped) and then the bitwise-and is computed.
    * 
    * If an implementation does not have any multisample buffers available, or multisampling is disabled, rasterization occurs with only a single sample computing a pixel's final RGB color.
    * 
    * Provided an implementation supports multisample buffers, and multisampling is enabled, then a pixel's final color is generated by combining several samples per pixel. Each sample contains color, depth, and stencil information, allowing those operations to be performed on each sample.
    * 
    * 
    * ### Notes:
    * The type of the **value** parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the **`removedTypes`** page.
    * 
    * 
    * ### Errors:
    * @param value Specify a single floating-point sample coverage value. The value is clamped to the range 0 1. The initial value is 1.0.
    * @param invert Specify a single boolean value representing if the coverage masks should be inverted. `GL_TRUE` and `GL_FALSE` are accepted. The initial value is `GL_FALSE`.

    * @see **`glEnable`**, **`removedTypes`**

    **/
    static function sampleCoverage(value:Float, in_vert:Bool):Void return ExtensionsNative.sampleCoverage(value, in_vert);
    static function sampleCoverageARB(value:Float, in_vert:Bool):Void return ExtensionsNative.sampleCoverageARB(value, in_vert);
    static function sampleCoveragex(value:Int, in_vert:Bool):Void return ExtensionsNative.sampleCoveragex(value, in_vert);
    static function sampleCoveragexOES(value:Int, in_vert:Bool):Void return ExtensionsNative.sampleCoveragexOES(value, in_vert);
    static function sampleMapATI(dst:Int, in_terp:Int, swizzle:Int):Void return ExtensionsNative.sampleMapATI(dst, in_terp, swizzle);
    static function sampleMaskEXT(value:Float, in_vert:Bool):Void return ExtensionsNative.sampleMaskEXT(value, in_vert);
    static function sampleMaskIndexedNV(in_dex:Int, mask:Int):Void return ExtensionsNative.sampleMaskIndexedNV(in_dex, mask);
    static function sampleMaskSGIS(value:Float, in_vert:Bool):Void return ExtensionsNative.sampleMaskSGIS(value, in_vert);
    /**
    * - #### Purpose:
    * set the value of a sub-word of the sample mask
    * ### Description:
    * **glSampleMaski** sets one 32-bit sub-word of the multi-word sample mask, `GL_SAMPLE_MASK_VALUE`.
    * 
    * **maskIndex** specifies which 32-bit sub-word of the sample mask to update, and **mask** specifies the new value to use for that sub-word. **maskIndex** must be less than the value of `GL_MAX_SAMPLE_MASK_WORDS`. Bit B of mask word M corresponds to sample 32 x M + B.
    * 
    * 
    * ### Notes:
    * **glSampleMaski** is available only if the GL version is 3.2 or greater, or if the ARB_texture_multisample extension is supported.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **maskIndex** is greater than or equal to the value of `GL_MAX_SAMPLE_MASK_WORDS`.
    * 
    * @param maskNumber Specifies which 32-bit sub-word of the sample mask to update.
    * @param mask Specifies the new value of the mask sub-word.

    * @see **`glGenRenderbuffers`**, **`glBindRenderbuffer`**, **`glRenderbufferStorageMultisample`**, **`glFramebufferRenderbuffer`**, **`glDeleteRenderbuffers`**

    **/
    static function sampleMaski(maskNumber:Int, mask:Int):Void return ExtensionsNative.sampleMaski(maskNumber, mask);
    static function samplePatternEXT(pattern:Int):Void return ExtensionsNative.samplePatternEXT(pattern);
    static function samplePatternSGIS(pattern:Int):Void return ExtensionsNative.samplePatternSGIS(pattern);
    static function samplerParameterIiv(sampler:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.samplerParameterIiv(sampler, pname, param);
    static function samplerParameterIivEXT(sampler:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.samplerParameterIivEXT(sampler, pname, param);
    static function samplerParameterIivOES(sampler:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.samplerParameterIivOES(sampler, pname, param);
    static function samplerParameterIuiv(sampler:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.samplerParameterIuiv(sampler, pname, param);
    static function samplerParameterIuivEXT(sampler:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.samplerParameterIuivEXT(sampler, pname, param);
    static function samplerParameterIuivOES(sampler:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.samplerParameterIuivOES(sampler, pname, param);
    static function samplerParameterf(sampler:Int, pname:Int, param:Float):Void return ExtensionsNative.samplerParameterf(sampler, pname, param);
    static function samplerParameterfv(sampler:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.samplerParameterfv(sampler, pname, param);
    static function samplerParameteri(sampler:Int, pname:Int, param:Int):Void return ExtensionsNative.samplerParameteri(sampler, pname, param);
    static function samplerParameteriv(sampler:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.samplerParameteriv(sampler, pname, param);
    static function scaled(x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.scaled(x, y, z);
    static function scalef(x:Float, y:Float, z:Float):Void return ExtensionsNative.scalef(x, y, z);
    static function scalex(x:Int, y:Int, z:Int):Void return ExtensionsNative.scalex(x, y, z);
    static function scalexOES(x:Int, y:Int, z:Int):Void return ExtensionsNative.scalexOES(x, y, z);
    /**
    * - #### Purpose:
    * define the scissor box
    * ### Description:
    * **glScissor** defines a rectangle, called the scissor box, in window coordinates. The first two arguments, **x** and **y**, specify the lower left corner of the box. **width** and **height** specify the width and height of the box.
    * 
    * To enable and disable the scissor test, call **`glEnable`** and **glDisable** with argument `GL_SCISSOR_TEST`. The test is initially disabled. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. glScissor(0,0,1,1) allows modification of only the lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow modification of any pixels in the window.
    * 
    * When the scissor test is disabled, it is as though the scissor box includes the entire window.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if either **width** or **height** is negative.
    * 
    * @param x y Specify the lower left corner of the scissor box. Initially (0, 0).
    * @param width height Specify the width and height of the scissor box. When a GL context is first attached to a window, **width** and **height** are set to the dimensions of that window.

    * @see **`glEnable`**, **`glViewport`**

    **/
    static function scissor(x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.scissor(x, y, width, height);
    static function scissorArrayv(first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.scissorArrayv(first, count, v);
    static function scissorArrayvNV(first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.scissorArrayvNV(first, count, v);
    static function scissorArrayvOES(first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.scissorArrayvOES(first, count, v);
    static function scissorExclusiveArrayvNV(first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.scissorExclusiveArrayvNV(first, count, v);
    static function scissorExclusiveNV(x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.scissorExclusiveNV(x, y, width, height);
    /**
    * - #### Purpose:
    * define the scissor box for a specific viewport
    * ### Description:
    * **glScissorIndexed** defines the scissor box for a specified viewport. **index** specifies the index of scissor box to modify. **index** must be less than the value of `GL_MAX_VIEWPORTS`. For **glScissorIndexed**, **left**, **bottom**, **width** and **height** specify the left, bottom, width and height of the scissor box, in pixels, respectively. For **glScissorIndexedv**, **v** specifies the address of an array containing integers specifying the lower left corner of the scissor box, and the width and height of the scissor box, in that order.
    * 
    * To enable and disable the scissor test, call **`glEnable`** and **glDisable** with argument `GL_SCISSOR_TEST`. The test is initially disabled for all viewports. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. glScissor(0,0,1,1) allows modification of only the lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow modification of any pixels in the window.
    * 
    * When the scissor test is disabled, it is as though the scissor box includes the entire window.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the value of `GL_MAX_VIEWPORTS`.
    * 
    * `GL_INVALID_VALUE` is generated if any width or height specified in the array **v** is negative.
    * 
    * @param index Specifies the index of the viewport whose scissor box to modify.
    * @param left bottom Specify the coordinate of the bottom left corner of the scissor box, in pixels.
    * @param width height Specify ths dimensions of the scissor box, in pixels.
    * @param v For **glScissorIndexedv**, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.

    * @see **`glEnable`**, **`glScissor`**, **`glScissorArray`**

    **/
    static function scissorIndexed(in_dex:Int, left:Int, bottom:Int, width:Int, height:Int):Void return ExtensionsNative.scissorIndexed(in_dex, left, bottom, width, height);
    static function scissorIndexedNV(in_dex:Int, left:Int, bottom:Int, width:Int, height:Int):Void return ExtensionsNative.scissorIndexedNV(in_dex, left, bottom, width, height);
    static function scissorIndexedOES(in_dex:Int, left:Int, bottom:Int, width:Int, height:Int):Void return ExtensionsNative.scissorIndexedOES(in_dex, left, bottom, width, height);
    static function scissorIndexedv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.scissorIndexedv(in_dex, v);
    static function scissorIndexedvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.scissorIndexedvNV(in_dex, v);
    static function scissorIndexedvOES(in_dex:Int, v:DataPointer):Void return ExtensionsNative.scissorIndexedvOES(in_dex, v);
    static function secondaryColor3b(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3b(red, green, blue);
    static function secondaryColor3bEXT(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3bEXT(red, green, blue);
    static function secondaryColor3bv(v:DataPointer):Void return ExtensionsNative.secondaryColor3bv(v);
    static function secondaryColor3bvEXT(v:DataPointer):Void return ExtensionsNative.secondaryColor3bvEXT(v);
    static function secondaryColor3d(red:DataPointer, green:DataPointer, blue:DataPointer):Void return ExtensionsNative.secondaryColor3d(red, green, blue);
    static function secondaryColor3dEXT(red:DataPointer, green:DataPointer, blue:DataPointer):Void return ExtensionsNative.secondaryColor3dEXT(red, green, blue);
    static function secondaryColor3dv(v:DataPointer):Void return ExtensionsNative.secondaryColor3dv(v);
    static function secondaryColor3dvEXT(v:DataPointer):Void return ExtensionsNative.secondaryColor3dvEXT(v);
    static function secondaryColor3f(red:Float, green:Float, blue:Float):Void return ExtensionsNative.secondaryColor3f(red, green, blue);
    static function secondaryColor3fEXT(red:Float, green:Float, blue:Float):Void return ExtensionsNative.secondaryColor3fEXT(red, green, blue);
    static function secondaryColor3fv(v:DataPointer):Void return ExtensionsNative.secondaryColor3fv(v);
    static function secondaryColor3fvEXT(v:DataPointer):Void return ExtensionsNative.secondaryColor3fvEXT(v);
    static function secondaryColor3hNV(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3hNV(red, green, blue);
    static function secondaryColor3hvNV(v:DataPointer):Void return ExtensionsNative.secondaryColor3hvNV(v);
    static function secondaryColor3i(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3i(red, green, blue);
    static function secondaryColor3iEXT(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3iEXT(red, green, blue);
    static function secondaryColor3iv(v:DataPointer):Void return ExtensionsNative.secondaryColor3iv(v);
    static function secondaryColor3ivEXT(v:DataPointer):Void return ExtensionsNative.secondaryColor3ivEXT(v);
    static function secondaryColor3s(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3s(red, green, blue);
    static function secondaryColor3sEXT(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3sEXT(red, green, blue);
    static function secondaryColor3sv(v:DataPointer):Void return ExtensionsNative.secondaryColor3sv(v);
    static function secondaryColor3svEXT(v:DataPointer):Void return ExtensionsNative.secondaryColor3svEXT(v);
    static function secondaryColor3ub(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3ub(red, green, blue);
    static function secondaryColor3ubEXT(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3ubEXT(red, green, blue);
    static function secondaryColor3ubv(v:DataPointer):Void return ExtensionsNative.secondaryColor3ubv(v);
    static function secondaryColor3ubvEXT(v:DataPointer):Void return ExtensionsNative.secondaryColor3ubvEXT(v);
    static function secondaryColor3ui(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3ui(red, green, blue);
    static function secondaryColor3uiEXT(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3uiEXT(red, green, blue);
    static function secondaryColor3uiv(v:DataPointer):Void return ExtensionsNative.secondaryColor3uiv(v);
    static function secondaryColor3uivEXT(v:DataPointer):Void return ExtensionsNative.secondaryColor3uivEXT(v);
    static function secondaryColor3us(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3us(red, green, blue);
    static function secondaryColor3usEXT(red:Int, green:Int, blue:Int):Void return ExtensionsNative.secondaryColor3usEXT(red, green, blue);
    static function secondaryColor3usv(v:DataPointer):Void return ExtensionsNative.secondaryColor3usv(v);
    static function secondaryColor3usvEXT(v:DataPointer):Void return ExtensionsNative.secondaryColor3usvEXT(v);
    static function secondaryColorFormatNV(size:Int, type:Int, stride:Int):Void return ExtensionsNative.secondaryColorFormatNV(size, type, stride);
    static function secondaryColorP3ui(type:Int, color:Int):Void return ExtensionsNative.secondaryColorP3ui(type, color);
    static function secondaryColorP3uiv(type:Int, color:DataPointer):Void return ExtensionsNative.secondaryColorP3uiv(type, color);
    static function secondaryColorPointer(size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.secondaryColorPointer(size, type, stride, poin_ter);
    static function secondaryColorPointerEXT(size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.secondaryColorPointerEXT(size, type, stride, poin_ter);
    static function secondaryColorPointerListIBM(size:Int, type:Int, stride:Int, poin_ter:DataPointer, ptrstride:Int):Void return ExtensionsNative.secondaryColorPointerListIBM(size, type, stride, poin_ter, ptrstride);
    static function selectBuffer(size:Int, buffer:DataPointer):Void return ExtensionsNative.selectBuffer(size, buffer);
    static function selectPerfMonitorCountersAMD(monitor:Int, enable:Bool, group:Int, numCounters:Int, counterList:DataPointer):Void return ExtensionsNative.selectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
    static function semaphoreParameterivNV(semaphore:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.semaphoreParameterivNV(semaphore, pname, params);
    static function semaphoreParameterui64vEXT(semaphore:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.semaphoreParameterui64vEXT(semaphore, pname, params);
    static function separableFilter2D(target:Int, in_ternalformat:Int, width:Int, height:Int, format:Int, type:Int, row:DataPointer, column:DataPointer):Void return ExtensionsNative.separableFilter2D(target, in_ternalformat, width, height, format, type, row, column);
    static function separableFilter2DEXT(target:Int, in_ternalformat:Int, width:Int, height:Int, format:Int, type:Int, row:DataPointer, column:DataPointer):Void return ExtensionsNative.separableFilter2DEXT(target, in_ternalformat, width, height, format, type, row, column);
    static function setFenceAPPLE(fence:Int):Void return ExtensionsNative.setFenceAPPLE(fence);
    static function setFenceNV(fence:Int, condition:Int):Void return ExtensionsNative.setFenceNV(fence, condition);
    static function setFragmentShaderConstantATI(dst:Int, value:DataPointer):Void return ExtensionsNative.setFragmentShaderConstantATI(dst, value);
    static function setInvariantEXT(id:Int, type:Int, addr:DataPointer):Void return ExtensionsNative.setInvariantEXT(id, type, addr);
    static function setLocalConstantEXT(id:Int, type:Int, addr:DataPointer):Void return ExtensionsNative.setLocalConstantEXT(id, type, addr);
    static function setMultisamplefvAMD(pname:Int, in_dex:Int, val:DataPointer):Void return ExtensionsNative.setMultisamplefvAMD(pname, in_dex, val);
    static function shadeModel(mode:Int):Void return ExtensionsNative.shadeModel(mode);
    /**
    * - #### Purpose:
    * load pre-compiled shader binaries
    * ### Description:
    * **glShaderBinary** loads pre-compiled shader binary code into the **count** shader objects whose handles are given in **shaders**. **binary** points to **length** bytes of binary shader code stored in client memory. **binaryFormat** specifies the format of the pre-compiled code.
    * 
    * The binary image contained in **binary** will be decoded according to the extension specification defining the specified **binaryFormat** token. OpenGL does not define any specific binary formats, but it does provide a mechanism to obtain token vaues for such formats provided by such extensions.
    * 
    * Depending on the types of the shader objects in **shaders**, **glShaderBinary** will individually load binary vertex or fragment shaders, or load an executable binary that contains an optimized pair of vertex and fragment shaders stored in the same binary.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if more than one of the handles in **shaders** refers to the same shader object.
    * 
    * `GL_INVALID_ENUM` is generated if **binaryFormat** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if the data pointed to by **binary** does not match the format specified by **binaryFormat**.
    * 
    * @param count Specifies the number of shader object handles contained in **shaders**.
    * @param shaders Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
    * @param binaryFormat Specifies the format of the shader binaries contained in **binary**.
    * @param binary Specifies the address of an array of bytes containing pre-compiled binary shader code.
    * @param length Specifies the length of the array whose address is given in **binary**.

    * @see **`glGetProgram`**, **`glGetProgramBinary`**, **`glProgramBinary`**

    **/
    static function shaderBinary(count:Int, shaders:DataPointer, bin_aryFormat:Int, bin_ary:DataPointer, length:Int):Void return ExtensionsNative.shaderBinary(count, shaders, bin_aryFormat, bin_ary, length);
    static function shaderOp1EXT(op:Int, res:Int, arg1:Int):Void return ExtensionsNative.shaderOp1EXT(op, res, arg1);
    static function shaderOp2EXT(op:Int, res:Int, arg1:Int, arg2:Int):Void return ExtensionsNative.shaderOp2EXT(op, res, arg1, arg2);
    static function shaderOp3EXT(op:Int, res:Int, arg1:Int, arg2:Int, arg3:Int):Void return ExtensionsNative.shaderOp3EXT(op, res, arg1, arg2, arg3);
    /**
    * - #### Purpose:
    * Replaces the source code in a shader object
    * ### Description:
    * **glShaderSource** sets the source code in **shader** to the source code in the array of strings specified by **string**. Any source code previously stored in the shader object is completely replaced. The number of strings in the array is specified by **count**. If **length** is `NULL`, each string is assumed to be null terminated. If **length** is a value other than `NULL`, it points to an array containing a string length for each of the corresponding elements of **string**. Each element in the **length** array may contain the length of the corresponding string (the null character is not counted as part of the string length) or a value less than 0 to indicate that the string is null terminated. The source code strings are not scanned or parsed at this time; they are simply copied into the specified shader object.
    * 
    * 
    * ### Notes:
    * OpenGL copies the shader source code strings when **glShaderSource** is called, so an application may free its copy of the source code strings immediately after the function returns.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **shader** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **shader** is not a shader object.
    * 
    * `GL_INVALID_VALUE` is generated if **count** is less than 0.
    * 
    * @param shader Specifies the handle of the shader object whose source code is to be replaced.
    * @param count Specifies the number of elements in the **string** and **length** arrays.
    * @param string Specifies an array of pointers to strings containing the source code to be loaded into the shader.
    * @param length Specifies an array of string lengths.

    * @see **`glCompileShader`**, **`glCreateShader`**, **`glDeleteShader`**

    **/
    static function shaderSource(shader:Int, count:Int, strin_g:String, length:DataPointer):Void return ExtensionsNative.shaderSource(shader, count, strin_g, length);
    static function shaderSourceARB(shaderObj:Int, count:Int, strin_g:String, length:DataPointer):Void return ExtensionsNative.shaderSourceARB(shaderObj, count, strin_g, length);
    /**
    * - #### Purpose:
    * change an active shader storage block binding
    * ### Description:
    * **glShaderStorageBlockBinding**, changes the active shader storage block with an assigned index of **storageBlockIndex** in program object **program**. **storageBlockIndex** must be an active shader storage block index in **program**. **storageBlockBinding** must be less than the value of `GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`. If successful, **glShaderStorageBlockBinding** specifies that **program** will use the data store of the buffer object bound to the binding point **storageBlockBinding** to read and write the values of the buffer variables in the shader storage block identified by **storageBlockIndex**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not the name of either a program or shader object.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is the name of a shader object.
    * 
    * `GL_INVALID_VALUE` is generated if **storageBlockIndex** is not an active shader storage block index in **program**, or if **storageBlockBinding** is greater than or equal to the value of `MAX_SHADER_STORAGE_BUFFER_BINDINGS`.
    * 
    * @param program The name of the program containing the block whose binding to change.
    * @param storageBlockIndex The index storage block within the program.
    * @param storageBlockBinding The index storage block binding to associate with the specified storage block.

    * @see **/
    static function shaderStorageBlockBinding(program:Int, storageBlockIndex:Int, storageBlockBin_din_g:Int):Void return ExtensionsNative.shaderStorageBlockBinding(program, storageBlockIndex, storageBlockBin_din_g);
    static function shadingRateEXT(rate:Int):Void return ExtensionsNative.shadingRateEXT(rate);
    static function shadingRateCombinerOpsEXT(combin_erOp0:Int, combin_erOp1:Int):Void return ExtensionsNative.shadingRateCombinerOpsEXT(combin_erOp0, combin_erOp1);
    static function shadingRateImageBarrierNV(synchronize:Bool):Void return ExtensionsNative.shadingRateImageBarrierNV(synchronize);
    static function shadingRateQCOM(rate:Int):Void return ExtensionsNative.shadingRateQCOM(rate);
    static function shadingRateImagePaletteNV(viewport:Int, first:Int, count:Int, rates:DataPointer):Void return ExtensionsNative.shadingRateImagePaletteNV(viewport, first, count, rates);
    static function shadingRateSampleOrderNV(order:Int):Void return ExtensionsNative.shadingRateSampleOrderNV(order);
    static function shadingRateSampleOrderCustomNV(rate:Int, samples:Int, locations:DataPointer):Void return ExtensionsNative.shadingRateSampleOrderCustomNV(rate, samples, locations);
    static function sharpenTexFuncSGIS(target:Int, n:Int, poin_ts:DataPointer):Void return ExtensionsNative.sharpenTexFuncSGIS(target, n, poin_ts);
    static function signalSemaphoreEXT(semaphore:Int, numBufferBarriers:Int, buffers:DataPointer, numTextureBarriers:Int, textures:DataPointer, dstLayouts:DataPointer):Void return ExtensionsNative.signalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    static function signalSemaphoreui64NVX(signalGpu:Int, fenceObjectCount:Int, semaphoreArray:DataPointer, fenceValueArray:DataPointer):Void return ExtensionsNative.signalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    static function specializeShader(shader:Int, pEntryPoin_t:String, numSpecializationConstants:Int, pConstantIndex:DataPointer, pConstantValue:DataPointer):Void return ExtensionsNative.specializeShader(shader, pEntryPoin_t, numSpecializationConstants, pConstantIndex, pConstantValue);
    static function specializeShaderARB(shader:Int, pEntryPoin_t:String, numSpecializationConstants:Int, pConstantIndex:DataPointer, pConstantValue:DataPointer):Void return ExtensionsNative.specializeShaderARB(shader, pEntryPoin_t, numSpecializationConstants, pConstantIndex, pConstantValue);
    static function spriteParameterfSGIX(pname:Int, param:Float):Void return ExtensionsNative.spriteParameterfSGIX(pname, param);
    static function spriteParameterfvSGIX(pname:Int, params:DataPointer):Void return ExtensionsNative.spriteParameterfvSGIX(pname, params);
    static function spriteParameteriSGIX(pname:Int, param:Int):Void return ExtensionsNative.spriteParameteriSGIX(pname, param);
    static function spriteParameterivSGIX(pname:Int, params:DataPointer):Void return ExtensionsNative.spriteParameterivSGIX(pname, params);
    static function startInstrumentsSGIX():Void return ExtensionsNative.startInstrumentsSGIX();
    static function startTilingQCOM(x:Int, y:Int, width:Int, height:Int, preserveMask:Int):Void return ExtensionsNative.startTilingQCOM(x, y, width, height, preserveMask);
    static function stateCaptureNV(state:Int, mode:Int):Void return ExtensionsNative.stateCaptureNV(state, mode);
    static function stencilClearTagEXT(stencilTagBits:Int, stencilClearTag:Int):Void return ExtensionsNative.stencilClearTagEXT(stencilTagBits, stencilClearTag);
    static function stencilFillPathInstancedNV(numPaths:Int, pathNameType:Int, paths:DataPointer, pathBase:Int, fillMode:Int, mask:Int, transformType:Int, transformValues:DataPointer):Void return ExtensionsNative.stencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    static function stencilFillPathNV(path:Int, fillMode:Int, mask:Int):Void return ExtensionsNative.stencilFillPathNV(path, fillMode, mask);
    /**
    * - #### Purpose:
    * set front and back function and reference value for stencil testing
    * ### Description:
    * Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil planes are first drawn into using GL drawing primitives, then geometry and images are rendered using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.
    * 
    * The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call **`glEnable`** and **glDisable** with argument `GL_STENCIL_TEST`. To specify actions based on the outcome of the stencil test, call **`glStencilOp`** or **`glStencilOpSeparate`**.
    * 
    * There can be two separate sets of **func**, **ref**, and **mask** parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. **`glStencilFunc`** sets both front and back stencil state to the same values. Use **`glStencilFuncSeparate`** to set front and back stencil state to different values.
    * 
    * **func** is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. **ref** is an integer reference value that is used in the stencil comparison. It is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. **mask** is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison.
    * 
    * If stencil represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by **func**. Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see **`glStencilOp`**). All tests treat stencil values as unsigned integers in the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer.
    * 
    * The following values are accepted by **func**:
    * 
    * *``GL_NEVER``* Always fails.
    * 
    * *``GL_LESS``* Passes if ( **ref** &amp; **mask** ) &lt; ( stencil &amp; **mask** ).
    * 
    * *``GL_LEQUAL``* Passes if ( **ref** &amp; **mask** ) &lt;= ( stencil &amp; **mask** ).
    * 
    * *``GL_GREATER``* Passes if ( **ref** &amp; **mask** ) &gt; ( stencil &amp; **mask** ).
    * 
    * *``GL_GEQUAL``* Passes if ( **ref** &amp; **mask** ) &gt;= ( stencil &amp; **mask** ).
    * 
    * *``GL_EQUAL``* Passes if ( **ref** &amp; **mask** ) = ( stencil &amp; **mask** ).
    * 
    * *``GL_NOTEQUAL``* Passes if ( **ref** &amp; **mask** ) != ( stencil &amp; **mask** ).
    * 
    * *``GL_ALWAYS``* Always passes.
    * 
    * 
    * ### Notes:
    * Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.
    * 
    * **`glStencilFunc`** is the same as calling **`glStencilFuncSeparate`** with **face** set to `GL_FRONT_AND_BACK`.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **func** is not one of the eight accepted values.
    * 
    * @param func Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`.
    * @param ref Specifies the reference value for the stencil test. **ref** is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The initial value is 0.
    * @param mask Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.

    * @see **`glBlendFunc`**, **`glDepthFunc`**, **`glEnable`**, **`glLogicOp`**, **`glStencilFuncSeparate`**, **`glStencilMask`**, **`glStencilMaskSeparate`**, **`glStencilOp`**, **`glStencilOpSeparate`**

    **/
    static function stencilFunc(func:Int, ref:Int, mask:Int):Void return ExtensionsNative.stencilFunc(func, ref, mask);
    /**
    * - #### Purpose:
    * set front and/or back function and reference value for stencil testing
    * ### Description:
    * Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.
    * 
    * The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call **`glEnable`** and **glDisable** with argument `GL_STENCIL_TEST`. To specify actions based on the outcome of the stencil test, call **`glStencilOp`** or **`glStencilOpSeparate`**.
    * 
    * There can be two separate sets of **func**, **ref**, and **mask** parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. **`glStencilFunc`** sets both front and back stencil state to the same values, as if **`glStencilFuncSeparate`** were called with **face** set to `GL_FRONT_AND_BACK`.
    * 
    * **func** is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. **ref** is an integer reference value that is used in the stencil comparison. It is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. **mask** is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison.
    * 
    * If stencil represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by **func**. Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see **`glStencilOp`**). All tests treat stencil values as unsigned integers in the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer.
    * 
    * The following values are accepted by **func**:
    * 
    * *``GL_NEVER``* Always fails.
    * 
    * *``GL_LESS``* Passes if ( **ref** &amp; **mask** ) &lt; ( stencil &amp; **mask** ).
    * 
    * *``GL_LEQUAL``* Passes if ( **ref** &amp; **mask** ) &lt;= ( stencil &amp; **mask** ).
    * 
    * *``GL_GREATER``* Passes if ( **ref** &amp; **mask** ) &gt; ( stencil &amp; **mask** ).
    * 
    * *``GL_GEQUAL``* Passes if ( **ref** &amp; **mask** ) &gt;= ( stencil &amp; **mask** ).
    * 
    * *``GL_EQUAL``* Passes if ( **ref** &amp; **mask** ) = ( stencil &amp; **mask** ).
    * 
    * *``GL_NOTEQUAL``* Passes if ( **ref** &amp; **mask** ) != ( stencil &amp; **mask** ).
    * 
    * *``GL_ALWAYS``* Always passes.
    * 
    * 
    * ### Notes:
    * Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **func** is not one of the eight accepted values.
    * 
    * @param face Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`.
    * @param func Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`.
    * @param ref Specifies the reference value for the stencil test. **ref** is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The initial value is 0.
    * @param mask Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.

    * @see **`glBlendFunc`**, **`glDepthFunc`**, **`glEnable`**, **`glLogicOp`**, **`glStencilFunc`**, **`glStencilMask`**, **`glStencilMaskSeparate`**, **`glStencilOp`**, **`glStencilOpSeparate`**

    **/
    static function stencilFuncSeparate(face:Int, func:Int, ref:Int, mask:Int):Void return ExtensionsNative.stencilFuncSeparate(face, func, ref, mask);
    static function stencilFuncSeparateATI(frontfunc:Int, backfunc:Int, ref:Int, mask:Int):Void return ExtensionsNative.stencilFuncSeparateATI(frontfunc, backfunc, ref, mask);
    /**
    * - #### Purpose:
    * control the front and back writing of individual bits in the stencil planes
    * ### Description:
    * **glStencilMask** controls the writing of individual bits in the stencil planes. The least significant n bits of **mask**, where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing.
    * 
    * There can be two separate **mask** writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. **`glStencilMask`** sets both front and back stencil writemasks to the same values. Use **`glStencilMaskSeparate`** to set front and back stencil writemasks to different values.
    * 
    * 
    * ### Notes:
    * **`glStencilMask`** is the same as calling **`glStencilMaskSeparate`** with **face** set to `GL_FRONT_AND_BACK`.
    * 
    * 
    * ### Errors:
    * @param mask Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.

    * @see **`glColorMask`**, **`glDepthMask`**, **`glStencilFunc`**, **`glStencilFuncSeparate`**, **`glStencilMaskSeparate`**, **`glStencilOp`**, **`glStencilOpSeparate`**

    **/
    static function stencilMask(mask:Int):Void return ExtensionsNative.stencilMask(mask);
    /**
    * - #### Purpose:
    * control the front and/or back writing of individual bits in the stencil planes
    * ### Description:
    * **glStencilMaskSeparate** controls the writing of individual bits in the stencil planes. The least significant n bits of **mask**, where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing.
    * 
    * There can be two separate **mask** writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. **`glStencilMask`** sets both front and back stencil writemasks to the same values, as if **`glStencilMaskSeparate`** were called with **face** set to `GL_FRONT_AND_BACK`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **face** is not one of the accepted tokens.
    * 
    * @param face Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`.
    * @param mask Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.

    * @see **`glColorMask`**, **`glDepthMask`**, **`glStencilFunc`**, **`glStencilFuncSeparate`**, **`glStencilMask`**, **`glStencilOp`**, **`glStencilOpSeparate`**

    **/
    static function stencilMaskSeparate(face:Int, mask:Int):Void return ExtensionsNative.stencilMaskSeparate(face, mask);
    /**
    * - #### Purpose:
    * set front and back stencil test actions
    * ### Description:
    * Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.
    * 
    * The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call **`glEnable`** and **glDisable** with argument `GL_STENCIL_TEST`; to control it, call **`glStencilFunc`** or **`glStencilFuncSeparate`**.
    * 
    * There can be two separate sets of **sfail**, **dpfail**, and **dppass** parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. **`glStencilOp`** sets both front and back stencil state to the same values. Use **`glStencilOpSeparate`** to set front and back stencil state to different values.
    * 
    * **glStencilOp** takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and **sfail** specifies what happens to the stencil buffer contents. The following eight actions are possible.
    * 
    * *``GL_KEEP``* Keeps the current value.
    * 
    * *``GL_ZERO``* Sets the stencil buffer value to 0.
    * 
    * *``GL_REPLACE``* Sets the stencil buffer value to ref, as specified by **`glStencilFunc`**.
    * 
    * *``GL_INCR``* Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.
    * 
    * *``GL_INCR_WRAP``* Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.
    * 
    * *``GL_DECR``* Decrements the current stencil buffer value. Clamps to 0.
    * 
    * *``GL_DECR_WRAP``* Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.
    * 
    * *``GL_INVERT``* Bitwise inverts the current stencil buffer value.
    * 
    * Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2 n - 1, where n is the value returned by querying `GL_STENCIL_BITS`.
    * 
    * The other two arguments to **glStencilOp** specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed (**dppass**) or fail (**dpfail**) (see **`glDepthFunc`**). The actions are specified using the same eight symbolic constants as **sfail**. Note that **dpfail** is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, **sfail** and **dppass** specify stencil action when the stencil test fails and passes, respectively.
    * 
    * 
    * ### Notes:
    * Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil tests always pass, regardless of any call to **glStencilOp**.
    * 
    * **`glStencilOp`** is the same as calling **`glStencilOpSeparate`** with **face** set to `GL_FRONT_AND_BACK`.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **sfail**, **dpfail**, or **dppass** is any value other than the defined constant values.
    * 
    * @param sfail Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`.
    * @param dpfail Specifies the stencil action when the stencil test passes, but the depth test fails. **dpfail** accepts the same symbolic constants as **sfail**. The initial value is `GL_KEEP`.
    * @param dppass Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. **dppass** accepts the same symbolic constants as **sfail**. The initial value is `GL_KEEP`.

    * @see **`glBlendFunc`**, **`glDepthFunc`**, **`glEnable`**, **`glLogicOp`**, **`glStencilFunc`**, **`glStencilFuncSeparate`**, **`glStencilMask`**, **`glStencilMaskSeparate`**, **`glStencilOpSeparate`**

    **/
    static function stencilOp(fail:Int, zfail:Int, zpass:Int):Void return ExtensionsNative.stencilOp(fail, zfail, zpass);
    /**
    * - #### Purpose:
    * set front and/or back stencil test actions
    * ### Description:
    * Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.
    * 
    * The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call **`glEnable`** and **glDisable** with argument `GL_STENCIL_TEST`; to control it, call **`glStencilFunc`** or **`glStencilFuncSeparate`**.
    * 
    * There can be two separate sets of **sfail**, **dpfail**, and **dppass** parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. **`glStencilOp`** sets both front and back stencil state to the same values, as if **`glStencilOpSeparate`** were called with **face** set to `GL_FRONT_AND_BACK`.
    * 
    * **glStencilOpSeparate** takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and **sfail** specifies what happens to the stencil buffer contents. The following eight actions are possible.
    * 
    * *``GL_KEEP``* Keeps the current value.
    * 
    * *``GL_ZERO``* Sets the stencil buffer value to 0.
    * 
    * *``GL_REPLACE``* Sets the stencil buffer value to ref, as specified by **`glStencilFunc`**.
    * 
    * *``GL_INCR``* Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.
    * 
    * *``GL_INCR_WRAP``* Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.
    * 
    * *``GL_DECR``* Decrements the current stencil buffer value. Clamps to 0.
    * 
    * *``GL_DECR_WRAP``* Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.
    * 
    * *``GL_INVERT``* Bitwise inverts the current stencil buffer value.
    * 
    * Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2 n - 1, where n is the value returned by querying `GL_STENCIL_BITS`.
    * 
    * The other two arguments to **glStencilOpSeparate** specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed (**dppass**) or fail (**dpfail**) (see **`glDepthFunc`**). The actions are specified using the same eight symbolic constants as **sfail**. Note that **dpfail** is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, **sfail** and **dppass** specify stencil action when the stencil test fails and passes, respectively.
    * 
    * 
    * ### Notes:
    * Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **face** is any value other than `GL_FRONT`, `GL_BACK`, or `GL_FRONT_AND_BACK`.
    * 
    * `GL_INVALID_ENUM` is generated if **sfail**, **dpfail**, or **dppass** is any value other than the eight defined constant values.
    * 
    * @param face Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`.
    * @param sfail Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`.
    * @param dpfail Specifies the stencil action when the stencil test passes, but the depth test fails. **dpfail** accepts the same symbolic constants as **sfail**. The initial value is `GL_KEEP`.
    * @param dppass Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. **dppass** accepts the same symbolic constants as **sfail**. The initial value is `GL_KEEP`.

    * @see **`glBlendFunc`**, **`glDepthFunc`**, **`glEnable`**, **`glLogicOp`**, **`glStencilFunc`**, **`glStencilFuncSeparate`**, **`glStencilMask`**, **`glStencilMaskSeparate`**, **`glStencilOp`**

    **/
    static function stencilOpSeparate(face:Int, sfail:Int, dpfail:Int, dppass:Int):Void return ExtensionsNative.stencilOpSeparate(face, sfail, dpfail, dppass);
    static function stencilOpSeparateATI(face:Int, sfail:Int, dpfail:Int, dppass:Int):Void return ExtensionsNative.stencilOpSeparateATI(face, sfail, dpfail, dppass);
    static function stencilOpValueAMD(face:Int, value:Int):Void return ExtensionsNative.stencilOpValueAMD(face, value);
    static function stencilStrokePathInstancedNV(numPaths:Int, pathNameType:Int, paths:DataPointer, pathBase:Int, reference:Int, mask:Int, transformType:Int, transformValues:DataPointer):Void return ExtensionsNative.stencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    static function stencilStrokePathNV(path:Int, reference:Int, mask:Int):Void return ExtensionsNative.stencilStrokePathNV(path, reference, mask);
    static function stencilThenCoverFillPathInstancedNV(numPaths:Int, pathNameType:Int, paths:DataPointer, pathBase:Int, fillMode:Int, mask:Int, coverMode:Int, transformType:Int, transformValues:DataPointer):Void return ExtensionsNative.stencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
    static function stencilThenCoverFillPathNV(path:Int, fillMode:Int, mask:Int, coverMode:Int):Void return ExtensionsNative.stencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
    static function stencilThenCoverStrokePathInstancedNV(numPaths:Int, pathNameType:Int, paths:DataPointer, pathBase:Int, reference:Int, mask:Int, coverMode:Int, transformType:Int, transformValues:DataPointer):Void return ExtensionsNative.stencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
    static function stencilThenCoverStrokePathNV(path:Int, reference:Int, mask:Int, coverMode:Int):Void return ExtensionsNative.stencilThenCoverStrokePathNV(path, reference, mask, coverMode);
    static function stopInstrumentsSGIX(marker:Int):Void return ExtensionsNative.stopInstrumentsSGIX(marker);
    static function stringMarkerGREMEDY(len:Int, strin_g:DataPointer):Void return ExtensionsNative.stringMarkerGREMEDY(len, strin_g);
    static function subpixelPrecisionBiasNV(xbits:Int, ybits:Int):Void return ExtensionsNative.subpixelPrecisionBiasNV(xbits, ybits);
    static function swizzleEXT(res:Int, in_:Int, outX:Int, outY:Int, outZ:Int, outW:Int):Void return ExtensionsNative.swizzleEXT(res, in_, outX, outY, outZ, outW);
    static function syncTextureINTEL(texture:Int):Void return ExtensionsNative.syncTextureINTEL(texture);
    static function tagSampleBufferSGIX():Void return ExtensionsNative.tagSampleBufferSGIX();
    static function tangent3bEXT(tx:Int, ty:Int, tz:Int):Void return ExtensionsNative.tangent3bEXT(tx, ty, tz);
    static function tangent3bvEXT(v:DataPointer):Void return ExtensionsNative.tangent3bvEXT(v);
    static function tangent3dEXT(tx:DataPointer, ty:DataPointer, tz:DataPointer):Void return ExtensionsNative.tangent3dEXT(tx, ty, tz);
    static function tangent3dvEXT(v:DataPointer):Void return ExtensionsNative.tangent3dvEXT(v);
    static function tangent3fEXT(tx:Float, ty:Float, tz:Float):Void return ExtensionsNative.tangent3fEXT(tx, ty, tz);
    static function tangent3fvEXT(v:DataPointer):Void return ExtensionsNative.tangent3fvEXT(v);
    static function tangent3iEXT(tx:Int, ty:Int, tz:Int):Void return ExtensionsNative.tangent3iEXT(tx, ty, tz);
    static function tangent3ivEXT(v:DataPointer):Void return ExtensionsNative.tangent3ivEXT(v);
    static function tangent3sEXT(tx:Int, ty:Int, tz:Int):Void return ExtensionsNative.tangent3sEXT(tx, ty, tz);
    static function tangent3svEXT(v:DataPointer):Void return ExtensionsNative.tangent3svEXT(v);
    static function tangentPointerEXT(type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.tangentPointerEXT(type, stride, poin_ter);
    static function tbufferMask3DFX(mask:Int):Void return ExtensionsNative.tbufferMask3DFX(mask);
    static function tessellationFactorAMD(factor:Float):Void return ExtensionsNative.tessellationFactorAMD(factor);
    static function tessellationModeAMD(mode:Int):Void return ExtensionsNative.tessellationModeAMD(mode);
    static function testFenceAPPLE(fence:Int):Bool return ExtensionsNative.testFenceAPPLE(fence);
    static function testFenceNV(fence:Int):Bool return ExtensionsNative.testFenceNV(fence);
    static function testObjectAPPLE(object:Int, name:Int):Bool return ExtensionsNative.testObjectAPPLE(object, name);
    static function texAttachMemoryNV(target:Int, memory:Int, offset:Int):Void return ExtensionsNative.texAttachMemoryNV(target, memory, offset);
    /**
    * - #### Purpose:
    * attach a buffer object's data store to a buffer texture object
    * ### Description:
    * **glTexBuffer** and **glTextureBuffer** attaches the data store of a specified buffer object to a specified texture object, and specify the storage format for the texture image found in the buffer object. The texture object must be a buffer texture.
    * 
    * If **buffer** is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If **buffer** is non-zero, it must be the name of an existing buffer object.
    * 
    * **internalformat** specifies the storage format, and must be one of the following sized internal formats:
    * 
    * When a buffer object is attached to a buffer texture, the buffer object's data store is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \left\lfloor { size \over { components \times sizeof(base\_type) } } \right\rfloor $$ where $size$ is the size of the buffer object in basic machine units (the value of `GL_BUFFER_SIZE` for **buffer**), and $components$ and $base\_type$ are the element count and base data type for elements, as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent limit `GL_MAX_TEXTURE_BUFFER_SIZE`. When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels in the texel array.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glTexBuffer** if **target** is not `GL_TEXTURE_BUFFER`.
    * 
    * `GL_INVALID_OPERATION` is generated by **glTextureBuffer** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_ENUM` is generated by **glTextureBuffer** if the effective target of **texture** is not `GL_TEXTURE_BUFFER`.
    * 
    * `GL_INVALID_ENUM` is generated if **internalformat** is not one of the sized internal formats described above.
    * 
    * `GL_INVALID_OPERATION` is generated if **buffer** is not zero and is not the name of an existing buffer object.
    * 
    * @param target Specifies the target to which the texture is bound for **glTexBuffer**. Must be `GL_TEXTURE_BUFFER`.
    * @param texture Specifies the texture object name for **glTextureBuffer**.
    * @param internalformat Specifies the internal format of the data in the store belonging to **buffer**.
    * @param buffer Specifies the name of the buffer object whose storage to attach to the active buffer texture.

    * @see **`glGenBuffers`**, **`glBindBuffer`**, **`glBufferData`**, **`glDeleteBuffers`**, **`glGenTextures`**, **`glBindTexture`**, **`glDeleteTextures`**

    **/
    static function texBuffer(target:Int, in_ternalformat:Int, buffer:Int):Void return ExtensionsNative.texBuffer(target, in_ternalformat, buffer);
    static function texBufferARB(target:Int, in_ternalformat:Int, buffer:Int):Void return ExtensionsNative.texBufferARB(target, in_ternalformat, buffer);
    static function texBufferEXT(target:Int, in_ternalformat:Int, buffer:Int):Void return ExtensionsNative.texBufferEXT(target, in_ternalformat, buffer);
    static function texBufferOES(target:Int, in_ternalformat:Int, buffer:Int):Void return ExtensionsNative.texBufferOES(target, in_ternalformat, buffer);
    /**
    * - #### Purpose:
    * attach a range of a buffer object's data store to a buffer texture object
    * ### Description:
    * **glTexBufferRange** and **glTextureBufferRange** attach a range of the data store of a specified buffer object to a specified texture object, and specify the storage format for the texture image found in the buffer object. The texture object must be a buffer texture.
    * 
    * If **buffer** is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If **buffer** is non-zero, it must be the name of an existing buffer object.
    * 
    * The start and size of the range are specified by **offset** and **size** respectively, both measured in basic machine units. **offset** must be greater than or equal to zero, **size** must be greater than zero, and the sum of **offset** and **size** must not exceed the value of `GL_BUFFER_SIZE` for **buffer**. Furthermore, **offset** must be an integer multiple of the value of `GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`.
    * 
    * **internalformat** specifies the storage format, and must be one of the following sized internal formats:
    * 
    * When a range of a buffer object is attached to a buffer texture, the specified range of the buffer object's data store is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \left\lfloor { size \over { components \times sizeof(base\_type) } } \right\rfloor $$ where $components$ and $base\_type$ are the element count and base data type for elements, as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent limit `GL_MAX_TEXTURE_BUFFER_SIZE`. When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels in the texel array.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glTexBufferRange** if **target** is not `GL_TEXTURE_BUFFER`.
    * 
    * `GL_INVALID_OPERATION` is generated by **glTextureBufferRange** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_ENUM` is generated by **glTextureBufferRange** if the effective target of **texture** is not `GL_TEXTURE_BUFFER`.
    * 
    * `GL_INVALID_ENUM` is generated if **internalformat** is not one of the sized internal formats described above.
    * 
    * `GL_INVALID_OPERATION` is generated if **buffer** is not zero and is not the name of an existing buffer object.
    * 
    * `GL_INVALID_VALUE` is generated if **offset** is negative, if **size** is less than or equal to zero, or if **offset** + **size** is greater than the value of `GL_BUFFER_SIZE` for **buffer**.
    * 
    * `GL_INVALID_VALUE` is generated if **offset** is not an integer multiple of the value of `GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`.
    * 
    * @param target Specifies the target to which the texture object is bound for **glTexBufferRange**. Must be `GL_TEXTURE_BUFFER`.
    * @param texture Specifies the texture object name for **glTextureBufferRange**.
    * @param internalformat Specifies the internal format of the data in the store belonging to **buffer**.
    * @param buffer Specifies the name of the buffer object whose storage to attach to the active buffer texture.
    * @param offset Specifies the offset of the start of the range of the buffer's data store to attach.
    * @param size Specifies the size of the range of the buffer's data store to attach.

    * @see **`glTexBuffer`**.

    **/
    static function texBufferRange(target:Int, in_ternalformat:Int, buffer:Int, offset:Int, size:Int):Void return ExtensionsNative.texBufferRange(target, in_ternalformat, buffer, offset, size);
    static function texBufferRangeEXT(target:Int, in_ternalformat:Int, buffer:Int, offset:Int, size:Int):Void return ExtensionsNative.texBufferRangeEXT(target, in_ternalformat, buffer, offset, size);
    static function texBufferRangeOES(target:Int, in_ternalformat:Int, buffer:Int, offset:Int, size:Int):Void return ExtensionsNative.texBufferRangeOES(target, in_ternalformat, buffer, offset, size);
    static function texBumpParameterfvATI(pname:Int, param:DataPointer):Void return ExtensionsNative.texBumpParameterfvATI(pname, param);
    static function texBumpParameterivATI(pname:Int, param:DataPointer):Void return ExtensionsNative.texBumpParameterivATI(pname, param);
    static function texCoord1bOES(s:Int):Void return ExtensionsNative.texCoord1bOES(s);
    static function texCoord1bvOES(coords:DataPointer):Void return ExtensionsNative.texCoord1bvOES(coords);
    static function texCoord1d(s:DataPointer):Void return ExtensionsNative.texCoord1d(s);
    static function texCoord1dv(v:DataPointer):Void return ExtensionsNative.texCoord1dv(v);
    static function texCoord1f(s:Float):Void return ExtensionsNative.texCoord1f(s);
    static function texCoord1fv(v:DataPointer):Void return ExtensionsNative.texCoord1fv(v);
    static function texCoord1hNV(s:Int):Void return ExtensionsNative.texCoord1hNV(s);
    static function texCoord1hvNV(v:DataPointer):Void return ExtensionsNative.texCoord1hvNV(v);
    static function texCoord1i(s:Int):Void return ExtensionsNative.texCoord1i(s);
    static function texCoord1iv(v:DataPointer):Void return ExtensionsNative.texCoord1iv(v);
    static function texCoord1s(s:Int):Void return ExtensionsNative.texCoord1s(s);
    static function texCoord1sv(v:DataPointer):Void return ExtensionsNative.texCoord1sv(v);
    static function texCoord1xOES(s:Int):Void return ExtensionsNative.texCoord1xOES(s);
    static function texCoord1xvOES(coords:DataPointer):Void return ExtensionsNative.texCoord1xvOES(coords);
    static function texCoord2bOES(s:Int, t:Int):Void return ExtensionsNative.texCoord2bOES(s, t);
    static function texCoord2bvOES(coords:DataPointer):Void return ExtensionsNative.texCoord2bvOES(coords);
    static function texCoord2d(s:DataPointer, t:DataPointer):Void return ExtensionsNative.texCoord2d(s, t);
    static function texCoord2dv(v:DataPointer):Void return ExtensionsNative.texCoord2dv(v);
    static function texCoord2f(s:Float, t:Float):Void return ExtensionsNative.texCoord2f(s, t);
    static function texCoord2fColor3fVertex3fSUN(s:Float, t:Float, r:Float, g:Float, b:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.texCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
    static function texCoord2fColor3fVertex3fvSUN(tc:DataPointer, c:DataPointer, v:DataPointer):Void return ExtensionsNative.texCoord2fColor3fVertex3fvSUN(tc, c, v);
    static function texCoord2fColor4fNormal3fVertex3fSUN(s:Float, t:Float, r:Float, g:Float, b:Float, a:Float, nx:Float, ny:Float, nz:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.texCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
    static function texCoord2fColor4fNormal3fVertex3fvSUN(tc:DataPointer, c:DataPointer, n:DataPointer, v:DataPointer):Void return ExtensionsNative.texCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
    static function texCoord2fColor4ubVertex3fSUN(s:Float, t:Float, r:Int, g:Int, b:Int, a:Int, x:Float, y:Float, z:Float):Void return ExtensionsNative.texCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
    static function texCoord2fColor4ubVertex3fvSUN(tc:DataPointer, c:DataPointer, v:DataPointer):Void return ExtensionsNative.texCoord2fColor4ubVertex3fvSUN(tc, c, v);
    static function texCoord2fNormal3fVertex3fSUN(s:Float, t:Float, nx:Float, ny:Float, nz:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.texCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
    static function texCoord2fNormal3fVertex3fvSUN(tc:DataPointer, n:DataPointer, v:DataPointer):Void return ExtensionsNative.texCoord2fNormal3fVertex3fvSUN(tc, n, v);
    static function texCoord2fVertex3fSUN(s:Float, t:Float, x:Float, y:Float, z:Float):Void return ExtensionsNative.texCoord2fVertex3fSUN(s, t, x, y, z);
    static function texCoord2fVertex3fvSUN(tc:DataPointer, v:DataPointer):Void return ExtensionsNative.texCoord2fVertex3fvSUN(tc, v);
    static function texCoord2fv(v:DataPointer):Void return ExtensionsNative.texCoord2fv(v);
    static function texCoord2hNV(s:Int, t:Int):Void return ExtensionsNative.texCoord2hNV(s, t);
    static function texCoord2hvNV(v:DataPointer):Void return ExtensionsNative.texCoord2hvNV(v);
    static function texCoord2i(s:Int, t:Int):Void return ExtensionsNative.texCoord2i(s, t);
    static function texCoord2iv(v:DataPointer):Void return ExtensionsNative.texCoord2iv(v);
    static function texCoord2s(s:Int, t:Int):Void return ExtensionsNative.texCoord2s(s, t);
    static function texCoord2sv(v:DataPointer):Void return ExtensionsNative.texCoord2sv(v);
    static function texCoord2xOES(s:Int, t:Int):Void return ExtensionsNative.texCoord2xOES(s, t);
    static function texCoord2xvOES(coords:DataPointer):Void return ExtensionsNative.texCoord2xvOES(coords);
    static function texCoord3bOES(s:Int, t:Int, r:Int):Void return ExtensionsNative.texCoord3bOES(s, t, r);
    static function texCoord3bvOES(coords:DataPointer):Void return ExtensionsNative.texCoord3bvOES(coords);
    static function texCoord3d(s:DataPointer, t:DataPointer, r:DataPointer):Void return ExtensionsNative.texCoord3d(s, t, r);
    static function texCoord3dv(v:DataPointer):Void return ExtensionsNative.texCoord3dv(v);
    static function texCoord3f(s:Float, t:Float, r:Float):Void return ExtensionsNative.texCoord3f(s, t, r);
    static function texCoord3fv(v:DataPointer):Void return ExtensionsNative.texCoord3fv(v);
    static function texCoord3hNV(s:Int, t:Int, r:Int):Void return ExtensionsNative.texCoord3hNV(s, t, r);
    static function texCoord3hvNV(v:DataPointer):Void return ExtensionsNative.texCoord3hvNV(v);
    static function texCoord3i(s:Int, t:Int, r:Int):Void return ExtensionsNative.texCoord3i(s, t, r);
    static function texCoord3iv(v:DataPointer):Void return ExtensionsNative.texCoord3iv(v);
    static function texCoord3s(s:Int, t:Int, r:Int):Void return ExtensionsNative.texCoord3s(s, t, r);
    static function texCoord3sv(v:DataPointer):Void return ExtensionsNative.texCoord3sv(v);
    static function texCoord3xOES(s:Int, t:Int, r:Int):Void return ExtensionsNative.texCoord3xOES(s, t, r);
    static function texCoord3xvOES(coords:DataPointer):Void return ExtensionsNative.texCoord3xvOES(coords);
    static function texCoord4bOES(s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.texCoord4bOES(s, t, r, q);
    static function texCoord4bvOES(coords:DataPointer):Void return ExtensionsNative.texCoord4bvOES(coords);
    static function texCoord4d(s:DataPointer, t:DataPointer, r:DataPointer, q:DataPointer):Void return ExtensionsNative.texCoord4d(s, t, r, q);
    static function texCoord4dv(v:DataPointer):Void return ExtensionsNative.texCoord4dv(v);
    static function texCoord4f(s:Float, t:Float, r:Float, q:Float):Void return ExtensionsNative.texCoord4f(s, t, r, q);
    static function texCoord4fColor4fNormal3fVertex4fSUN(s:Float, t:Float, p:Float, q:Float, r:Float, g:Float, b:Float, a:Float, nx:Float, ny:Float, nz:Float, x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.texCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
    static function texCoord4fColor4fNormal3fVertex4fvSUN(tc:DataPointer, c:DataPointer, n:DataPointer, v:DataPointer):Void return ExtensionsNative.texCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
    static function texCoord4fVertex4fSUN(s:Float, t:Float, p:Float, q:Float, x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.texCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
    static function texCoord4fVertex4fvSUN(tc:DataPointer, v:DataPointer):Void return ExtensionsNative.texCoord4fVertex4fvSUN(tc, v);
    static function texCoord4fv(v:DataPointer):Void return ExtensionsNative.texCoord4fv(v);
    static function texCoord4hNV(s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.texCoord4hNV(s, t, r, q);
    static function texCoord4hvNV(v:DataPointer):Void return ExtensionsNative.texCoord4hvNV(v);
    static function texCoord4i(s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.texCoord4i(s, t, r, q);
    static function texCoord4iv(v:DataPointer):Void return ExtensionsNative.texCoord4iv(v);
    static function texCoord4s(s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.texCoord4s(s, t, r, q);
    static function texCoord4sv(v:DataPointer):Void return ExtensionsNative.texCoord4sv(v);
    static function texCoord4xOES(s:Int, t:Int, r:Int, q:Int):Void return ExtensionsNative.texCoord4xOES(s, t, r, q);
    static function texCoord4xvOES(coords:DataPointer):Void return ExtensionsNative.texCoord4xvOES(coords);
    static function texCoordFormatNV(size:Int, type:Int, stride:Int):Void return ExtensionsNative.texCoordFormatNV(size, type, stride);
    static function texCoordP1ui(type:Int, coords:Int):Void return ExtensionsNative.texCoordP1ui(type, coords);
    static function texCoordP1uiv(type:Int, coords:DataPointer):Void return ExtensionsNative.texCoordP1uiv(type, coords);
    static function texCoordP2ui(type:Int, coords:Int):Void return ExtensionsNative.texCoordP2ui(type, coords);
    static function texCoordP2uiv(type:Int, coords:DataPointer):Void return ExtensionsNative.texCoordP2uiv(type, coords);
    static function texCoordP3ui(type:Int, coords:Int):Void return ExtensionsNative.texCoordP3ui(type, coords);
    static function texCoordP3uiv(type:Int, coords:DataPointer):Void return ExtensionsNative.texCoordP3uiv(type, coords);
    static function texCoordP4ui(type:Int, coords:Int):Void return ExtensionsNative.texCoordP4ui(type, coords);
    static function texCoordP4uiv(type:Int, coords:DataPointer):Void return ExtensionsNative.texCoordP4uiv(type, coords);
    static function texCoordPointer(size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.texCoordPointer(size, type, stride, poin_ter);
    static function texCoordPointerEXT(size:Int, type:Int, stride:Int, count:Int, poin_ter:DataPointer):Void return ExtensionsNative.texCoordPointerEXT(size, type, stride, count, poin_ter);
    static function texCoordPointerListIBM(size:Int, type:Int, stride:Int, poin_ter:DataPointer, ptrstride:Int):Void return ExtensionsNative.texCoordPointerListIBM(size, type, stride, poin_ter, ptrstride);
    static function texCoordPointervINTEL(size:Int, type:Int, poin_ter:DataPointer):Void return ExtensionsNative.texCoordPointervINTEL(size, type, poin_ter);
    static function texEnvf(target:Int, pname:Int, param:Float):Void return ExtensionsNative.texEnvf(target, pname, param);
    static function texEnvfv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texEnvfv(target, pname, params);
    static function texEnvi(target:Int, pname:Int, param:Int):Void return ExtensionsNative.texEnvi(target, pname, param);
    static function texEnviv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texEnviv(target, pname, params);
    static function texEnvx(target:Int, pname:Int, param:Int):Void return ExtensionsNative.texEnvx(target, pname, param);
    static function texEnvxOES(target:Int, pname:Int, param:Int):Void return ExtensionsNative.texEnvxOES(target, pname, param);
    static function texEnvxv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texEnvxv(target, pname, params);
    static function texEnvxvOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texEnvxvOES(target, pname, params);
    static function texEstimateMotionQCOM(ref:Int, target:Int, output:Int):Void return ExtensionsNative.texEstimateMotionQCOM(ref, target, output);
    static function texEstimateMotionRegionsQCOM(ref:Int, target:Int, output:Int, mask:Int):Void return ExtensionsNative.texEstimateMotionRegionsQCOM(ref, target, output, mask);
    static function extrapolateTex2DQCOM(src1:Int, src2:Int, output:Int, scaleFactor:Float):Void return ExtensionsNative.extrapolateTex2DQCOM(src1, src2, output, scaleFactor);
    static function texFilterFuncSGIS(target:Int, filter:Int, n:Int, weights:DataPointer):Void return ExtensionsNative.texFilterFuncSGIS(target, filter, n, weights);
    static function texGend(coord:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.texGend(coord, pname, param);
    static function texGendv(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texGendv(coord, pname, params);
    static function texGenf(coord:Int, pname:Int, param:Float):Void return ExtensionsNative.texGenf(coord, pname, param);
    static function texGenfOES(coord:Int, pname:Int, param:Float):Void return ExtensionsNative.texGenfOES(coord, pname, param);
    static function texGenfv(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texGenfv(coord, pname, params);
    static function texGenfvOES(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texGenfvOES(coord, pname, params);
    static function texGeni(coord:Int, pname:Int, param:Int):Void return ExtensionsNative.texGeni(coord, pname, param);
    static function texGeniOES(coord:Int, pname:Int, param:Int):Void return ExtensionsNative.texGeniOES(coord, pname, param);
    static function texGeniv(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texGeniv(coord, pname, params);
    static function texGenivOES(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texGenivOES(coord, pname, params);
    static function texGenxOES(coord:Int, pname:Int, param:Int):Void return ExtensionsNative.texGenxOES(coord, pname, param);
    static function texGenxvOES(coord:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texGenxvOES(coord, pname, params);
    /**
    * - #### Purpose:
    * specify a one-dimensional texture image
    * ### Description:
    * Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable one-dimensional texturing, call **`glEnable`** and **glDisable** with argument `GL_TEXTURE_1D`.
    * 
    * Texture images are defined with **glTexImage1D**. The arguments describe the parameters of the texture image, such as width, width of the border, level-of-detail number (see **`glTexParameter`**), and the internal resolution and format used to store the image. The last three arguments describe how the image is represented in memory.
    * 
    * If **target** is `GL_PROXY_TEXTURE_1D`, no data is read from **data**, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see **`glGetError`**). To query for an entire mipmap array, use an image array level greater than or equal to 1.
    * 
    * If **target** is `GL_TEXTURE_1D`, data is read from **data** as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on **type**. These values are grouped into sets of one, two, three, or four values, depending on **format**, to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by `GL_UNPACK_LSB_FIRST` (see **`glPixelStore`**).
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
    * 
    * The first element corresponds to the left end of the texture array. Subsequent elements progress left-to-right through the remaining texels in the texture array. The final element corresponds to the right end of the texture array.
    * 
    * **format** determines the composition of each element in **data**. It can assume one of these symbolic values:
    * 
    * *``GL_RED``* Each element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for alpha. Each component is clamped to the range [0,1].
    * 
    * *``GL_RG``* Each element is a single red/green double The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is clamped to the range [0,1].
    * 
    * *``GL_RGB``* *``GL_BGR``* Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is clamped to the range [0,1].
    * 
    * *``GL_RGBA``* *``GL_BGRA``* Each element contains all four components. Each component clamped to the range [0,1].
    * 
    * *``GL_DEPTH_COMPONENT``* Each element is a single depth value. The GL converts it to floating point and clamps to the range [0,1].
    * 
    * If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with **internalformat**. The GL will choose an internal representation that closely approximates that requested by **internalformat**, but it may not match exactly. (The representations specified by `GL_RED`, `GL_RG`, `GL_RGB` and `GL_RGBA` must match exactly.)
    * 
    * **internalformat** may be one of the base internal formats shown in Table 1, below
    * 
    * 
    * 
    * **internalformat** may also be one of the sized internal formats shown in Table 2, below
    * 
    * 
    * 
    * Finally, **internalformat** may also be one of the generic or compressed texture formats shown in Table 3 below
    * 
    * 
    * 
    * If the **internalformat** parameter is one of the generic compressed formats, `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, or `GL_COMPRESSED_RGBA`, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.
    * 
    * If the **internalformat** parameter is `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`or `GL_SRGB8_ALPHA8`, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component c s to a linear component c l is:
    * 
    * c l = { c s 12.92 if c s &amp;le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045
    * 
    * Assume c s is the sRGB component in the range [0,1].
    * 
    * Use the `GL_PROXY_TEXTURE_1D` target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call **`glGetTexLevelParameter`**. If the texture cannot be accommodated, texture state is set to 0.
    * 
    * A one-component texture image uses only the red component of the RGBA color from **data**. A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.
    * 
    * Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See **`glTexParameter`** for details on texture comparison.
    * 
    * 
    * ### Notes:
    * **`glPixelStore`** modes affect texture images.
    * 
    * **data** may be a null pointer. In this case texture memory is allocated to accommodate a texture of width **width**. You can then download subtextures to initialize the texture memory. The image is undefined if the program tries to apply an uninitialized portion of the texture image to a primitive.
    * 
    * **glTexImage1D** specifies the one-dimensional texture for the current texture unit, specified with **`glActiveTexture`**.
    * 
    * `GL_STENCIL_INDEX` may be used for **format** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.
    * 
    * `GL_INVALID_ENUM` is generated if **format** is not an accepted format constant. Format constants other than `GL_STENCIL_INDEX` are accepted.
    * 
    * `GL_INVALID_ENUM` is generated if **type** is not a type constant.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` may be generated if **level** is greater than log 2 &amp;af; max, where max is the returned value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **internalformat** is not one of the accepted resolution and format symbolic constants.
    * 
    * `GL_INVALID_VALUE` is generated if **width** is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **border** is not 0.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and **format** is not `GL_RGB`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and **format** is neither `GL_RGBA` nor `GL_BGRA`.
    * 
    * `GL_INVALID_OPERATION` is generated if **format** is `GL_DEPTH_COMPONENT` and **internalformat** is not `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32`.
    * 
    * `GL_INVALID_OPERATION` is generated if **internalformat** is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32`, and **format** is not `GL_DEPTH_COMPONENT`.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and **data** is not evenly divisible into the number of bytes needed to store in memory a datum indicated by **type**.
    * 
    * @param target Specifies the target texture. Must be `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param internalformat Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
    * @param width Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1.
    * @param border This value must be 0.
    * @param format Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`, `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`.
    * @param type Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.
    * @param data Specifies a pointer to the image data in memory.

    * @see **`glActiveTexture`**, **`glCompressedTexImage1D`**, **`glCompressedTexSubImage1D`**, **`glCopyTexImage1D`**, **`glCopyTexSubImage1D`**, **`glGetCompressedTexImage`**, **`glPixelStore`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**, **`glTexParameter`**

    **/
    static function texImage1D(target:Int, level:Int, in_ternalformat:Int, width:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texImage1D(target, level, in_ternalformat, width, border, format, type, pixels);
    /**
    * - #### Purpose:
    * specify a two-dimensional texture image
    * ### Description:
    * Texturing allows elements of an image array to be read by shaders.
    * 
    * To define texture images, call **glTexImage2D**. The arguments describe the parameters of the texture image, such as height, width, width of the border, level-of-detail number (see **`glTexParameter`**), and number of color components provided. The last three arguments describe how the image is represented in memory.
    * 
    * If **target** is `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_CUBE_MAP`, or `GL_PROXY_TEXTURE_RECTANGLE`, no data is read from **data**, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see **`glGetError`**). To query for an entire mipmap array, use an image array level greater than or equal to 1.
    * 
    * If **target** is `GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE` or one of the `GL_TEXTURE_CUBE_MAP` targets, data is read from **data** as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on **type**. These values are grouped into sets of one, two, three, or four values, depending on **format**, to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by `GL_UNPACK_LSB_FIRST` (see **`glPixelStore`**).
    * 
    * If **target** is `GL_TEXTURE_1D_ARRAY`, data is interpreted as an array of one-dimensional images.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
    * 
    * The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image.
    * 
    * **format** determines the composition of each element in **data**. It can assume one of these symbolic values:
    * 
    * *``GL_RED``* Each element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for alpha. Each component is clamped to the range [0,1].
    * 
    * *``GL_RG``* Each element is a red/green double. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is clamped to the range [0,1].
    * 
    * *``GL_RGB``* *``GL_BGR``* Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is clamped to the range [0,1].
    * 
    * *``GL_RGBA``* *``GL_BGRA``* Each element contains all four components. Each component is clamped to the range [0,1].
    * 
    * *``GL_DEPTH_COMPONENT``* Each element is a single depth value. The GL converts it to floating point and clamps to the range [0,1].
    * 
    * *``GL_DEPTH_STENCIL``* Each element is a pair of depth and stencil values. The depth component of the pair is interpreted as in `GL_DEPTH_COMPONENT`. The stencil component is interpreted based on specified the depth + stencil internal format.
    * 
    * If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with **internalformat**. The GL will choose an internal representation that closely approximates that requested by **internalformat**, but it may not match exactly. (The representations specified by `GL_RED`, `GL_RG`, `GL_RGB`, and `GL_RGBA` must match exactly.)
    * 
    * **internalformat** may be one of the base internal formats shown in Table 1, below
    * 
    * 
    * 
    * **internalformat** may also be one of the sized internal formats shown in Table 2, below
    * 
    * 
    * 
    * Finally, **internalformat** may also be one of the generic or compressed texture formats shown in Table 3 below
    * 
    * 
    * 
    * If the **internalformat** parameter is one of the generic compressed formats, `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, or `GL_COMPRESSED_RGBA`, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.
    * 
    * If the **internalformat** parameter is `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component c s to a linear component c l is:
    * 
    * c l = { c s 12.92 if c s &amp;le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045
    * 
    * Assume c s is the sRGB component in the range [0,1].
    * 
    * Use the `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_RECTANGLE`, or `GL_PROXY_TEXTURE_CUBE_MAP` target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call **`glGetTexLevelParameter`**. If the texture cannot be accommodated, texture state is set to 0.
    * 
    * A one-component texture image uses only the red component of the RGBA color extracted from **data**. A two-component image uses the R and G values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.
    * 
    * Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See **`glTexParameter`** for details on texture comparison.
    * 
    * 
    * ### Notes:
    * The **`glPixelStore`** mode affects texture images.
    * 
    * **data** may be a null pointer. In this case, texture memory is allocated to accommodate a texture of width **width** and height **height**. You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to apply an uninitialized portion of the texture image to a primitive.
    * 
    * **glTexImage2D** specifies the two-dimensional texture for the current texture unit, specified with **`glActiveTexture`**.
    * 
    * `GL_STENCIL_INDEX` may be used for **format** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.
    * 
    * `GL_INVALID_ENUM` is generated if **target** is one of the six cube map 2D image targets and the width and height parameters are not equal.
    * 
    * `GL_INVALID_ENUM` is generated if **type** is not a type constant.
    * 
    * `GL_INVALID_VALUE` is generated if **width** is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **target** is not `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY` and **height** is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **target** is `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY` and **height** is less than 0 or greater than `GL_MAX_ARRAY_TEXTURE_LAYERS`.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` may be generated if **level** is greater than log 2 &amp;af; max, where max is the returned value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **internalformat** is not one of the accepted resolution and format symbolic constants.
    * 
    * `GL_INVALID_VALUE` is generated if **width** or **height** is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **border** is not 0.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, or `GL_UNSIGNED_INT_10F_11F_11F_REV`, and **format** is not `GL_RGB`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, or `GL_UNSIGNED_INT_5_9_9_9_REV`, and **format** is neither `GL_RGBA` nor `GL_BGRA`.
    * 
    * `GL_INVALID_OPERATION` is generated if **target** is not `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE`, or `GL_PROXY_TEXTURE_RECTANGLE`, and **internalformat** is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32F`.
    * 
    * `GL_INVALID_OPERATION` is generated if **format** is `GL_DEPTH_COMPONENT` and **internalformat** is not `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32F`.
    * 
    * `GL_INVALID_OPERATION` is generated if **internalformat** is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32F`, and **format** is not `GL_DEPTH_COMPONENT`.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and **data** is not evenly divisible into the number of bytes needed to store in memory a datum indicated by **type**.
    * 
    * `GL_INVALID_VALUE` is generated if **target** is `GL_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_RECTANGLE` and **level** is not 0.
    * 
    * @param target Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If **target** is `GL_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_RECTANGLE`, **level** must be 0.
    * @param internalformat Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
    * @param width Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
    * @param height Specifies the height of the texture image, or the number of layers in a texture array, in the case of the `GL_TEXTURE_1D_ARRAY` and `GL_PROXY_TEXTURE_1D_ARRAY` targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
    * @param border This value must be 0.
    * @param format Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`, `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`.
    * @param type Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.
    * @param data Specifies a pointer to the image data in memory.

    * @see **`glActiveTexture`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glTexImage1D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**, **`glTexParameter`**

    **/
    static function texImage2D(target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texImage2D(target, level, in_ternalformat, width, height, border, format, type, pixels);
    /**
    * - #### Purpose:
    * establish the data storage, format, dimensions, and number of samples of a multisample texture's image
    * ### Description:
    * **glTexImage2DMultisample** establishes the data storage, format, dimensions and number of samples of a multisample texture's image.
    * 
    * **target** must be `GL_TEXTURE_2D_MULTISAMPLE` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE`. **width** and **height** are the dimensions in texels of the texture, and must be in the range zero to the value of `GL_MAX_TEXTURE_SIZE` minus one. **samples** specifies the number of samples in the image and must be in the range zero to the value of `GL_MAX_SAMPLES` minus one.
    * 
    * **internalformat** must be a color-renderable, depth-renderable, or stencil-renderable format.
    * 
    * If **fixedsamplelocations** is `GL_TRUE`, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
    * 
    * When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the multisample texture targets.
    * 
    * 
    * ### Notes:
    * **glTexImage2DMultisample** is available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **internalformat** is a depth- or stencil-renderable format and **samples** is greater than the value of `GL_MAX_DEPTH_TEXTURE_SAMPLES`.
    * 
    * `GL_INVALID_OPERATION` is generated if **internalformat** is a color-renderable format and **samples** is greater than the value of `GL_MAX_COLOR_TEXTURE_SAMPLES`.
    * 
    * `GL_INVALID_OPERATION` is generated if **internalformat** is a signed or unsigned integer format and **samples** is greater than the value of `GL_MAX_INTEGER_SAMPLES`.
    * 
    * `GL_INVALID_VALUE` is generated if either **width** or **height** negative or is greater than `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **samples** is zero.
    * 
    * `GL_INVALID_OPERATION` is generated if **samples** is greater than the maximum number of samples supported for this **target** and **internalformat**.
    * 
    * @param target Specifies the target of the operation. **target** must be `GL_TEXTURE_2D_MULTISAMPLE` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE`.
    * @param samples The number of samples in the multisample texture's image.
    * @param internalformat The internal format to be used to store the multisample texture's image. **internalformat** must specify a color-renderable, depth-renderable, or stencil-renderable format.
    * @param width The width of the multisample texture's image, in texels.
    * @param height The height of the multisample texture's image, in texels.
    * @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.

    * @see **`glTexImage3D`**, **`glTexImage2DMultisample`**

    **/
    static function texImage2DMultisample(target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int, fixedsamplelocations:Bool):Void return ExtensionsNative.texImage2DMultisample(target, samples, in_ternalformat, width, height, fixedsamplelocations);
    static function texImage2DMultisampleCoverageNV(target:Int, coverageSamples:Int, colorSamples:Int, in_ternalFormat:Int, width:Int, height:Int, fixedSampleLocations:Bool):Void return ExtensionsNative.texImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, in_ternalFormat, width, height, fixedSampleLocations);
    /**
    * - #### Purpose:
    * specify a three-dimensional texture image
    * ### Description:
    * Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable three-dimensional texturing, call **`glEnable`** and **glDisable** with argument `GL_TEXTURE_3D`.
    * 
    * To define texture images, call **glTexImage3D**. The arguments describe the parameters of the texture image, such as height, width, depth, width of the border, level-of-detail number (see **`glTexParameter`**), and number of color components provided. The last three arguments describe how the image is represented in memory.
    * 
    * If **target** is `GL_PROXY_TEXTURE_3D`, no data is read from **data**, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see **`glGetError`**). To query for an entire mipmap array, use an image array level greater than or equal to 1.
    * 
    * If **target** is `GL_TEXTURE_3D`, data is read from **data** as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on **type**. These values are grouped into sets of one, two, three, or four values, depending on **format**, to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by `GL_UNPACK_LSB_FIRST` (see **`glPixelStore`**).
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
    * 
    * The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image.
    * 
    * **format** determines the composition of each element in **data**. It can assume one of these symbolic values:
    * 
    * *``GL_RED``* Each element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for alpha. Each component is clamped to the range [0,1].
    * 
    * *``GL_RG``* Each element is a red and green pair. The GL converts each to floating point and assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is clamped to the range [0,1].
    * 
    * *``GL_RGB``* *``GL_BGR``* Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is clamped to the range [0,1].
    * 
    * *``GL_RGBA``* *``GL_BGRA``* Each element contains all four components. Each component is clamped to the range [0,1].
    * 
    * If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with **internalformat**. The GL will choose an internal representation that closely approximates that requested by **internalformat**, but it may not match exactly. (The representations specified by `GL_RED`, `GL_RG`, `GL_RGB`, and `GL_RGBA` must match exactly.)
    * 
    * **internalformat** may be one of the base internal formats shown in Table 1, below
    * 
    * 
    * 
    * **internalformat** may also be one of the sized internal formats shown in Table 2, below
    * 
    * 
    * 
    * Finally, **internalformat** may also be one of the generic or compressed texture formats shown in Table 3 below
    * 
    * 
    * 
    * If the **internalformat** parameter is one of the generic compressed formats, `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, or `GL_COMPRESSED_RGBA`, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.
    * 
    * If the **internalformat** parameter is `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`, the texture is treated as if the red, green, blue, or luminance components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component c s to a linear component c l is:
    * 
    * c l = { c s 12.92 if c s &amp;le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045
    * 
    * Assume c s is the sRGB component in the range [0,1].
    * 
    * Use the `GL_PROXY_TEXTURE_3D` target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call **`glGetTexLevelParameter`**. If the texture cannot be accommodated, texture state is set to 0.
    * 
    * A one-component texture image uses only the red component of the RGBA color extracted from **data**. A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.
    * 
    * 
    * ### Notes:
    * The **`glPixelStore`** mode affects texture images.
    * 
    * **data** may be a null pointer. In this case texture memory is allocated to accommodate a texture of width **width**, height **height**, and depth **depth**. You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to apply an uninitialized portion of the texture image to a primitive.
    * 
    * **glTexImage3D** specifies the three-dimensional texture for the current texture unit, specified with **`glActiveTexture`**.
    * 
    * `GL_STENCIL_INDEX` may be used for **format** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** is not `GL_TEXTURE_3D` or `GL_PROXY_TEXTURE_3D`.
    * 
    * `GL_INVALID_ENUM` is generated if **format** is not an accepted format constant. Format constants other than `GL_STENCIL_INDEX` and `GL_DEPTH_COMPONENT` are accepted.
    * 
    * `GL_INVALID_ENUM` is generated if **type** is not a type constant.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` may be generated if **level** is greater than log 2 &amp;af; max, where max is the returned value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **internalformat** is not one of the accepted resolution and format symbolic constants.
    * 
    * `GL_INVALID_VALUE` is generated if **width**, **height**, or **depth** is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **border** is not 0.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and **format** is not `GL_RGB`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and **format** is neither `GL_RGBA` nor `GL_BGRA`.
    * 
    * `GL_INVALID_OPERATION` is generated if **format** or **internalformat** is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32`.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and **data** is not evenly divisible into the number of bytes needed to store in memory a datum indicated by **type**.
    * 
    * @param target Specifies the target texture. Must be one of `GL_TEXTURE_3D`, `GL_PROXY_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_2D_ARRAY`.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the n th mipmap reduction image.
    * @param internalformat Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
    * @param width Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
    * @param height Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
    * @param depth Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
    * @param border This value must be 0.
    * @param format Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`, `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`.
    * @param type Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.
    * @param data Specifies a pointer to the image data in memory.

    * @see **`glActiveTexture`**, **`glCompressedTexImage1D`**, **`glCompressedTexImage2D`**, **`glCompressedTexImage3D`**, **`glCompressedTexSubImage1D`**, **`glCompressedTexSubImage2D`**, **`glCompressedTexSubImage3D`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glGetCompressedTexImage`**, **`glPixelStore`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**, **`glTexParameter`**

    **/
    static function texImage3D(target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texImage3D(target, level, in_ternalformat, width, height, depth, border, format, type, pixels);
    static function texImage3DEXT(target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texImage3DEXT(target, level, in_ternalformat, width, height, depth, border, format, type, pixels);
    /**
    * - #### Purpose:
    * establish the data storage, format, dimensions, and number of samples of a multisample texture's image
    * ### Description:
    * **glTexImage3DMultisample** establishes the data storage, format, dimensions and number of samples of a multisample texture's image.
    * 
    * **target** must be `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`. **width** and **height**are the dimensions in texels of the texture, and must be in the range zero to the value of `GL_MAX_TEXTURE_SIZE` minus one. **depth** is the number of array slices in the array texture's image. **samples** specifies the number of samples in the image and must be in the range zero to the value of `GL_MAX_SAMPLES` minus one.
    * 
    * **internalformat** must be a color-renderable, depth-renderable, or stencil-renderable format.
    * 
    * If **fixedsamplelocations** is `GL_TRUE`, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
    * 
    * When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the multisample texture targets.
    * 
    * 
    * ### Notes:
    * **glTexImage2DMultisample** is available only if the GL version is 3.2 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **internalformat** is a depth- or stencil-renderable format and **samples** is greater than the value of `GL_MAX_DEPTH_TEXTURE_SAMPLES`.
    * 
    * `GL_INVALID_OPERATION` is generated if **internalformat** is a color-renderable format and **samples** is greater than the value of `GL_MAX_COLOR_TEXTURE_SAMPLES`.
    * 
    * `GL_INVALID_OPERATION` is generated if **internalformat** is a signed or unsigned integer format and **samples** is greater than the value of `GL_MAX_INTEGER_SAMPLES`.
    * 
    * `GL_INVALID_VALUE` is generated if either **width** or **height** negative or is greater than `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **depth** is negative or is greater than `GL_MAX_ARRAY_TEXTURE_LAYERS`.
    * 
    * `GL_INVALID_VALUE` is generated if **samples** is zero.
    * 
    * `GL_INVALID_OPERATION` is generated if **samples** is greater than the maximum number of samples supported for this **target** and **internalformat**.
    * 
    * @param target Specifies the target of the operation. **target** must be `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`.
    * @param samples The number of samples in the multisample texture's image.
    * @param internalformat The internal format to be used to store the multisample texture's image. **internalformat** must specify a color-renderable, depth-renderable, or stencil-renderable format.
    * @param width The width of the multisample texture's image, in texels.
    * @param height The height of the multisample texture's image, in texels.
    * @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.

    * @see **`glTexImage3D`**, **`glTexImage2DMultisample`**

    **/
    static function texImage3DMultisample(target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, fixedsamplelocations:Bool):Void return ExtensionsNative.texImage3DMultisample(target, samples, in_ternalformat, width, height, depth, fixedsamplelocations);
    static function texImage3DMultisampleCoverageNV(target:Int, coverageSamples:Int, colorSamples:Int, in_ternalFormat:Int, width:Int, height:Int, depth:Int, fixedSampleLocations:Bool):Void return ExtensionsNative.texImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, in_ternalFormat, width, height, depth, fixedSampleLocations);
    static function texImage3DOES(target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texImage3DOES(target, level, in_ternalformat, width, height, depth, border, format, type, pixels);
    static function texImage4DSGIS(target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, size4d:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texImage4DSGIS(target, level, in_ternalformat, width, height, depth, size4d, border, format, type, pixels);
    static function texPageCommitmentARB(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, commit:Bool):Void return ExtensionsNative.texPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    static function texPageCommitmentEXT(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, commit:Bool):Void return ExtensionsNative.texPageCommitmentEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    static function texPageCommitmentMemNV(target:Int, layer:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, memory:Int, offset:Int, commit:Bool):Void return ExtensionsNative.texPageCommitmentMemNV(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
    static function texParameterIiv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texParameterIiv(target, pname, params);
    static function texParameterIivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texParameterIivEXT(target, pname, params);
    static function texParameterIivOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texParameterIivOES(target, pname, params);
    static function texParameterIuiv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texParameterIuiv(target, pname, params);
    static function texParameterIuivEXT(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texParameterIuivEXT(target, pname, params);
    static function texParameterIuivOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texParameterIuivOES(target, pname, params);
    static function texParameterf(target:Int, pname:Int, param:Float):Void return ExtensionsNative.texParameterf(target, pname, param);
    static function texParameterfv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texParameterfv(target, pname, params);
    static function texParameteri(target:Int, pname:Int, param:Int):Void return ExtensionsNative.texParameteri(target, pname, param);
    static function texParameteriv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texParameteriv(target, pname, params);
    static function texParameterx(target:Int, pname:Int, param:Int):Void return ExtensionsNative.texParameterx(target, pname, param);
    static function texParameterxOES(target:Int, pname:Int, param:Int):Void return ExtensionsNative.texParameterxOES(target, pname, param);
    static function texParameterxv(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texParameterxv(target, pname, params);
    static function texParameterxvOES(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.texParameterxvOES(target, pname, params);
    static function texRenderbufferNV(target:Int, renderbuffer:Int):Void return ExtensionsNative.texRenderbufferNV(target, renderbuffer);
    /**
    * - #### Purpose:
    * simultaneously specify storage for all levels of a one-dimensional texture
    * ### Description:
    * **glTexStorage1D** and **glTextureStorage1D** specify the storage requirements for all levels of a one-dimensional texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an immutable-format texture.
    * 
    * Calling **glTexStorage1D** is equivalent, assuming no errors are generated, to executing the following pseudo-code:
    * 
    * Calling **glTextureStorage1D** is equivalent to the above pseudo-code, where **target** is the effective target of **texture** and it is as if **texture** were bound to **target** for the purposes of **glTexImage1D**.
    * 
    * Since no texture data is actually provided, the values used in the pseudo-code for **format** and **type** are irrelevant and may be considered to be any values that are legal for the chosen **internalformat** enumerant. **internalformat** must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats, `GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format, `GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`. The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling **`glGetTexParameter`** with **pname** set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as **`glTexImage1D`** or another call to **glTexStorage1D**) will result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter the dimensions or format of the object.
    * 
    * 
    * 
    * 
    * ### Notes:
    * `GL_STENCIL_INDEX8` is accepted for **internalformat** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated by **glTexStorage1D** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glTextureStorage1D** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_ENUM` is generated if **internalformat** is not a valid sized internal format.
    * 
    * `GL_INVALID_ENUM` is generated if **target** or the effective target of **texture** is not one of the accepted targets described above.
    * 
    * `GL_INVALID_VALUE` is generated if **width** or **levels** are less than 1.
    * 
    * `GL_INVALID_OPERATION` is generated if **levels** is greater than log 2 width + 1.
    * 
    * @param target Specifies the target to which the texture object is bound for **glTexStorage1D**. Must be one of `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.
    * @param texture Specifies the texture object name for **glTextureStorage1D**. The effective target of **texture** must be one of the valid non-proxy **target** values above.
    * @param levels Specify the number of texture levels.
    * @param internalformat Specifies the sized internal format to be used to store texture image data.
    * @param width Specifies the width of the texture, in texels.

    * @see **`glTexImage1D`**, **`glTexStorage2D`**, **`glTexStorage3D`**.

    **/
    static function texStorage1D(target:Int, levels:Int, in_ternalformat:Int, width:Int):Void return ExtensionsNative.texStorage1D(target, levels, in_ternalformat, width);
    static function texStorage1DEXT(target:Int, levels:Int, in_ternalformat:Int, width:Int):Void return ExtensionsNative.texStorage1DEXT(target, levels, in_ternalformat, width);
    /**
    * - #### Purpose:
    * simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
    * ### Description:
    * **glTexStorage2D** and **glTextureStorage2D** specify the storage requirements for all levels of a two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an immutable-format texture.
    * 
    * The behavior of **glTexStorage2D** depends on the **target** parameter. When **target** is `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_CUBE_MAP`, calling **glTexStorage2D** is equivalent, assuming no errors are generated, to executing the following pseudo-code:
    * 
    * When **target** is `GL_TEXTURE_CUBE_MAP`, **glTexStorage2D** is equivalent to:
    * 
    * When **target** is `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY`, **glTexStorage2D** is equivalent to:
    * 
    * Calling **glTextureStorage2D** is equivalent to the above pseudo-code, where **target** is the effective target of **texture** and it is as if **texture** were bound to **target** for the purposes of **glTexImage2D**.
    * 
    * Since no texture data is actually provided, the values used in the pseudo-code for **format** and **type** are irrelevant and may be considered to be any values that are legal for the chosen **internalformat** enumerant. **internalformat** must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats, `GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format, `GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`. The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling **`glGetTexParameter`** with **pname** set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as **`glTexImage2D`** or another call to **glTexStorage2D**) will result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter the dimensions or format of the object.
    * 
    * 
    * 
    * 
    * ### Notes:
    * `GL_STENCIL_INDEX8` is accepted for **internalformat** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated by **glTexStorage2D** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glTextureStorage2D** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_ENUM` is generated if **internalformat** is not a valid sized internal format.
    * 
    * `GL_INVALID_ENUM` is generated if **target** or the effective target of **texture** is not one of the accepted targets described above.
    * 
    * `GL_INVALID_VALUE` is generated if **width**, **height** or **levels** are less than 1.
    * 
    * `GL_INVALID_OPERATION` is generated if **target** is `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY` and **levels** is greater than log 2 width + 1.
    * 
    * `GL_INVALID_OPERATION` is generated if **target** is not `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY` and **levels** is greater than log 2 max width , &amp;nbsp; height + 1.
    * 
    * @param target Specifies the target to which the texture object is bound for **glTexStorage2D**. Must be one of `GL_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_RECTANGLE`, or `GL_PROXY_TEXTURE_CUBE_MAP`.
    * @param texture Specifies the texture object name for **glTextureStorage2D**. The effective target of **texture** must be one of the valid non-proxy **target** values above.
    * @param levels Specify the number of texture levels.
    * @param internalformat Specifies the sized internal format to be used to store texture image data.
    * @param width Specifies the width of the texture, in texels.
    * @param height Specifies the height of the texture, in texels.

    * @see **`glTexImage2D`**, **`glTexStorage1D`**, **`glTexStorage3D`**.

    **/
    static function texStorage2D(target:Int, levels:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.texStorage2D(target, levels, in_ternalformat, width, height);
    static function texStorage2DEXT(target:Int, levels:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.texStorage2DEXT(target, levels, in_ternalformat, width, height);
    /**
    * - #### Purpose:
    * specify storage for a two-dimensional multisample texture
    * ### Description:
    * **glTexStorage2DMultisample** and **glTextureStorage2DMultisample** specify the storage requirements for a two-dimensional multisample texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an immutable-format texture.
    * 
    * **samples** specifies the number of samples to be used for the texture and must be greater than zero and less than or equal to the value of `GL_MAX_SAMPLES`. **internalformat** must be a color-renderable, depth-renderable, or stencil-renderable format. **width** and **height** specify the width and height, respectively, of the texture. If **fixedsamplelocations** is `GL_TRUE`, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
    * 
    * 
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated by **glTexStorage2DMultisample** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glTextureStorage2DMultisample** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_ENUM` is generated if **internalformat** is not a valid color-renderable, depth-renderable or stencil-renderable format.
    * 
    * `GL_INVALID_ENUM` is generated if **target** or the effective target of **texture** is not one of the accepted targets described above.
    * 
    * `GL_INVALID_VALUE` is generated if **width** or **height** are less than 1 or greater than the value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **levels** is less than 1.
    * 
    * `GL_INVALID_VALUE` is generated if **samples** is zero.
    * 
    * `GL_INVALID_OPERATION` is generated if **samples** is greater than the maximum number of samples supported for this **target** and **internalformat**.
    * 
    * `GL_INVALID_OPERATION` is generated if the value of `GL_TEXTURE_IMMUTABLE_FORMAT` for the texture bound to **target** is not `GL_FALSE`.
    * 
    * @param target Specifies the target to which the texture object is bound for **glTexStorage2DMultisample**. Must be one of `GL_TEXTURE_2D_MULTISAMPLE` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE`.
    * @param texture Specifies the texture object name for **glTextureStorage2DMultisample**. The effective target of **texture** must be one of the valid non-proxy **target** values above.
    * @param samples Specify the number of samples in the texture.
    * @param internalformat Specifies the sized internal format to be used to store texture image data.
    * @param width Specifies the width of the texture, in texels.
    * @param height Specifies the height of the texture, in texels.
    * @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.

    * @see **`glTexImage2D`**, **`glTexImage2DMultisample`**, **`glTexStorage1D`**, **`glTexStorage3D`**.

    **/
    static function texStorage2DMultisample(target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int, fixedsamplelocations:Bool):Void return ExtensionsNative.texStorage2DMultisample(target, samples, in_ternalformat, width, height, fixedsamplelocations);
    /**
    * - #### Purpose:
    * simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
    * ### Description:
    * **glTexStorage3D** and **glTextureStorage3D** specify the storage requirements for all levels of a three-dimensional, two-dimensional array or cube-map array texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an immutable-format texture.
    * 
    * The behavior of **glTexStorage3D** depends on the **target** parameter. When **target** is `GL_TEXTURE_3D`, or `GL_PROXY_TEXTURE_3D`, calling **glTexStorage3D** is equivalent, assuming no errors are generated, to executing the following pseudo-code:
    * 
    * When **target** is `GL_TEXTURE_2D_ARRAY`, `GL_PROXY_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY`, **glTexStorage3D** is equivalent to:
    * 
    * Calling **glTextureStorage3D** is equivalent to the above pseudo-code, where **target** is the effective target of **texture** and it is as if **texture** were bound to **target** for the purposes of **glTexImage3D**.
    * 
    * Since no texture data is actually provided, the values used in the pseudo-code for **format** and **type** are irrelevant and may be considered to be any values that are legal for the chosen **internalformat** enumerant. **internalformat** must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats, `GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format, `GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`. The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling **`glGetTexParameter`** with **pname** set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as **`glTexImage3D`** or another call to **glTexStorage3D**) will result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter the dimensions or format of the object.
    * 
    * 
    * 
    * 
    * ### Notes:
    * `GL_STENCIL_INDEX8` is accepted for **internalformat** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated by **glTexStorage3D** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glTextureStorage3D** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_ENUM` is generated if **internalformat** is not a valid sized internal format.
    * 
    * `GL_INVALID_ENUM` is generated if **target** or the effective target of **texture** is not one of the accepted targets described above.
    * 
    * `GL_INVALID_VALUE` is generated if **width**, **height**, **depth** or **levels** are less than 1.
    * 
    * `GL_INVALID_OPERATION` is generated if **target** is `GL_TEXTURE_3D` or `GL_PROXY_TEXTURE_3D` and **levels** is greater than log 2 max width , &amp;nbsp; height , &amp;nbsp; depth + 1.
    * 
    * `GL_INVALID_OPERATION` is generated if **target** is `GL_TEXTURE_2D_ARRAY`, `GL_PROXY_TEXTURE_2D_ARRAY`, `GL_TEXURE_CUBE_MAP_ARRAY`, or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY` and **levels** is greater than log 2 max width , &amp;nbsp; height + 1.
    * 
    * @param target Specifies the target to which the texture object is bound for **glTexStorage3D**. Must be one of `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_PROXY_TEXTURE_3D`, `GL_PROXY_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY`.
    * @param texture Specifies the texture object name for **glTextureStorage3D**. The effective target of **texture** must be one of the valid non-proxy **target** values above.
    * @param levels Specify the number of texture levels.
    * @param internalformat Specifies the sized internal format to be used to store texture image data.
    * @param width Specifies the width of the texture, in texels.
    * @param height Specifies the height of the texture, in texels.
    * @param depth Specifies the depth of the texture, in texels.

    * @see **`glTexImage3D`**, **`glTexStorage1D`**, **`glTexStorage2D`**.

    **/
    static function texStorage3D(target:Int, levels:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int):Void return ExtensionsNative.texStorage3D(target, levels, in_ternalformat, width, height, depth);
    static function texStorage3DEXT(target:Int, levels:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int):Void return ExtensionsNative.texStorage3DEXT(target, levels, in_ternalformat, width, height, depth);
    /**
    * - #### Purpose:
    * specify storage for a two-dimensional multisample array texture
    * ### Description:
    * **glTexStorage3DMultisample** and **glTextureStorage3DMultisample** specify the storage requirements for a two-dimensional multisample array texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an immutable-format texture.
    * 
    * **samples** specifies the number of samples to be used for the texture and must be greater than zero and less than or equal to the value of `GL_MAX_SAMPLES`. **internalformat** must be a color-renderable, depth-renderable, or stencil-renderable format. **width** and **height** specify the width and height, respectively, of the texture and **depth** specifies the depth (or the number of layers) of the texture. If **fixedsamplelocations** is `GL_TRUE`, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
    * 
    * 
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated by **glTexStorage3DMultisample** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glTextureStorage3DMultisample** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_ENUM` is generated if **internalformat** is not a valid color-renderable, depth-renderable or stencil-renderable format.
    * 
    * `GL_INVALID_ENUM` is generated if **target** or the effective target of **texture** is not one of the accepted targets described above.
    * 
    * `GL_INVALID_VALUE` is generated if **width** or **height** are less than 1 or greater than the value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if **depth** is less than 1 or greater than the value of `GL_MAX_ARRAY_TEXTURE_LAYERS`.
    * 
    * `GL_INVALID_VALUE` is generated if **levels** is less than 1.
    * 
    * `GL_INVALID_VALUE` is generated if **samples** is zero.
    * 
    * `GL_INVALID_OPERATION` is generated if **samples** is greater than the maximum number of samples supported for this **target** and **internalformat**.
    * 
    * `GL_INVALID_OPERATION` is generated if the value of `GL_TEXTURE_IMMUTABLE_FORMAT` for the texture bound to **target** is not `GL_FALSE`.
    * 
    * @param target Specifies the target to which the texture object is bound for **glTexStorage3DMultisample**. Must be one of `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`.
    * @param texture Specifies the texture object name for **glTextureStorage3DMultisample**. The effective target of **texture** must be one of the valid non-proxy **target** values above.
    * @param samples Specify the number of samples in the texture.
    * @param internalformat Specifies the sized internal format to be used to store texture image data.
    * @param width Specifies the width of the texture, in texels.
    * @param height Specifies the height of the texture, in texels.
    * @param depth Specifies the depth of the texture, in layers.
    * @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.

    * @see **`glTexImage3D`**, **`glTexImage3DMultisample`**, **`glTexStorage1D`**, **`glTexStorage2DMultisample`**, **`glTexStorage3D`**.

    **/
    static function texStorage3DMultisample(target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, fixedsamplelocations:Bool):Void return ExtensionsNative.texStorage3DMultisample(target, samples, in_ternalformat, width, height, depth, fixedsamplelocations);
    static function texStorage3DMultisampleOES(target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, fixedsamplelocations:Bool):Void return ExtensionsNative.texStorage3DMultisampleOES(target, samples, in_ternalformat, width, height, depth, fixedsamplelocations);
    static function texStorageAttribs2DEXT(target:Int, levels:Int, in_ternalformat:Int, width:Int, height:Int, attrib_list:DataPointer):Void return ExtensionsNative.texStorageAttribs2DEXT(target, levels, in_ternalformat, width, height, attrib_list);
    static function texStorageAttribs3DEXT(target:Int, levels:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, attrib_list:DataPointer):Void return ExtensionsNative.texStorageAttribs3DEXT(target, levels, in_ternalformat, width, height, depth, attrib_list);
    static function texStorageMem1DEXT(target:Int, levels:Int, in_ternalFormat:Int, width:Int, memory:Int, offset:Int):Void return ExtensionsNative.texStorageMem1DEXT(target, levels, in_ternalFormat, width, memory, offset);
    static function texStorageMem2DEXT(target:Int, levels:Int, in_ternalFormat:Int, width:Int, height:Int, memory:Int, offset:Int):Void return ExtensionsNative.texStorageMem2DEXT(target, levels, in_ternalFormat, width, height, memory, offset);
    static function texStorageMem2DMultisampleEXT(target:Int, samples:Int, in_ternalFormat:Int, width:Int, height:Int, fixedSampleLocations:Bool, memory:Int, offset:Int):Void return ExtensionsNative.texStorageMem2DMultisampleEXT(target, samples, in_ternalFormat, width, height, fixedSampleLocations, memory, offset);
    static function texStorageMem3DEXT(target:Int, levels:Int, in_ternalFormat:Int, width:Int, height:Int, depth:Int, memory:Int, offset:Int):Void return ExtensionsNative.texStorageMem3DEXT(target, levels, in_ternalFormat, width, height, depth, memory, offset);
    static function texStorageMem3DMultisampleEXT(target:Int, samples:Int, in_ternalFormat:Int, width:Int, height:Int, depth:Int, fixedSampleLocations:Bool, memory:Int, offset:Int):Void return ExtensionsNative.texStorageMem3DMultisampleEXT(target, samples, in_ternalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    static function texStorageSparseAMD(target:Int, in_ternalFormat:Int, width:Int, height:Int, depth:Int, layers:Int, flags:Int):Void return ExtensionsNative.texStorageSparseAMD(target, in_ternalFormat, width, height, depth, layers, flags);
    /**
    * - #### Purpose:
    * specify a one-dimensional texture subimage
    * ### Description:
    * Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable or disable one-dimensional texturing, call **`glEnable`** and **glDisable** with argument `GL_TEXTURE_1D`.
    * 
    * **glTexSubImage1D** and **glTextureSubImage1D** redefine a contiguous subregion of an existing one-dimensional texture image. The texels referenced by **pixels** replace the portion of the existing texture array with x indices **xoffset** and xoffset + width - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **pixels** is treated as a byte offset into the buffer object's data store.
    * 
    * 
    * ### Notes:
    * **`glPixelStore`** modes affect texture images.
    * 
    * **glTexSubImage1D** and **glTextureSubImage1D** specify a one-dimensional subtexture for the current texture unit, specified with **`glActiveTexture`**.
    * 
    * `GL_STENCIL_INDEX` is accepted for **format** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** or the effective target of **texture** is not one of the allowable values.
    * 
    * `GL_INVALID_OPERATION` is generated by **glTextureSubImage1D** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_ENUM` is generated if **format** is not an accepted format constant.
    * 
    * `GL_INVALID_ENUM` is generated if **type** is not a type constant.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` may be generated if **level** is greater than log 2 max, where max is the returned value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if xoffset &lt; - b, or if (w - b): --> xoffset + width &gt; w - b, where w is the `GL_TEXTURE_WIDTH`, and b is the width of the `GL_TEXTURE_BORDER` of the texture image being modified. Note that w includes twice the border width.
    * 
    * `GL_INVALID_VALUE` is generated if **width** is less than 0.
    * 
    * `GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous **`glTexImage1D`** operation.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and **format** is not `GL_RGB`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and **format** is neither `GL_RGBA` nor `GL_BGRA`.
    * 
    * `GL_INVALID_OPERATION` is generated if **format** is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX`.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and **pixels** is not evenly divisible into the number of bytes needed to store in memory a datum indicated by **type**.
    * 
    * @param target Specifies the target to which the texture is bound for **glTexSubImage1D**. Must be `GL_TEXTURE_1D`.
    * @param texture Specifies the texture object name for **glTextureSubImage1D**. The effective target of **texture** must be one of the valid **target** values above.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param xoffset Specifies a texel offset in the x direction within the texture array.
    * @param width Specifies the width of the texture subimage.
    * @param format Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`.
    * @param type Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.
    * @param pixels Specifies a pointer to the image data in memory.

    * @see **`glActiveTexture`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexParameter`**, **`glTexSubImage2D`**, **`glTexSubImage3D`**

    **/
    static function texSubImage1D(target:Int, level:Int, xoffset:Int, width:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texSubImage1D(target, level, xoffset, width, format, type, pixels);
    static function texSubImage1DEXT(target:Int, level:Int, xoffset:Int, width:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texSubImage1DEXT(target, level, xoffset, width, format, type, pixels);
    /**
    * - #### Purpose:
    * specify a two-dimensional texture subimage
    * ### Description:
    * Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.
    * 
    * **glTexSubImage2D** and **glTextureSubImage2D** redefine a contiguous subregion of an existing two-dimensional or one-dimensional array texture image. The texels referenced by **pixels** replace the portion of the existing texture array with x indices **xoffset** and xoffset + width - 1, inclusive, and y indices **yoffset** and yoffset + height - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **pixels** is treated as a byte offset into the buffer object's data store.
    * 
    * 
    * ### Notes:
    * **`glPixelStore`** modes affect texture images.
    * 
    * **glTexSubImage2D** and **glTextureSubImage3D** specify a two-dimensional subtexture for the current texture unit, specified with **`glActiveTexture`**.
    * 
    * `GL_STENCIL_INDEX` is accepted for **format** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** or the effective target of **texture** is not `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_1D_ARRAY`.
    * 
    * `GL_INVALID_OPERATION` is generated by **glTextureSubImage2D** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_ENUM` is generated if **format** is not an accepted format constant.
    * 
    * `GL_INVALID_ENUM` is generated if **type** is not a type constant.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` may be generated if **level** is greater than log 2 max, where max is the returned value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if xoffset &lt; - b, (w - b): --> xoffset + width &gt; w - b, yoffset &lt; - b, or (h - b): --> yoffset + height &gt; h - b, where w is the `GL_TEXTURE_WIDTH`, h is the `GL_TEXTURE_HEIGHT`, and b is the border width of the texture image being modified. Note that w and h include twice the border width.
    * 
    * `GL_INVALID_VALUE` is generated if **width** or **height** is less than 0.
    * 
    * `GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous **`glTexImage2D`** operation.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and **format** is not `GL_RGB`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and **format** is neither `GL_RGBA` nor `GL_BGRA`.
    * 
    * `GL_INVALID_OPERATION` is generated if **format** is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX`.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and **pixels** is not evenly divisible into the number of bytes needed to store in memory a datum indicated by **type**.
    * 
    * @param target Specifies the target to which the texture is bound for **glTexSubImage2D**. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_1D_ARRAY`.
    * @param texture Specifies the texture object name for **glTextureSubImage2D**. The effective target of **texture** must be one of the valid **target** values above.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param xoffset Specifies a texel offset in the x direction within the texture array.
    * @param yoffset Specifies a texel offset in the y direction within the texture array.
    * @param width Specifies the width of the texture subimage.
    * @param height Specifies the height of the texture subimage.
    * @param format Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`.
    * @param type Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.
    * @param pixels Specifies a pointer to the image data in memory.

    * @see **`glActiveTexture`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage3D`**, **`glTexParameter`**

    **/
    static function texSubImage2D(target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
    static function texSubImage2DEXT(target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);
    /**
    * - #### Purpose:
    * specify a three-dimensional texture subimage
    * ### Description:
    * Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.
    * 
    * **glTexSubImage3D** and **glTextureSubImage3D** redefine a contiguous subregion of an existing three-dimensional or two-dimensioanl array texture image. The texels referenced by **pixels** replace the portion of the existing texture array with x indices **xoffset** and xoffset + width - 1, inclusive, y indices **yoffset** and yoffset + height - 1, inclusive, and z indices **zoffset** and zoffset + depth - 1, inclusive. For three-dimensional textures, the z index refers to the third dimension. For two-dimensional array textures, the z index refers to the slice index. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width, height, or depth but such a specification has no effect.
    * 
    * If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see **`glBindBuffer`**) while a texture image is specified, **pixels** is treated as a byte offset into the buffer object's data store.
    * 
    * 
    * ### Notes:
    * The **`glPixelStore`** modes affect texture images.
    * 
    * **glTexSubImage3D** and **glTextureSubImage3D** specify a three-dimensional or two-dimensional array subtexture for the current texture unit, specified with **`glActiveTexture`**.
    * 
    * `GL_STENCIL_INDEX` is accepted for **format** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated if **target** or the effective target of **texture** is not `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.
    * 
    * `GL_INVALID_OPERATION` is generated by **glTextureSubImage3D** if **texture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_ENUM` is generated if **format** is not an accepted format constant.
    * 
    * `GL_INVALID_ENUM` is generated if **type** is not a type constant.
    * 
    * `GL_INVALID_VALUE` is generated if **level** is less than 0.
    * 
    * `GL_INVALID_VALUE` may be generated if **level** is greater than log 2 max, where max is the returned value of `GL_MAX_TEXTURE_SIZE`.
    * 
    * `GL_INVALID_VALUE` is generated if xoffset &lt; - b, (w - b): --> xoffset + width &gt; w - b, yoffset &lt; - b, or (h - b): --> yoffset + height &gt; h - b, or zoffset &lt; - b, or (d - b): --> zoffset + depth &gt; d - b, where w is the `GL_TEXTURE_WIDTH`, h is the `GL_TEXTURE_HEIGHT`, d is the `GL_TEXTURE_DEPTH` and b is the border width of the texture image being modified. Note that w, h, and d include twice the border width.
    * 
    * `GL_INVALID_VALUE` is generated if **width**, **height**, or **depth** is less than 0.
    * 
    * `GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous **`glTexImage3D`** or **`glTexStorage3D`** operation.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and **format** is not `GL_RGB`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and **format** is neither `GL_RGBA` nor `GL_BGRA`.
    * 
    * `GL_INVALID_OPERATION` is generated if **format** is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX`.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
    * 
    * `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and **pixels** is not evenly divisible into the number of bytes needed to store in memory a datum indicated by **type**.
    * 
    * @param target Specifies the target to which the texture is bound for **glTexSubImage3D**. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`.
    * @param texture Specifies the texture object name for **glTextureSubImage3D**. The effective target of **texture** must be one of the valid **target** values above.
    * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
    * @param xoffset Specifies a texel offset in the x direction within the texture array.
    * @param yoffset Specifies a texel offset in the y direction within the texture array.
    * @param zoffset Specifies a texel offset in the z direction within the texture array.
    * @param width Specifies the width of the texture subimage.
    * @param height Specifies the height of the texture subimage.
    * @param depth Specifies the depth of the texture subimage.
    * @param format Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`.
    * @param type Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.
    * @param pixels Specifies a pointer to the image data in memory.

    * @see **`glActiveTexture`**, **`glCopyTexImage1D`**, **`glCopyTexImage2D`**, **`glCopyTexSubImage1D`**, **`glCopyTexSubImage2D`**, **`glCopyTexSubImage3D`**, **`glPixelStore`**, **`glTexImage1D`**, **`glTexImage2D`**, **`glTexImage3D`**, **`glTexSubImage1D`**, **`glTexSubImage2D`**, **`glTexParameter`**

    **/
    static function texSubImage3D(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    static function texSubImage3DEXT(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    static function texSubImage3DOES(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    static function texSubImage4DSGIS(target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, woffset:Int, width:Int, height:Int, depth:Int, size4d:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.texSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
    static function textureAttachMemoryNV(texture:Int, memory:Int, offset:Int):Void return ExtensionsNative.textureAttachMemoryNV(texture, memory, offset);
    /**
    * - #### Purpose:
    * controls the ordering of reads and writes to rendered fragments across drawing commands
    * ### Description:
    * The values of rendered fragments are undefined when a shader stage fetches texels and the same texels are written via fragment shader outputs, even if the reads and writes are not in the same drawing command. To safely read the result of a written texel via a texel fetch in a subsequent drawing command, call **glTextureBarrier** between the two drawing commands to guarantee that writes have completed and caches have been invalidated before subsequent drawing commands are executed.
    * 
    * 
    * ### Notes:
    * The situation described above is referred to as a rendering feedback loop and is discussed in more detail in section 9.3 of the OpenGL 4.5 Specification.
    * 
    * 
    * ### Errors:
    * None.
    * 
    * * @see **`glMemoryBarrier`**

    **/
    static function textureBarrier():Void return ExtensionsNative.textureBarrier();
    static function textureBarrierNV():Void return ExtensionsNative.textureBarrierNV();
    static function textureBuffer(texture:Int, in_ternalformat:Int, buffer:Int):Void return ExtensionsNative.textureBuffer(texture, in_ternalformat, buffer);
    static function textureBufferEXT(texture:Int, target:Int, in_ternalformat:Int, buffer:Int):Void return ExtensionsNative.textureBufferEXT(texture, target, in_ternalformat, buffer);
    static function textureBufferRange(texture:Int, in_ternalformat:Int, buffer:Int, offset:Int, size:Int):Void return ExtensionsNative.textureBufferRange(texture, in_ternalformat, buffer, offset, size);
    static function textureBufferRangeEXT(texture:Int, target:Int, in_ternalformat:Int, buffer:Int, offset:Int, size:Int):Void return ExtensionsNative.textureBufferRangeEXT(texture, target, in_ternalformat, buffer, offset, size);
    static function textureColorMaskSGIS(red:Bool, green:Bool, blue:Bool, alpha:Bool):Void return ExtensionsNative.textureColorMaskSGIS(red, green, blue, alpha);
    static function textureFoveationParametersQCOM(texture:Int, layer:Int, focalPoin_t:Int, focalX:Float, focalY:Float, gain_X:Float, gain_Y:Float, foveaArea:Float):Void return ExtensionsNative.textureFoveationParametersQCOM(texture, layer, focalPoin_t, focalX, focalY, gain_X, gain_Y, foveaArea);
    static function textureImage1DEXT(texture:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.textureImage1DEXT(texture, target, level, in_ternalformat, width, border, format, type, pixels);
    static function textureImage2DEXT(texture:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.textureImage2DEXT(texture, target, level, in_ternalformat, width, height, border, format, type, pixels);
    static function textureImage2DMultisampleCoverageNV(texture:Int, target:Int, coverageSamples:Int, colorSamples:Int, in_ternalFormat:Int, width:Int, height:Int, fixedSampleLocations:Bool):Void return ExtensionsNative.textureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, in_ternalFormat, width, height, fixedSampleLocations);
    static function textureImage2DMultisampleNV(texture:Int, target:Int, samples:Int, in_ternalFormat:Int, width:Int, height:Int, fixedSampleLocations:Bool):Void return ExtensionsNative.textureImage2DMultisampleNV(texture, target, samples, in_ternalFormat, width, height, fixedSampleLocations);
    static function textureImage3DEXT(texture:Int, target:Int, level:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, border:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.textureImage3DEXT(texture, target, level, in_ternalformat, width, height, depth, border, format, type, pixels);
    static function textureImage3DMultisampleCoverageNV(texture:Int, target:Int, coverageSamples:Int, colorSamples:Int, in_ternalFormat:Int, width:Int, height:Int, depth:Int, fixedSampleLocations:Bool):Void return ExtensionsNative.textureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, in_ternalFormat, width, height, depth, fixedSampleLocations);
    static function textureImage3DMultisampleNV(texture:Int, target:Int, samples:Int, in_ternalFormat:Int, width:Int, height:Int, depth:Int, fixedSampleLocations:Bool):Void return ExtensionsNative.textureImage3DMultisampleNV(texture, target, samples, in_ternalFormat, width, height, depth, fixedSampleLocations);
    static function textureLightEXT(pname:Int):Void return ExtensionsNative.textureLightEXT(pname);
    static function textureMaterialEXT(face:Int, mode:Int):Void return ExtensionsNative.textureMaterialEXT(face, mode);
    static function textureNormalEXT(mode:Int):Void return ExtensionsNative.textureNormalEXT(mode);
    static function texturePageCommitmentEXT(texture:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, commit:Bool):Void return ExtensionsNative.texturePageCommitmentEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    static function texturePageCommitmentMemNV(texture:Int, layer:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, memory:Int, offset:Int, commit:Bool):Void return ExtensionsNative.texturePageCommitmentMemNV(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
    static function textureParameterIiv(texture:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.textureParameterIiv(texture, pname, params);
    static function textureParameterIivEXT(texture:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.textureParameterIivEXT(texture, target, pname, params);
    static function textureParameterIuiv(texture:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.textureParameterIuiv(texture, pname, params);
    static function textureParameterIuivEXT(texture:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.textureParameterIuivEXT(texture, target, pname, params);
    static function textureParameterf(texture:Int, pname:Int, param:Float):Void return ExtensionsNative.textureParameterf(texture, pname, param);
    static function textureParameterfEXT(texture:Int, target:Int, pname:Int, param:Float):Void return ExtensionsNative.textureParameterfEXT(texture, target, pname, param);
    static function textureParameterfv(texture:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.textureParameterfv(texture, pname, param);
    static function textureParameterfvEXT(texture:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.textureParameterfvEXT(texture, target, pname, params);
    static function textureParameteri(texture:Int, pname:Int, param:Int):Void return ExtensionsNative.textureParameteri(texture, pname, param);
    static function textureParameteriEXT(texture:Int, target:Int, pname:Int, param:Int):Void return ExtensionsNative.textureParameteriEXT(texture, target, pname, param);
    static function textureParameteriv(texture:Int, pname:Int, param:DataPointer):Void return ExtensionsNative.textureParameteriv(texture, pname, param);
    static function textureParameterivEXT(texture:Int, target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.textureParameterivEXT(texture, target, pname, params);
    static function textureRangeAPPLE(target:Int, length:Int, poin_ter:DataPointer):Void return ExtensionsNative.textureRangeAPPLE(target, length, poin_ter);
    static function textureRenderbufferEXT(texture:Int, target:Int, renderbuffer:Int):Void return ExtensionsNative.textureRenderbufferEXT(texture, target, renderbuffer);
    static function textureStorage1D(texture:Int, levels:Int, in_ternalformat:Int, width:Int):Void return ExtensionsNative.textureStorage1D(texture, levels, in_ternalformat, width);
    static function textureStorage1DEXT(texture:Int, target:Int, levels:Int, in_ternalformat:Int, width:Int):Void return ExtensionsNative.textureStorage1DEXT(texture, target, levels, in_ternalformat, width);
    static function textureStorage2D(texture:Int, levels:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.textureStorage2D(texture, levels, in_ternalformat, width, height);
    static function textureStorage2DEXT(texture:Int, target:Int, levels:Int, in_ternalformat:Int, width:Int, height:Int):Void return ExtensionsNative.textureStorage2DEXT(texture, target, levels, in_ternalformat, width, height);
    static function textureStorage2DMultisample(texture:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int, fixedsamplelocations:Bool):Void return ExtensionsNative.textureStorage2DMultisample(texture, samples, in_ternalformat, width, height, fixedsamplelocations);
    static function textureStorage2DMultisampleEXT(texture:Int, target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int, fixedsamplelocations:Bool):Void return ExtensionsNative.textureStorage2DMultisampleEXT(texture, target, samples, in_ternalformat, width, height, fixedsamplelocations);
    static function textureStorage3D(texture:Int, levels:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int):Void return ExtensionsNative.textureStorage3D(texture, levels, in_ternalformat, width, height, depth);
    static function textureStorage3DEXT(texture:Int, target:Int, levels:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int):Void return ExtensionsNative.textureStorage3DEXT(texture, target, levels, in_ternalformat, width, height, depth);
    static function textureStorage3DMultisample(texture:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, fixedsamplelocations:Bool):Void return ExtensionsNative.textureStorage3DMultisample(texture, samples, in_ternalformat, width, height, depth, fixedsamplelocations);
    static function textureStorage3DMultisampleEXT(texture:Int, target:Int, samples:Int, in_ternalformat:Int, width:Int, height:Int, depth:Int, fixedsamplelocations:Bool):Void return ExtensionsNative.textureStorage3DMultisampleEXT(texture, target, samples, in_ternalformat, width, height, depth, fixedsamplelocations);
    static function textureStorageMem1DEXT(texture:Int, levels:Int, in_ternalFormat:Int, width:Int, memory:Int, offset:Int):Void return ExtensionsNative.textureStorageMem1DEXT(texture, levels, in_ternalFormat, width, memory, offset);
    static function textureStorageMem2DEXT(texture:Int, levels:Int, in_ternalFormat:Int, width:Int, height:Int, memory:Int, offset:Int):Void return ExtensionsNative.textureStorageMem2DEXT(texture, levels, in_ternalFormat, width, height, memory, offset);
    static function textureStorageMem2DMultisampleEXT(texture:Int, samples:Int, in_ternalFormat:Int, width:Int, height:Int, fixedSampleLocations:Bool, memory:Int, offset:Int):Void return ExtensionsNative.textureStorageMem2DMultisampleEXT(texture, samples, in_ternalFormat, width, height, fixedSampleLocations, memory, offset);
    static function textureStorageMem3DEXT(texture:Int, levels:Int, in_ternalFormat:Int, width:Int, height:Int, depth:Int, memory:Int, offset:Int):Void return ExtensionsNative.textureStorageMem3DEXT(texture, levels, in_ternalFormat, width, height, depth, memory, offset);
    static function textureStorageMem3DMultisampleEXT(texture:Int, samples:Int, in_ternalFormat:Int, width:Int, height:Int, depth:Int, fixedSampleLocations:Bool, memory:Int, offset:Int):Void return ExtensionsNative.textureStorageMem3DMultisampleEXT(texture, samples, in_ternalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    static function textureStorageSparseAMD(texture:Int, target:Int, in_ternalFormat:Int, width:Int, height:Int, depth:Int, layers:Int, flags:Int):Void return ExtensionsNative.textureStorageSparseAMD(texture, target, in_ternalFormat, width, height, depth, layers, flags);
    static function textureSubImage1D(texture:Int, level:Int, xoffset:Int, width:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.textureSubImage1D(texture, level, xoffset, width, format, type, pixels);
    static function textureSubImage1DEXT(texture:Int, target:Int, level:Int, xoffset:Int, width:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.textureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels);
    static function textureSubImage2D(texture:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.textureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels);
    static function textureSubImage2DEXT(texture:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.textureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
    static function textureSubImage3D(texture:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.textureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    static function textureSubImage3DEXT(texture:Int, target:Int, level:Int, xoffset:Int, yoffset:Int, zoffset:Int, width:Int, height:Int, depth:Int, format:Int, type:Int, pixels:DataPointer):Void return ExtensionsNative.textureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    /**
    * - #### Purpose:
    * initialize a texture as a data alias of another texture's data store
    * ### Description:
    * **glTextureView** initializes a texture object as an alias, or view of another texture object, sharing some or all of the parent texture's data store with the initialized texture. **texture** specifies a name previously reserved by a successful call to **`glGenTextures`** but that has not yet been bound or given a target. **target** specifies the target for the newly initialized texture and must be compatible with the target of the parent texture, given in **origtexture** as specified in the following table:
    * 
    * The value of `GL_TEXTURE_IMMUTABLE_FORMAT` for **origtexture** must be `GL_TRUE`. After initialization, **texture** inherits the data store of the parent texture, **origtexture** and is usable as a normal texture object with target **target**. Data in the shared store is reinterpreted with the new internal format specified by **internalformat**. **internalformat** must be compatible with the internal format of the parent texture as specified in the following table:
    * 
    * If the original texture is an array or has multiple mipmap levels, the parameters **minlayer**, **numlayers**, **minlevel**, and **numlevels** control which of those slices and levels are considered part of the texture. The **minlevel** and **minlayer** parameters are relative to the view of the original texture. If **numlayers** or **numlevels** extend beyond the original texture, they are clamped to the max extent of the original texture.
    * 
    * If the new texture's target is `GL_TEXTURE_CUBE_MAP`, the clamped **numlayers** must be equal to 6. If the new texture's target is `GL_TEXTURE_CUBE_MAP_ARRAY`, then **numlayers** counts layer-faces rather than layers, and the clamped **numlayers** must be a multiple of 6. If the new texture's target is `GL_TEXTURE_CUBE_MAP` or `GL_TEXTURE_CUBE_MAP_ARRAY`, the width and height of the original texture's levels must be equal.
    * 
    * When the original texture's target is `GL_TEXTURE_CUBE_MAP`, the layer parameters are interpreted in the same order as if it were a `GL_TEXTURE_CUBE_MAP_ARRAY` with 6 layer-faces.
    * 
    * If **target** is `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_RECTANGLE`, or `GL_TEXTURE_2D_MULTISAMPLE`, **numlayers** must equal 1.
    * 
    * The dimensions of the original texture must be less than or equal to the maximum supported dimensions of the new target. For example, if the original texture has a `GL_TEXTURE_2D_ARRAY` target and its width is greater than `GL_MAX_CUBE_MAP_TEXTURE_SIZE`, an error will be generated if **glTextureView** is called to create a `GL_TEXTURE_CUBE_MAP` view.
    * 
    * Texture commands that take a **level** or **layer** parameter, such as **`glTexSubImage2D`**, interpret that parameter to be relative to the view of the texture. i.e. the mipmap level of the data store that would be updated via **`glTexSubImage2D`** would be the sum of **level** and the value of `GL_TEXTURE_VIEW_MIN_LEVEL`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **minlayer** or **minlevel** are larger than the greatest layer or level of **origtexture**.
    * 
    * `GL_INVALID_OPERATION` is generated if **target** is not compatible with the target of **origtexture**.
    * 
    * `GL_INVALID_OPERATION` is generated if the dimensions of **origtexture** are greater than the maximum supported dimensions for **target**.
    * 
    * `GL_INVALID_OPERATION` is generated if **internalformat** is not compatible with the internal format of **origtexture**.
    * 
    * `GL_INVALID_OPERATION` is generated if **texture** has already been bound or otherwise given a target.
    * 
    * `GL_INVALID_OPERATION` is generated if the value of `GL_TEXTURE_IMMUTABLE_FORMAT` for **origtexture** is not `GL_TRUE`.
    * 
    * `GL_INVALID_OPERATION` is generated if **origtexture** is not the name of an existing texture object.
    * 
    * `GL_INVALID_VALUE` is generaged if **target** is `GL_TEXTURE_CUBE_MAP` and **numlayers** is not 6, or if **target** is `GL_TEXTURE_CUBE_MAP_ARRAY` and **numlayers** is not an integer multiple of 6.
    * 
    * `GL_INVALID_VALUE` is generated if **target** is `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_RECTANGLE`, or `GL_TEXTURE_2D_MULTISAMPLE` and **numlayers** does not equal 1.
    * 
    * `GL_INVALID_VALUE` is generated if **texture** zero or is not the name of a texture previously returned from a successful call to **`glGenTextures`**.
    * 
    * @param texture Specifies the texture object to be initialized as a view.
    * @param target Specifies the target to be used for the newly initialized texture.
    * @param origtexture Specifies the name of a texture object of which to make a view.
    * @param internalformat Specifies the internal format for the newly created view.
    * @param minlevel Specifies lowest level of detail of the view.
    * @param numlevels Specifies the number of levels of detail to include in the view.
    * @param minlayer Specifies the index of the first layer to include in the view.
    * @param numlayers Specifies the number of layers to include in the view.

    * @see **`glTexStorage1D`**, **`glTexStorage2D`**, **`glTexStorage3D`**, **`glGetTexParameter`**.

    **/
    static function textureView(texture:Int, target:Int, origtexture:Int, in_ternalformat:Int, min_level:Int, numlevels:Int, min_layer:Int, numlayers:Int):Void return ExtensionsNative.textureView(texture, target, origtexture, in_ternalformat, min_level, numlevels, min_layer, numlayers);
    static function textureViewEXT(texture:Int, target:Int, origtexture:Int, in_ternalformat:Int, min_level:Int, numlevels:Int, min_layer:Int, numlayers:Int):Void return ExtensionsNative.textureViewEXT(texture, target, origtexture, in_ternalformat, min_level, numlevels, min_layer, numlayers);
    static function textureViewOES(texture:Int, target:Int, origtexture:Int, in_ternalformat:Int, min_level:Int, numlevels:Int, min_layer:Int, numlayers:Int):Void return ExtensionsNative.textureViewOES(texture, target, origtexture, in_ternalformat, min_level, numlevels, min_layer, numlayers);
    static function trackMatrixNV(target:Int, address:Int, matrix:Int, transform:Int):Void return ExtensionsNative.trackMatrixNV(target, address, matrix, transform);
    static function transformFeedbackAttribsNV(count:Int, attribs:DataPointer, bufferMode:Int):Void return ExtensionsNative.transformFeedbackAttribsNV(count, attribs, bufferMode);
    /**
    * - #### Purpose:
    * bind a buffer object to a transform feedback buffer object
    * ### Description:
    * **glTransformFeedbackBufferBase** binds the buffer object **buffer** to the binding point at index **index** of the transform feedback object **xfb**.
    * 
    * 
    * ### Notes:
    * Calling **glTransformFeedbackBufferBase** is equivalent to calling **`glTransformFeedbackBufferRange`** with **offset** zero and **size** equal to the size of **buffer**.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **xfb** is not the name of an existing transform feedback object.
    * 
    * `GL_INVALID_VALUE` is generated if in **buffer** is not zero or the name of an existing buffer object.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the number of transform feedback buffer binding points (the value of `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`).
    * 
    * @param xfb Name of the transform feedback buffer object.
    * @param index Index of the binding point within **xfb**.
    * @param buffer Name of the buffer object to bind to the specified binding point.

    * @see **`glBindBufferRange`**, **`glBindBufferBase`**, **`glTransformFeedbackBufferRange`**.

    **/
    static function transformFeedbackBufferBase(xfb:Int, in_dex:Int, buffer:Int):Void return ExtensionsNative.transformFeedbackBufferBase(xfb, in_dex, buffer);
    /**
    * - #### Purpose:
    * bind a range within a buffer object to a transform feedback buffer object
    * ### Description:
    * **glTransformFeedbackBufferRange** binds a range of the buffer object **buffer** represented by **offset** and **size** to the binding point at index **index** of the transform feedback object **xfb**.
    * 
    * **offset** specifies the offset in basic machine units into the buffer object **buffer** and **size** specifies the amount of data that can be read from the buffer object while used as an indexed target.
    * 
    * 
    * ### Notes:
    * 
    * 
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **xfb** is not the name of an existing transform feedback object.
    * 
    * `GL_INVALID_VALUE` is generated if in **buffer** is not zero or the name of an existing buffer object.
    * 
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the number of transform feedback buffer binding points (the value of `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`).
    * 
    * `GL_INVALID_VALUE` is generated if **offset** is negative.
    * 
    * `GL_INVALID_VALUE` is generated if **buffer** is non-zero and either **size** is less than or equal to zero, or **offset** + **size** is greater than the value of `GL_BUFFER_SIZE` for **buffer**.
    * 
    * @param xfb Name of the transform feedback buffer object.
    * @param index Index of the binding point within **xfb**.
    * @param buffer Name of the buffer object to bind to the specified binding point.
    * @param offset The starting offset in basic machine units into the buffer object.
    * @param size The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target.

    * @see **`glBindBufferRange`**, **`glBindBufferBase`**, **`glTransformFeedbackBufferBase`**.

    **/
    static function transformFeedbackBufferRange(xfb:Int, in_dex:Int, buffer:Int, offset:Int, size:Int):Void return ExtensionsNative.transformFeedbackBufferRange(xfb, in_dex, buffer, offset, size);
    static function transformFeedbackStreamAttribsNV(count:Int, attribs:DataPointer, nbuffers:Int, bufstreams:DataPointer, bufferMode:Int):Void return ExtensionsNative.transformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams, bufferMode);
    /**
    * - #### Purpose:
    * specify values to record in transform feedback buffers
    * ### Description:
    * The names of the vertex or geometry shader outputs to be recorded in transform feedback mode are specified using **glTransformFeedbackVaryings**. When a geometry shader is active, transform feedback records the values of selected geometry shader output variables from the emitted vertices. Otherwise, the values of the selected vertex shader outputs are recorded.
    * 
    * The state set by **glTranformFeedbackVaryings** is stored and takes effect next time **`glLinkProgram`** is called on **program**. When **`glLinkProgram`** is called, **program** is linked so that the values of the specified varying variables for the vertices of each primitive generated by the GL are written to a single buffer object if **bufferMode** is `GL_INTERLEAVED_ATTRIBS` or multiple buffer objects if **bufferMode** is `GL_SEPARATE_ATTRIBS`.
    * 
    * **glTransformFeedbackVaryings** can also special identifiers if **bufferMode** is `GL_INTERLEAVED_ATTRIBS`:
    * 
    * In addition to the errors generated by **glTransformFeedbackVaryings**, the program **program** will fail to link if: The count specified by **glTransformFeedbackVaryings** is non-zero, but the program object has no vertex or geometry shader. Any variable name specified in the **varyings** array is not declared as an output in the vertex shader (or the geometry shader, if active), or is not one of the special identifiers listed above. Special identifiers appear in a **varyings** array where **bufferMode** is not `GL_INTERLEAVED_ATTRIBS`. Any two entries in the **varyings** array, which are not one of the special varyings above, specify the same varying variable. Discounting any special identifiers, the total number of components to capture in any varying variable in **varyings** is greater than the constant `GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS` and the buffer mode is `GL_SEPARATE_ATTRIBS`. The total number of components to capture is greater than the constant `GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS` and the buffer mode is `GL_INTERLEAVED_ATTRIBS`.
    * 
    * 
    * ### Notes:
    * **glGetTransformFeedbackVarying** is available only if the GL version is 3.0 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not the name of a program object.
    * 
    * `GL_INVALID_VALUE` is generated if **bufferMode** is `GL_SEPARATE_ATTRIBS` and **count** is greater than the implementation-dependent limit `GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS`.
    * 
    * @param program The name of the target program object.
    * @param count The number of varying variables used for transform feedback.
    * @param varyings An array of **count** zero-terminated strings specifying the names of the varying variables to use for transform feedback.
    * @param bufferMode Identifies the mode used to capture the varying variables when transform feedback is active. **bufferMode** must be `GL_INTERLEAVED_ATTRIBS` or `GL_SEPARATE_ATTRIBS`.

    * @see **`glBeginTransformFeedback`**, **glEndTransformFeedback**, **`glGetTransformFeedbackVarying`**

    **/
    static function transformFeedbackVaryings(program:Int, count:Int, varyin_gs:String, bufferMode:Int):Void return ExtensionsNative.transformFeedbackVaryings(program, count, varyin_gs, bufferMode);
    static function transformFeedbackVaryingsEXT(program:Int, count:Int, varyin_gs:String, bufferMode:Int):Void return ExtensionsNative.transformFeedbackVaryingsEXT(program, count, varyin_gs, bufferMode);
    static function transformFeedbackVaryingsNV(program:Int, count:Int, locations:DataPointer, bufferMode:Int):Void return ExtensionsNative.transformFeedbackVaryingsNV(program, count, locations, bufferMode);
    static function transformPathNV(resultPath:Int, srcPath:Int, transformType:Int, transformValues:DataPointer):Void return ExtensionsNative.transformPathNV(resultPath, srcPath, transformType, transformValues);
    static function translated(x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.translated(x, y, z);
    static function translatef(x:Float, y:Float, z:Float):Void return ExtensionsNative.translatef(x, y, z);
    static function translatex(x:Int, y:Int, z:Int):Void return ExtensionsNative.translatex(x, y, z);
    static function translatexOES(x:Int, y:Int, z:Int):Void return ExtensionsNative.translatexOES(x, y, z);
    static function uniform1d(location:Int, x:DataPointer):Void return ExtensionsNative.uniform1d(location, x);
    static function uniform1dv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform1dv(location, count, value);
    static function uniform1f(location:Int, v0:Float):Void return ExtensionsNative.uniform1f(location, v0);
    static function uniform1fARB(location:Int, v0:Float):Void return ExtensionsNative.uniform1fARB(location, v0);
    static function uniform1fv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform1fv(location, count, value);
    static function uniform1fvARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform1fvARB(location, count, value);
    static function uniform1i(location:Int, v0:Int):Void return ExtensionsNative.uniform1i(location, v0);
    static function uniform1i64ARB(location:Int, x:Int):Void return ExtensionsNative.uniform1i64ARB(location, x);
    static function uniform1i64NV(location:Int, x:Int):Void return ExtensionsNative.uniform1i64NV(location, x);
    static function uniform1i64vARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform1i64vARB(location, count, value);
    static function uniform1i64vNV(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform1i64vNV(location, count, value);
    static function uniform1iARB(location:Int, v0:Int):Void return ExtensionsNative.uniform1iARB(location, v0);
    static function uniform1iv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform1iv(location, count, value);
    static function uniform1ivARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform1ivARB(location, count, value);
    static function uniform1ui(location:Int, v0:Int):Void return ExtensionsNative.uniform1ui(location, v0);
    static function uniform1ui64ARB(location:Int, x:Int):Void return ExtensionsNative.uniform1ui64ARB(location, x);
    static function uniform1ui64NV(location:Int, x:Int):Void return ExtensionsNative.uniform1ui64NV(location, x);
    static function uniform1ui64vARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform1ui64vARB(location, count, value);
    static function uniform1ui64vNV(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform1ui64vNV(location, count, value);
    static function uniform1uiEXT(location:Int, v0:Int):Void return ExtensionsNative.uniform1uiEXT(location, v0);
    static function uniform1uiv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform1uiv(location, count, value);
    static function uniform1uivEXT(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform1uivEXT(location, count, value);
    static function uniform2d(location:Int, x:DataPointer, y:DataPointer):Void return ExtensionsNative.uniform2d(location, x, y);
    static function uniform2dv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform2dv(location, count, value);
    static function uniform2f(location:Int, v0:Float, v1:Float):Void return ExtensionsNative.uniform2f(location, v0, v1);
    static function uniform2fARB(location:Int, v0:Float, v1:Float):Void return ExtensionsNative.uniform2fARB(location, v0, v1);
    static function uniform2fv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform2fv(location, count, value);
    static function uniform2fvARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform2fvARB(location, count, value);
    static function uniform2i(location:Int, v0:Int, v1:Int):Void return ExtensionsNative.uniform2i(location, v0, v1);
    static function uniform2i64ARB(location:Int, x:Int, y:Int):Void return ExtensionsNative.uniform2i64ARB(location, x, y);
    static function uniform2i64NV(location:Int, x:Int, y:Int):Void return ExtensionsNative.uniform2i64NV(location, x, y);
    static function uniform2i64vARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform2i64vARB(location, count, value);
    static function uniform2i64vNV(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform2i64vNV(location, count, value);
    static function uniform2iARB(location:Int, v0:Int, v1:Int):Void return ExtensionsNative.uniform2iARB(location, v0, v1);
    static function uniform2iv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform2iv(location, count, value);
    static function uniform2ivARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform2ivARB(location, count, value);
    static function uniform2ui(location:Int, v0:Int, v1:Int):Void return ExtensionsNative.uniform2ui(location, v0, v1);
    static function uniform2ui64ARB(location:Int, x:Int, y:Int):Void return ExtensionsNative.uniform2ui64ARB(location, x, y);
    static function uniform2ui64NV(location:Int, x:Int, y:Int):Void return ExtensionsNative.uniform2ui64NV(location, x, y);
    static function uniform2ui64vARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform2ui64vARB(location, count, value);
    static function uniform2ui64vNV(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform2ui64vNV(location, count, value);
    static function uniform2uiEXT(location:Int, v0:Int, v1:Int):Void return ExtensionsNative.uniform2uiEXT(location, v0, v1);
    static function uniform2uiv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform2uiv(location, count, value);
    static function uniform2uivEXT(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform2uivEXT(location, count, value);
    static function uniform3d(location:Int, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.uniform3d(location, x, y, z);
    static function uniform3dv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform3dv(location, count, value);
    static function uniform3f(location:Int, v0:Float, v1:Float, v2:Float):Void return ExtensionsNative.uniform3f(location, v0, v1, v2);
    static function uniform3fARB(location:Int, v0:Float, v1:Float, v2:Float):Void return ExtensionsNative.uniform3fARB(location, v0, v1, v2);
    static function uniform3fv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform3fv(location, count, value);
    static function uniform3fvARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform3fvARB(location, count, value);
    static function uniform3i(location:Int, v0:Int, v1:Int, v2:Int):Void return ExtensionsNative.uniform3i(location, v0, v1, v2);
    static function uniform3i64ARB(location:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.uniform3i64ARB(location, x, y, z);
    static function uniform3i64NV(location:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.uniform3i64NV(location, x, y, z);
    static function uniform3i64vARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform3i64vARB(location, count, value);
    static function uniform3i64vNV(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform3i64vNV(location, count, value);
    static function uniform3iARB(location:Int, v0:Int, v1:Int, v2:Int):Void return ExtensionsNative.uniform3iARB(location, v0, v1, v2);
    static function uniform3iv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform3iv(location, count, value);
    static function uniform3ivARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform3ivARB(location, count, value);
    static function uniform3ui(location:Int, v0:Int, v1:Int, v2:Int):Void return ExtensionsNative.uniform3ui(location, v0, v1, v2);
    static function uniform3ui64ARB(location:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.uniform3ui64ARB(location, x, y, z);
    static function uniform3ui64NV(location:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.uniform3ui64NV(location, x, y, z);
    static function uniform3ui64vARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform3ui64vARB(location, count, value);
    static function uniform3ui64vNV(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform3ui64vNV(location, count, value);
    static function uniform3uiEXT(location:Int, v0:Int, v1:Int, v2:Int):Void return ExtensionsNative.uniform3uiEXT(location, v0, v1, v2);
    static function uniform3uiv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform3uiv(location, count, value);
    static function uniform3uivEXT(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform3uivEXT(location, count, value);
    static function uniform4d(location:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.uniform4d(location, x, y, z, w);
    static function uniform4dv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform4dv(location, count, value);
    static function uniform4f(location:Int, v0:Float, v1:Float, v2:Float, v3:Float):Void return ExtensionsNative.uniform4f(location, v0, v1, v2, v3);
    static function uniform4fARB(location:Int, v0:Float, v1:Float, v2:Float, v3:Float):Void return ExtensionsNative.uniform4fARB(location, v0, v1, v2, v3);
    static function uniform4fv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform4fv(location, count, value);
    static function uniform4fvARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform4fvARB(location, count, value);
    static function uniform4i(location:Int, v0:Int, v1:Int, v2:Int, v3:Int):Void return ExtensionsNative.uniform4i(location, v0, v1, v2, v3);
    static function uniform4i64ARB(location:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.uniform4i64ARB(location, x, y, z, w);
    static function uniform4i64NV(location:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.uniform4i64NV(location, x, y, z, w);
    static function uniform4i64vARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform4i64vARB(location, count, value);
    static function uniform4i64vNV(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform4i64vNV(location, count, value);
    static function uniform4iARB(location:Int, v0:Int, v1:Int, v2:Int, v3:Int):Void return ExtensionsNative.uniform4iARB(location, v0, v1, v2, v3);
    static function uniform4iv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform4iv(location, count, value);
    static function uniform4ivARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform4ivARB(location, count, value);
    static function uniform4ui(location:Int, v0:Int, v1:Int, v2:Int, v3:Int):Void return ExtensionsNative.uniform4ui(location, v0, v1, v2, v3);
    static function uniform4ui64ARB(location:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.uniform4ui64ARB(location, x, y, z, w);
    static function uniform4ui64NV(location:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.uniform4ui64NV(location, x, y, z, w);
    static function uniform4ui64vARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform4ui64vARB(location, count, value);
    static function uniform4ui64vNV(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform4ui64vNV(location, count, value);
    static function uniform4uiEXT(location:Int, v0:Int, v1:Int, v2:Int, v3:Int):Void return ExtensionsNative.uniform4uiEXT(location, v0, v1, v2, v3);
    static function uniform4uiv(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform4uiv(location, count, value);
    static function uniform4uivEXT(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniform4uivEXT(location, count, value);
    /**
    * - #### Purpose:
    * assign a binding point to an active uniform block
    * ### Description:
    * Binding points for active uniform blocks are assigned using **glUniformBlockBinding**. Each of a program's active uniform blocks has a corresponding uniform buffer binding point. **program** is the name of a program object for which the command **`glLinkProgram`** has been issued in the past.
    * 
    * If successful, **glUniformBlockBinding** specifies that **program** will use the data store of the buffer object bound to the binding point **uniformBlockBinding** to extract the values of the uniforms in the uniform block identified by **uniformBlockIndex**.
    * 
    * When a program object is linked or re-linked, the uniform buffer object binding point assigned to each of its active uniform blocks is reset to zero.
    * 
    * 
    * ### Notes:
    * **glUniformBlockBinding** is available only if the GL version is 3.1 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **uniformBlockIndex** is not an active uniform block index of **program**.
    * 
    * `GL_INVALID_VALUE` is generated if **uniformBlockBinding** is greater than or equal to the value of `GL_MAX_UNIFORM_BUFFER_BINDINGS`.
    * 
    * `GL_INVALID_VALUE` is generated if **program** is not the name of a program object generated by the GL.
    * 
    * @param program The name of a program object containing the active uniform block whose binding to assign.
    * @param uniformBlockIndex The index of the active uniform block within **program** whose binding to assign.
    * @param uniformBlockBinding Specifies the binding point to which to bind the uniform block with index **uniformBlockIndex** within **program**.

    * @see **`glLinkProgram`**, **`glBindBufferBase`**, **`glBindBufferRange`**, **`glGetActiveUniformBlock`**

    **/
    static function uniformBlockBinding(program:Int, uniformBlockIndex:Int, uniformBlockBin_din_g:Int):Void return ExtensionsNative.uniformBlockBinding(program, uniformBlockIndex, uniformBlockBin_din_g);
    static function uniformBufferEXT(program:Int, location:Int, buffer:Int):Void return ExtensionsNative.uniformBufferEXT(program, location, buffer);
    static function uniformHandleui64ARB(location:Int, value:Int):Void return ExtensionsNative.uniformHandleui64ARB(location, value);
    static function uniformHandleui64IMG(location:Int, value:Int):Void return ExtensionsNative.uniformHandleui64IMG(location, value);
    static function uniformHandleui64NV(location:Int, value:Int):Void return ExtensionsNative.uniformHandleui64NV(location, value);
    static function uniformHandleui64vARB(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniformHandleui64vARB(location, count, value);
    static function uniformHandleui64vIMG(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniformHandleui64vIMG(location, count, value);
    static function uniformHandleui64vNV(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniformHandleui64vNV(location, count, value);
    static function uniformMatrix2dv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix2dv(location, count, transpose, value);
    static function uniformMatrix2fv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix2fv(location, count, transpose, value);
    static function uniformMatrix2fvARB(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix2fvARB(location, count, transpose, value);
    static function uniformMatrix2x3dv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix2x3dv(location, count, transpose, value);
    static function uniformMatrix2x3fv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix2x3fv(location, count, transpose, value);
    static function uniformMatrix2x3fvNV(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix2x3fvNV(location, count, transpose, value);
    static function uniformMatrix2x4dv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix2x4dv(location, count, transpose, value);
    static function uniformMatrix2x4fv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix2x4fv(location, count, transpose, value);
    static function uniformMatrix2x4fvNV(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix2x4fvNV(location, count, transpose, value);
    static function uniformMatrix3dv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix3dv(location, count, transpose, value);
    static function uniformMatrix3fv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix3fv(location, count, transpose, value);
    static function uniformMatrix3fvARB(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix3fvARB(location, count, transpose, value);
    static function uniformMatrix3x2dv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix3x2dv(location, count, transpose, value);
    static function uniformMatrix3x2fv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix3x2fv(location, count, transpose, value);
    static function uniformMatrix3x2fvNV(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix3x2fvNV(location, count, transpose, value);
    static function uniformMatrix3x4dv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix3x4dv(location, count, transpose, value);
    static function uniformMatrix3x4fv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix3x4fv(location, count, transpose, value);
    static function uniformMatrix3x4fvNV(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix3x4fvNV(location, count, transpose, value);
    static function uniformMatrix4dv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix4dv(location, count, transpose, value);
    static function uniformMatrix4fv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix4fv(location, count, transpose, value);
    static function uniformMatrix4fvARB(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix4fvARB(location, count, transpose, value);
    static function uniformMatrix4x2dv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix4x2dv(location, count, transpose, value);
    static function uniformMatrix4x2fv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix4x2fv(location, count, transpose, value);
    static function uniformMatrix4x2fvNV(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix4x2fvNV(location, count, transpose, value);
    static function uniformMatrix4x3dv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix4x3dv(location, count, transpose, value);
    static function uniformMatrix4x3fv(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix4x3fv(location, count, transpose, value);
    static function uniformMatrix4x3fvNV(location:Int, count:Int, transpose:Bool, value:DataPointer):Void return ExtensionsNative.uniformMatrix4x3fvNV(location, count, transpose, value);
    static function uniformSubroutinesuiv(shadertype:Int, count:Int, in_dices:DataPointer):Void return ExtensionsNative.uniformSubroutinesuiv(shadertype, count, in_dices);
    static function uniformui64NV(location:Int, value:Int):Void return ExtensionsNative.uniformui64NV(location, value);
    static function uniformui64vNV(location:Int, count:Int, value:DataPointer):Void return ExtensionsNative.uniformui64vNV(location, count, value);
    static function unlockArraysEXT():Void return ExtensionsNative.unlockArraysEXT();
    /**
    * - #### Purpose:
    * release the mapping of a buffer object's data store into the client's address space
    * ### Description:
    * **glUnmapBuffer** and **glUnmapNamedBuffer** unmap (release) any mapping of a specified buffer object into the client's address space (see **`glMapBufferRange`** and **`glMapBuffer`**).
    * 
    * If a mapping is not unmapped before the corresponding buffer object's data store is used by the GL, an error will be generated by any GL command that attempts to dereference the buffer object's data store, unless the buffer was successfully mapped with `GL_MAP_PERSISTENT_BIT` (see **`glMapBufferRange`**). When a data store is unmapped, the mapped pointer becomes invalid.
    * 
    * **glUnmapBuffer** returns `GL_TRUE` unless the data store contents have become corrupt during the time the data store was mapped. This can occur for system-specific reasons that affect the availability of graphics memory, such as screen mode changes. In such situations, `GL_FALSE` is returned and the data store contents are undefined. An application must detect this rare condition and reinitialize the data store.
    * 
    * A buffer object's mapped data store is automatically unmapped when the buffer object is deleted or its data store is recreated with **`glBufferData`**).
    * 
    * 
    * ### Notes:
    * If an error is generated, **glUnmapBuffer** returns `GL_FALSE`.
    * 
    * The `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or greater.
    * 
    * The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.
    * 
    * The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_ENUM` is generated by **glUnmapBuffer** if **target** is not one of the buffer binding targets listed above.
    * 
    * `GL_INVALID_OPERATION` is generated by **glUnmapBuffer** if zero is bound to **target**.
    * 
    * `GL_INVALID_OPERATION` is generated by **glUnmapNamedBuffer** if **buffer** is not the name of an existing buffer object.
    * 
    * `GL_INVALID_OPERATION` is generated if the buffer object is not in a mapped state.
    * 
    * @param target Specifies the target to which the buffer object is bound for **glUnmapBuffer**, which must be one of the buffer binding targets in the following table:
    * @param buffer Specifies the name of the buffer object for **glUnmapNamedBuffer**.

    * @see **`glBufferData`**, **`glDeleteBuffers`**, **`glMapBuffer`**, **`glMapBufferRange`**

    **/
    static function unmapBuffer(target:Int):Bool return ExtensionsNative.unmapBuffer(target);
    static function unmapBufferARB(target:Int):Bool return ExtensionsNative.unmapBufferARB(target);
    static function unmapBufferOES(target:Int):Bool return ExtensionsNative.unmapBufferOES(target);
    static function unmapNamedBuffer(buffer:Int):Bool return ExtensionsNative.unmapNamedBuffer(buffer);
    static function unmapNamedBufferEXT(buffer:Int):Bool return ExtensionsNative.unmapNamedBufferEXT(buffer);
    static function unmapObjectBufferATI(buffer:Int):Void return ExtensionsNative.unmapObjectBufferATI(buffer);
    static function unmapTexture2DINTEL(texture:Int, level:Int):Void return ExtensionsNative.unmapTexture2DINTEL(texture, level);
    static function updateObjectBufferATI(buffer:Int, offset:Int, size:Int, poin_ter:DataPointer, preserve:Int):Void return ExtensionsNative.updateObjectBufferATI(buffer, offset, size, poin_ter, preserve);
    static function uploadGpuMaskNVX(mask:Int):Void return ExtensionsNative.uploadGpuMaskNVX(mask);
    /**
    * - #### Purpose:
    * Installs a program object as part of current rendering state
    * ### Description:
    * **glUseProgram** installs the program object specified by **program** as part of current rendering state. One or more executables are created in a program object by successfully attaching shader objects to it with **`glAttachShader`**, successfully compiling the shader objects with **`glCompileShader`**, and successfully linking the program object with **`glLinkProgram`**.
    * 
    * A program object will contain an executable that will run on the vertex processor if it contains one or more shader objects of type `GL_VERTEX_SHADER` that have been successfully compiled and linked. A program object will contain an executable that will run on the geometry processor if it contains one or more shader objects of type `GL_GEOMETRY_SHADER` that have been successfully compiled and linked. Similarly, a program object will contain an executable that will run on the fragment processor if it contains one or more shader objects of type `GL_FRAGMENT_SHADER` that have been successfully compiled and linked.
    * 
    * While a program object is in use, applications are free to modify attached shader objects, compile attached shader objects, attach additional shader objects, and detach or delete shader objects. None of these operations will affect the executables that are part of the current state. However, relinking the program object that is currently in use will install the program object as part of the current rendering state if the link operation was successful (see **`glLinkProgram`** ). If the program object currently in use is relinked unsuccessfully, its link status will be set to `GL_FALSE`, but the executables and associated state will remain part of the current state until a subsequent call to **glUseProgram** removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked.
    * 
    * If **program** is zero, then the current rendering state refers to an invalid program object and the results of shader execution are undefined. However, this is not an error.
    * 
    * If **program** does not contain shader objects of type `GL_FRAGMENT_SHADER`, an executable will be installed on the vertex, and possibly geometry processors, but the results of fragment shader execution will be undefined.
    * 
    * 
    * ### Notes:
    * Like buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.
    * 
    * Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is neither 0 nor a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** could not be made part of current state.
    * 
    * `GL_INVALID_OPERATION` is generated if transform feedback mode is active.
    * 
    * @param program Specifies the handle of the program object whose executables are to be used as part of current rendering state.

    * @see **`glAttachShader`**, **`glBindAttribLocation`**, **`glCompileShader`**, **`glCreateProgram`**, **`glDeleteProgram`**, **`glDetachShader`**, **`glLinkProgram`**, **`glUniform`**, **`glValidateProgram`**, **`glVertexAttrib`**

    **/
    static function useProgram(program:Int):Void return ExtensionsNative.useProgram(program);
    static function useProgramObjectARB(programObj:Int):Void return ExtensionsNative.useProgramObjectARB(programObj);
    /**
    * - #### Purpose:
    * bind stages of a program object to a program pipeline
    * ### Description:
    * **glUseProgramStages** binds executables from a program object associated with a specified set of shader stages to the program pipeline object given by **pipeline**. **pipeline** specifies the program pipeline object to which to bind the executables. **stages** contains a logical combination of bits indicating the shader stages to use within **program** with the program pipeline object **pipeline**. **stages** must be a logical combination of `GL_VERTEX_SHADER_BIT`, `GL_TESS_CONTROL_SHADER_BIT`, `GL_TESS_EVALUATION_SHADER_BIT`, `GL_GEOMETRY_SHADER_BIT`, `GL_FRAGMENT_SHADER_BIT` and `GL_COMPUTE_SHADER_BIT`. Additionally, the special value `GL_ALL_SHADER_BITS` may be specified to indicate that all executables contained in **program** should be installed in **pipeline**.
    * 
    * If **program** refers to a program object with a valid shader attached for an indicated shader stage, **glUseProgramStages** installs the executable code for that stage in the indicated program pipeline object **pipeline**. If **program** is zero, or refers to a program object with no valid shader executable for a given stage, it is as if the pipeline object has no programmable stage configured for the indicated shader stages. If **stages** contains bits other than those listed above, and is not equal to `GL_ALL_SHADER_BITS`, an error is generated.
    * 
    * 
    * ### Notes:
    * The `GL_COMPUTE_SHADER_BIT` bit is available only if the GL version is 4.3 or greater.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **shaders** contains set bits that are not recognized, and is not the reserved value `GL_ALL_SHADER_BITS`.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** refers to a program object that was not linked with its `GL_PROGRAM_SEPARABLE` status set.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** refers to a program object that has not been successfully linked.
    * 
    * `GL_INVALID_OPERATION` is generated if **pipeline** is not a name previously returned from a call to **`glGenProgramPipelines`** or if such a name has been deleted by a call to **`glDeleteProgramPipelines`**.
    * 
    * @param pipeline Specifies the program pipeline object to which to bind stages from **program**.
    * @param stages Specifies a set of program stages to bind to the program pipeline object.
    * @param program Specifies the program object containing the shader executables to use in **pipeline**.

    * @see **`glGenProgramPipelines`**, **`glDeleteProgramPipelines`**, **`glIsProgramPipeline`**

    **/
    static function useProgramStages(pipelin_e:Int, stages:Int, program:Int):Void return ExtensionsNative.useProgramStages(pipelin_e, stages, program);
    static function useProgramStagesEXT(pipelin_e:Int, stages:Int, program:Int):Void return ExtensionsNative.useProgramStagesEXT(pipelin_e, stages, program);
    static function useShaderProgramEXT(type:Int, program:Int):Void return ExtensionsNative.useShaderProgramEXT(type, program);
    static function vDPAUFiniNV():Void return ExtensionsNative.vDPAUFiniNV();
    static function vDPAUGetSurfaceivNV(surface:Int, pname:Int, count:Int, length:DataPointer, values:DataPointer):Void return ExtensionsNative.vDPAUGetSurfaceivNV(surface, pname, count, length, values);
    static function vDPAUInitNV(vdpDevice:DataPointer, getProcAddress:DataPointer):Void return ExtensionsNative.vDPAUInitNV(vdpDevice, getProcAddress);
    static function vDPAUIsSurfaceNV(surface:Int):Bool return ExtensionsNative.vDPAUIsSurfaceNV(surface);
    static function vDPAUMapSurfacesNV(numSurfaces:Int, surfaces:DataPointer):Void return ExtensionsNative.vDPAUMapSurfacesNV(numSurfaces, surfaces);
    static function vDPAURegisterOutputSurfaceNV(vdpSurface:DataPointer, target:Int, numTextureNames:Int, textureNames:DataPointer):Int return ExtensionsNative.vDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
    static function vDPAURegisterVideoSurfaceNV(vdpSurface:DataPointer, target:Int, numTextureNames:Int, textureNames:DataPointer):Int return ExtensionsNative.vDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
    static function vDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface:DataPointer, target:Int, numTextureNames:Int, textureNames:DataPointer, isFrameStructure:Bool):Int return ExtensionsNative.vDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
    static function vDPAUSurfaceAccessNV(surface:Int, access:Int):Void return ExtensionsNative.vDPAUSurfaceAccessNV(surface, access);
    static function vDPAUUnmapSurfacesNV(numSurface:Int, surfaces:DataPointer):Void return ExtensionsNative.vDPAUUnmapSurfacesNV(numSurface, surfaces);
    static function vDPAUUnregisterSurfaceNV(surface:Int):Void return ExtensionsNative.vDPAUUnregisterSurfaceNV(surface);
    /**
    * - #### Purpose:
    * Validates a program object
    * ### Description:
    * **glValidateProgram** checks to see whether the executables contained in **program** can execute given the current OpenGL state. The information generated by the validation process will be stored in **program**'s information log. The validation information may consist of an empty string, or it may be a string containing information about how the current program object interacts with the rest of current OpenGL state. This provides a way for OpenGL implementers to convey more information about why the current program is inefficient, suboptimal, failing to execute, and so on.
    * 
    * The status of the validation operation will be stored as part of the program object's state. This value will be set to `GL_TRUE` if the validation succeeded, and `GL_FALSE` otherwise. It can be queried by calling **`glGetProgram`** with arguments **program** and `GL_VALIDATE_STATUS`. If validation is successful, **program** is guaranteed to execute given the current state. Otherwise, **program** is guaranteed to not execute.
    * 
    * This function is typically useful only during application development. The informational string stored in the information log is completely implementation dependent; therefore, an application should not expect different OpenGL implementations to produce identical information strings.
    * 
    * 
    * ### Notes:
    * This function mimics the validation operation that OpenGL implementations must perform when rendering commands are issued while programmable shaders are part of current state. The error `GL_INVALID_OPERATION` will be generated by any command that triggers the rendering of geometry if:
    * 
    * It may be difficult or cause a performance degradation for applications to catch these errors when rendering commands are issued. Therefore, applications are advised to make calls to **glValidateProgram** to detect these issues during application development.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **program** is not a value generated by OpenGL.
    * 
    * `GL_INVALID_OPERATION` is generated if **program** is not a program object.
    * 
    * @param program Specifies the handle of the program object to be validated.

    * @see **`glLinkProgram`**, **`glUseProgram`**

    **/
    static function validateProgram(program:Int):Void return ExtensionsNative.validateProgram(program);
    static function validateProgramARB(programObj:Int):Void return ExtensionsNative.validateProgramARB(programObj);
    /**
    * - #### Purpose:
    * validate a program pipeline object against current GL state
    * ### Description:
    * **glValidateProgramPipeline** instructs the implementation to validate the shader executables contained in **pipeline** against the current GL state. The implementation may use this as an opportunity to perform any internal shader modifications that may be required to ensure correct operation of the installed shaders given the current GL state.
    * 
    * After a program pipeline has been validated, its validation status is set to `GL_TRUE`. The validation status of a program pipeline object may be queried by calling **`glGetProgramPipeline`** with parameter `GL_VALIDATE_STATUS`.
    * 
    * If **pipeline** is a name previously returned from a call to **`glGenProgramPipelines`** but that has not yet been bound by a call to **`glBindProgramPipeline`**, a new program pipeline object is created with name **pipeline** and the default state vector.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated if **pipeline** is not a name previously returned from a call to **`glGenProgramPipelines`** or if such a name has been deleted by a call to **`glDeleteProgramPipelines`**.
    * 
    * @param pipeline Specifies the name of a program pipeline object to validate.

    * @see **`glGenProgramPipelines`**, **`glBindProgramPipeline`**, **`glDeleteProgramPipelines`**

    **/
    static function validateProgramPipeline(pipelin_e:Int):Void return ExtensionsNative.validateProgramPipeline(pipelin_e);
    static function validateProgramPipelineEXT(pipelin_e:Int):Void return ExtensionsNative.validateProgramPipelineEXT(pipelin_e);
    static function variantArrayObjectATI(id:Int, type:Int, stride:Int, buffer:Int, offset:Int):Void return ExtensionsNative.variantArrayObjectATI(id, type, stride, buffer, offset);
    static function variantPointerEXT(id:Int, type:Int, stride:Int, addr:DataPointer):Void return ExtensionsNative.variantPointerEXT(id, type, stride, addr);
    static function variantbvEXT(id:Int, addr:DataPointer):Void return ExtensionsNative.variantbvEXT(id, addr);
    static function variantdvEXT(id:Int, addr:DataPointer):Void return ExtensionsNative.variantdvEXT(id, addr);
    static function variantfvEXT(id:Int, addr:DataPointer):Void return ExtensionsNative.variantfvEXT(id, addr);
    static function variantivEXT(id:Int, addr:DataPointer):Void return ExtensionsNative.variantivEXT(id, addr);
    static function variantsvEXT(id:Int, addr:DataPointer):Void return ExtensionsNative.variantsvEXT(id, addr);
    static function variantubvEXT(id:Int, addr:DataPointer):Void return ExtensionsNative.variantubvEXT(id, addr);
    static function variantuivEXT(id:Int, addr:DataPointer):Void return ExtensionsNative.variantuivEXT(id, addr);
    static function variantusvEXT(id:Int, addr:DataPointer):Void return ExtensionsNative.variantusvEXT(id, addr);
    static function vertex2bOES(x:Int, y:Int):Void return ExtensionsNative.vertex2bOES(x, y);
    static function vertex2bvOES(coords:DataPointer):Void return ExtensionsNative.vertex2bvOES(coords);
    static function vertex2d(x:DataPointer, y:DataPointer):Void return ExtensionsNative.vertex2d(x, y);
    static function vertex2dv(v:DataPointer):Void return ExtensionsNative.vertex2dv(v);
    static function vertex2f(x:Float, y:Float):Void return ExtensionsNative.vertex2f(x, y);
    static function vertex2fv(v:DataPointer):Void return ExtensionsNative.vertex2fv(v);
    static function vertex2hNV(x:Int, y:Int):Void return ExtensionsNative.vertex2hNV(x, y);
    static function vertex2hvNV(v:DataPointer):Void return ExtensionsNative.vertex2hvNV(v);
    static function vertex2i(x:Int, y:Int):Void return ExtensionsNative.vertex2i(x, y);
    static function vertex2iv(v:DataPointer):Void return ExtensionsNative.vertex2iv(v);
    static function vertex2s(x:Int, y:Int):Void return ExtensionsNative.vertex2s(x, y);
    static function vertex2sv(v:DataPointer):Void return ExtensionsNative.vertex2sv(v);
    static function vertex2xOES(x:Int):Void return ExtensionsNative.vertex2xOES(x);
    static function vertex2xvOES(coords:DataPointer):Void return ExtensionsNative.vertex2xvOES(coords);
    static function vertex3bOES(x:Int, y:Int, z:Int):Void return ExtensionsNative.vertex3bOES(x, y, z);
    static function vertex3bvOES(coords:DataPointer):Void return ExtensionsNative.vertex3bvOES(coords);
    static function vertex3d(x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.vertex3d(x, y, z);
    static function vertex3dv(v:DataPointer):Void return ExtensionsNative.vertex3dv(v);
    static function vertex3f(x:Float, y:Float, z:Float):Void return ExtensionsNative.vertex3f(x, y, z);
    static function vertex3fv(v:DataPointer):Void return ExtensionsNative.vertex3fv(v);
    static function vertex3hNV(x:Int, y:Int, z:Int):Void return ExtensionsNative.vertex3hNV(x, y, z);
    static function vertex3hvNV(v:DataPointer):Void return ExtensionsNative.vertex3hvNV(v);
    static function vertex3i(x:Int, y:Int, z:Int):Void return ExtensionsNative.vertex3i(x, y, z);
    static function vertex3iv(v:DataPointer):Void return ExtensionsNative.vertex3iv(v);
    static function vertex3s(x:Int, y:Int, z:Int):Void return ExtensionsNative.vertex3s(x, y, z);
    static function vertex3sv(v:DataPointer):Void return ExtensionsNative.vertex3sv(v);
    static function vertex3xOES(x:Int, y:Int):Void return ExtensionsNative.vertex3xOES(x, y);
    static function vertex3xvOES(coords:DataPointer):Void return ExtensionsNative.vertex3xvOES(coords);
    static function vertex4bOES(x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertex4bOES(x, y, z, w);
    static function vertex4bvOES(coords:DataPointer):Void return ExtensionsNative.vertex4bvOES(coords);
    static function vertex4d(x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.vertex4d(x, y, z, w);
    static function vertex4dv(v:DataPointer):Void return ExtensionsNative.vertex4dv(v);
    static function vertex4f(x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.vertex4f(x, y, z, w);
    static function vertex4fv(v:DataPointer):Void return ExtensionsNative.vertex4fv(v);
    static function vertex4hNV(x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertex4hNV(x, y, z, w);
    static function vertex4hvNV(v:DataPointer):Void return ExtensionsNative.vertex4hvNV(v);
    static function vertex4i(x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertex4i(x, y, z, w);
    static function vertex4iv(v:DataPointer):Void return ExtensionsNative.vertex4iv(v);
    static function vertex4s(x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertex4s(x, y, z, w);
    static function vertex4sv(v:DataPointer):Void return ExtensionsNative.vertex4sv(v);
    static function vertex4xOES(x:Int, y:Int, z:Int):Void return ExtensionsNative.vertex4xOES(x, y, z);
    static function vertex4xvOES(coords:DataPointer):Void return ExtensionsNative.vertex4xvOES(coords);
    static function vertexArrayAttribBinding(vaobj:Int, attribin_dex:Int, bin_din_gin_dex:Int):Void return ExtensionsNative.vertexArrayAttribBinding(vaobj, attribin_dex, bin_din_gin_dex);
    static function vertexArrayAttribFormat(vaobj:Int, attribin_dex:Int, size:Int, type:Int, normalized:Bool, relativeoffset:Int):Void return ExtensionsNative.vertexArrayAttribFormat(vaobj, attribin_dex, size, type, normalized, relativeoffset);
    static function vertexArrayAttribIFormat(vaobj:Int, attribin_dex:Int, size:Int, type:Int, relativeoffset:Int):Void return ExtensionsNative.vertexArrayAttribIFormat(vaobj, attribin_dex, size, type, relativeoffset);
    static function vertexArrayAttribLFormat(vaobj:Int, attribin_dex:Int, size:Int, type:Int, relativeoffset:Int):Void return ExtensionsNative.vertexArrayAttribLFormat(vaobj, attribin_dex, size, type, relativeoffset);
    static function vertexArrayBindVertexBufferEXT(vaobj:Int, bin_din_gin_dex:Int, buffer:Int, offset:Int, stride:Int):Void return ExtensionsNative.vertexArrayBindVertexBufferEXT(vaobj, bin_din_gin_dex, buffer, offset, stride);
    static function vertexArrayBindingDivisor(vaobj:Int, bin_din_gin_dex:Int, divisor:Int):Void return ExtensionsNative.vertexArrayBindingDivisor(vaobj, bin_din_gin_dex, divisor);
    static function vertexArrayColorOffsetEXT(vaobj:Int, buffer:Int, size:Int, type:Int, stride:Int, offset:Int):Void return ExtensionsNative.vertexArrayColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
    static function vertexArrayEdgeFlagOffsetEXT(vaobj:Int, buffer:Int, stride:Int, offset:Int):Void return ExtensionsNative.vertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
    /**
    * - #### Purpose:
    * configures element array buffer binding of a vertex array object
    * ### Description:
    * **glVertexArrayElementBuffer** binds a buffer object with id **buffer** to the element array buffer bind point of a vertex array object with id **vaobj**. If **buffer** is zero, any existing element array buffer binding to **vaobj** is removed.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` error is generated if **vaobj** is not the name of an existing vertex array object.
    * 
    * `GL_INVALID_OPERATION` error is generated if **buffer** is not zero or the name of an existing buffer object.
    * 
    * @param vaobj Specifies the name of the vertex array object.
    * @param buffer Specifies the name of the buffer object to use for the element array buffer binding.

    * @see **`glGet`**, **`glGetVertexArrayiv`**

    **/
    static function vertexArrayElementBuffer(vaobj:Int, buffer:Int):Void return ExtensionsNative.vertexArrayElementBuffer(vaobj, buffer);
    static function vertexArrayFogCoordOffsetEXT(vaobj:Int, buffer:Int, type:Int, stride:Int, offset:Int):Void return ExtensionsNative.vertexArrayFogCoordOffsetEXT(vaobj, buffer, type, stride, offset);
    static function vertexArrayIndexOffsetEXT(vaobj:Int, buffer:Int, type:Int, stride:Int, offset:Int):Void return ExtensionsNative.vertexArrayIndexOffsetEXT(vaobj, buffer, type, stride, offset);
    static function vertexArrayMultiTexCoordOffsetEXT(vaobj:Int, buffer:Int, texunit:Int, size:Int, type:Int, stride:Int, offset:Int):Void return ExtensionsNative.vertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, type, stride, offset);
    static function vertexArrayNormalOffsetEXT(vaobj:Int, buffer:Int, type:Int, stride:Int, offset:Int):Void return ExtensionsNative.vertexArrayNormalOffsetEXT(vaobj, buffer, type, stride, offset);
    static function vertexArrayParameteriAPPLE(pname:Int, param:Int):Void return ExtensionsNative.vertexArrayParameteriAPPLE(pname, param);
    static function vertexArrayRangeAPPLE(length:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexArrayRangeAPPLE(length, poin_ter);
    static function vertexArrayRangeNV(length:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexArrayRangeNV(length, poin_ter);
    static function vertexArraySecondaryColorOffsetEXT(vaobj:Int, buffer:Int, size:Int, type:Int, stride:Int, offset:Int):Void return ExtensionsNative.vertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
    static function vertexArrayTexCoordOffsetEXT(vaobj:Int, buffer:Int, size:Int, type:Int, stride:Int, offset:Int):Void return ExtensionsNative.vertexArrayTexCoordOffsetEXT(vaobj, buffer, size, type, stride, offset);
    static function vertexArrayVertexAttribBindingEXT(vaobj:Int, attribin_dex:Int, bin_din_gin_dex:Int):Void return ExtensionsNative.vertexArrayVertexAttribBindingEXT(vaobj, attribin_dex, bin_din_gin_dex);
    static function vertexArrayVertexAttribDivisorEXT(vaobj:Int, in_dex:Int, divisor:Int):Void return ExtensionsNative.vertexArrayVertexAttribDivisorEXT(vaobj, in_dex, divisor);
    static function vertexArrayVertexAttribFormatEXT(vaobj:Int, attribin_dex:Int, size:Int, type:Int, normalized:Bool, relativeoffset:Int):Void return ExtensionsNative.vertexArrayVertexAttribFormatEXT(vaobj, attribin_dex, size, type, normalized, relativeoffset);
    static function vertexArrayVertexAttribIFormatEXT(vaobj:Int, attribin_dex:Int, size:Int, type:Int, relativeoffset:Int):Void return ExtensionsNative.vertexArrayVertexAttribIFormatEXT(vaobj, attribin_dex, size, type, relativeoffset);
    static function vertexArrayVertexAttribIOffsetEXT(vaobj:Int, buffer:Int, in_dex:Int, size:Int, type:Int, stride:Int, offset:Int):Void return ExtensionsNative.vertexArrayVertexAttribIOffsetEXT(vaobj, buffer, in_dex, size, type, stride, offset);
    static function vertexArrayVertexAttribLFormatEXT(vaobj:Int, attribin_dex:Int, size:Int, type:Int, relativeoffset:Int):Void return ExtensionsNative.vertexArrayVertexAttribLFormatEXT(vaobj, attribin_dex, size, type, relativeoffset);
    static function vertexArrayVertexAttribLOffsetEXT(vaobj:Int, buffer:Int, in_dex:Int, size:Int, type:Int, stride:Int, offset:Int):Void return ExtensionsNative.vertexArrayVertexAttribLOffsetEXT(vaobj, buffer, in_dex, size, type, stride, offset);
    static function vertexArrayVertexAttribOffsetEXT(vaobj:Int, buffer:Int, in_dex:Int, size:Int, type:Int, normalized:Bool, stride:Int, offset:Int):Void return ExtensionsNative.vertexArrayVertexAttribOffsetEXT(vaobj, buffer, in_dex, size, type, normalized, stride, offset);
    static function vertexArrayVertexBindingDivisorEXT(vaobj:Int, bin_din_gin_dex:Int, divisor:Int):Void return ExtensionsNative.vertexArrayVertexBindingDivisorEXT(vaobj, bin_din_gin_dex, divisor);
    static function vertexArrayVertexBuffer(vaobj:Int, bin_din_gin_dex:Int, buffer:Int, offset:Int, stride:Int):Void return ExtensionsNative.vertexArrayVertexBuffer(vaobj, bin_din_gin_dex, buffer, offset, stride);
    static function vertexArrayVertexBuffers(vaobj:Int, first:Int, count:Int, buffers:DataPointer, offsets:DataPointer, strides:DataPointer):Void return ExtensionsNative.vertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides);
    static function vertexArrayVertexOffsetEXT(vaobj:Int, buffer:Int, size:Int, type:Int, stride:Int, offset:Int):Void return ExtensionsNative.vertexArrayVertexOffsetEXT(vaobj, buffer, size, type, stride, offset);
    static function vertexAttrib1d(in_dex:Int, x:DataPointer):Void return ExtensionsNative.vertexAttrib1d(in_dex, x);
    static function vertexAttrib1dARB(in_dex:Int, x:DataPointer):Void return ExtensionsNative.vertexAttrib1dARB(in_dex, x);
    static function vertexAttrib1dNV(in_dex:Int, x:DataPointer):Void return ExtensionsNative.vertexAttrib1dNV(in_dex, x);
    static function vertexAttrib1dv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib1dv(in_dex, v);
    static function vertexAttrib1dvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib1dvARB(in_dex, v);
    static function vertexAttrib1dvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib1dvNV(in_dex, v);
    static function vertexAttrib1f(in_dex:Int, x:Float):Void return ExtensionsNative.vertexAttrib1f(in_dex, x);
    static function vertexAttrib1fARB(in_dex:Int, x:Float):Void return ExtensionsNative.vertexAttrib1fARB(in_dex, x);
    static function vertexAttrib1fNV(in_dex:Int, x:Float):Void return ExtensionsNative.vertexAttrib1fNV(in_dex, x);
    static function vertexAttrib1fv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib1fv(in_dex, v);
    static function vertexAttrib1fvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib1fvARB(in_dex, v);
    static function vertexAttrib1fvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib1fvNV(in_dex, v);
    static function vertexAttrib1hNV(in_dex:Int, x:Int):Void return ExtensionsNative.vertexAttrib1hNV(in_dex, x);
    static function vertexAttrib1hvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib1hvNV(in_dex, v);
    static function vertexAttrib1s(in_dex:Int, x:Int):Void return ExtensionsNative.vertexAttrib1s(in_dex, x);
    static function vertexAttrib1sARB(in_dex:Int, x:Int):Void return ExtensionsNative.vertexAttrib1sARB(in_dex, x);
    static function vertexAttrib1sNV(in_dex:Int, x:Int):Void return ExtensionsNative.vertexAttrib1sNV(in_dex, x);
    static function vertexAttrib1sv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib1sv(in_dex, v);
    static function vertexAttrib1svARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib1svARB(in_dex, v);
    static function vertexAttrib1svNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib1svNV(in_dex, v);
    static function vertexAttrib2d(in_dex:Int, x:DataPointer, y:DataPointer):Void return ExtensionsNative.vertexAttrib2d(in_dex, x, y);
    static function vertexAttrib2dARB(in_dex:Int, x:DataPointer, y:DataPointer):Void return ExtensionsNative.vertexAttrib2dARB(in_dex, x, y);
    static function vertexAttrib2dNV(in_dex:Int, x:DataPointer, y:DataPointer):Void return ExtensionsNative.vertexAttrib2dNV(in_dex, x, y);
    static function vertexAttrib2dv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib2dv(in_dex, v);
    static function vertexAttrib2dvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib2dvARB(in_dex, v);
    static function vertexAttrib2dvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib2dvNV(in_dex, v);
    static function vertexAttrib2f(in_dex:Int, x:Float, y:Float):Void return ExtensionsNative.vertexAttrib2f(in_dex, x, y);
    static function vertexAttrib2fARB(in_dex:Int, x:Float, y:Float):Void return ExtensionsNative.vertexAttrib2fARB(in_dex, x, y);
    static function vertexAttrib2fNV(in_dex:Int, x:Float, y:Float):Void return ExtensionsNative.vertexAttrib2fNV(in_dex, x, y);
    static function vertexAttrib2fv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib2fv(in_dex, v);
    static function vertexAttrib2fvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib2fvARB(in_dex, v);
    static function vertexAttrib2fvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib2fvNV(in_dex, v);
    static function vertexAttrib2hNV(in_dex:Int, x:Int, y:Int):Void return ExtensionsNative.vertexAttrib2hNV(in_dex, x, y);
    static function vertexAttrib2hvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib2hvNV(in_dex, v);
    static function vertexAttrib2s(in_dex:Int, x:Int, y:Int):Void return ExtensionsNative.vertexAttrib2s(in_dex, x, y);
    static function vertexAttrib2sARB(in_dex:Int, x:Int, y:Int):Void return ExtensionsNative.vertexAttrib2sARB(in_dex, x, y);
    static function vertexAttrib2sNV(in_dex:Int, x:Int, y:Int):Void return ExtensionsNative.vertexAttrib2sNV(in_dex, x, y);
    static function vertexAttrib2sv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib2sv(in_dex, v);
    static function vertexAttrib2svARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib2svARB(in_dex, v);
    static function vertexAttrib2svNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib2svNV(in_dex, v);
    static function vertexAttrib3d(in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.vertexAttrib3d(in_dex, x, y, z);
    static function vertexAttrib3dARB(in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.vertexAttrib3dARB(in_dex, x, y, z);
    static function vertexAttrib3dNV(in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.vertexAttrib3dNV(in_dex, x, y, z);
    static function vertexAttrib3dv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib3dv(in_dex, v);
    static function vertexAttrib3dvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib3dvARB(in_dex, v);
    static function vertexAttrib3dvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib3dvNV(in_dex, v);
    static function vertexAttrib3f(in_dex:Int, x:Float, y:Float, z:Float):Void return ExtensionsNative.vertexAttrib3f(in_dex, x, y, z);
    static function vertexAttrib3fARB(in_dex:Int, x:Float, y:Float, z:Float):Void return ExtensionsNative.vertexAttrib3fARB(in_dex, x, y, z);
    static function vertexAttrib3fNV(in_dex:Int, x:Float, y:Float, z:Float):Void return ExtensionsNative.vertexAttrib3fNV(in_dex, x, y, z);
    static function vertexAttrib3fv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib3fv(in_dex, v);
    static function vertexAttrib3fvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib3fvARB(in_dex, v);
    static function vertexAttrib3fvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib3fvNV(in_dex, v);
    static function vertexAttrib3hNV(in_dex:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexAttrib3hNV(in_dex, x, y, z);
    static function vertexAttrib3hvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib3hvNV(in_dex, v);
    static function vertexAttrib3s(in_dex:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexAttrib3s(in_dex, x, y, z);
    static function vertexAttrib3sARB(in_dex:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexAttrib3sARB(in_dex, x, y, z);
    static function vertexAttrib3sNV(in_dex:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexAttrib3sNV(in_dex, x, y, z);
    static function vertexAttrib3sv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib3sv(in_dex, v);
    static function vertexAttrib3svARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib3svARB(in_dex, v);
    static function vertexAttrib3svNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib3svNV(in_dex, v);
    static function vertexAttrib4Nbv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4Nbv(in_dex, v);
    static function vertexAttrib4NbvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4NbvARB(in_dex, v);
    static function vertexAttrib4Niv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4Niv(in_dex, v);
    static function vertexAttrib4NivARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4NivARB(in_dex, v);
    static function vertexAttrib4Nsv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4Nsv(in_dex, v);
    static function vertexAttrib4NsvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4NsvARB(in_dex, v);
    static function vertexAttrib4Nub(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttrib4Nub(in_dex, x, y, z, w);
    static function vertexAttrib4NubARB(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttrib4NubARB(in_dex, x, y, z, w);
    static function vertexAttrib4Nubv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4Nubv(in_dex, v);
    static function vertexAttrib4NubvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4NubvARB(in_dex, v);
    static function vertexAttrib4Nuiv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4Nuiv(in_dex, v);
    static function vertexAttrib4NuivARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4NuivARB(in_dex, v);
    static function vertexAttrib4Nusv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4Nusv(in_dex, v);
    static function vertexAttrib4NusvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4NusvARB(in_dex, v);
    static function vertexAttrib4bv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4bv(in_dex, v);
    static function vertexAttrib4bvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4bvARB(in_dex, v);
    static function vertexAttrib4d(in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.vertexAttrib4d(in_dex, x, y, z, w);
    static function vertexAttrib4dARB(in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.vertexAttrib4dARB(in_dex, x, y, z, w);
    static function vertexAttrib4dNV(in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.vertexAttrib4dNV(in_dex, x, y, z, w);
    static function vertexAttrib4dv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4dv(in_dex, v);
    static function vertexAttrib4dvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4dvARB(in_dex, v);
    static function vertexAttrib4dvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4dvNV(in_dex, v);
    static function vertexAttrib4f(in_dex:Int, x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.vertexAttrib4f(in_dex, x, y, z, w);
    static function vertexAttrib4fARB(in_dex:Int, x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.vertexAttrib4fARB(in_dex, x, y, z, w);
    static function vertexAttrib4fNV(in_dex:Int, x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.vertexAttrib4fNV(in_dex, x, y, z, w);
    static function vertexAttrib4fv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4fv(in_dex, v);
    static function vertexAttrib4fvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4fvARB(in_dex, v);
    static function vertexAttrib4fvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4fvNV(in_dex, v);
    static function vertexAttrib4hNV(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttrib4hNV(in_dex, x, y, z, w);
    static function vertexAttrib4hvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4hvNV(in_dex, v);
    static function vertexAttrib4iv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4iv(in_dex, v);
    static function vertexAttrib4ivARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4ivARB(in_dex, v);
    static function vertexAttrib4s(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttrib4s(in_dex, x, y, z, w);
    static function vertexAttrib4sARB(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttrib4sARB(in_dex, x, y, z, w);
    static function vertexAttrib4sNV(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttrib4sNV(in_dex, x, y, z, w);
    static function vertexAttrib4sv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4sv(in_dex, v);
    static function vertexAttrib4svARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4svARB(in_dex, v);
    static function vertexAttrib4svNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4svNV(in_dex, v);
    static function vertexAttrib4ubNV(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttrib4ubNV(in_dex, x, y, z, w);
    static function vertexAttrib4ubv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4ubv(in_dex, v);
    static function vertexAttrib4ubvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4ubvARB(in_dex, v);
    static function vertexAttrib4ubvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4ubvNV(in_dex, v);
    static function vertexAttrib4uiv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4uiv(in_dex, v);
    static function vertexAttrib4uivARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4uivARB(in_dex, v);
    static function vertexAttrib4usv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4usv(in_dex, v);
    static function vertexAttrib4usvARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttrib4usvARB(in_dex, v);
    static function vertexAttribArrayObjectATI(in_dex:Int, size:Int, type:Int, normalized:Bool, stride:Int, buffer:Int, offset:Int):Void return ExtensionsNative.vertexAttribArrayObjectATI(in_dex, size, type, normalized, stride, buffer, offset);
    /**
    * - #### Purpose:
    * associate a vertex attribute and a vertex buffer binding for a vertex array object
    * ### Description:
    * **glVertexAttribBinding** and **glVertexArrayAttribBinding** establishes an association between the generic vertex attribute of a vertex array object whose index is given by **attribindex**, and a vertex buffer binding whose index is given by **bindingindex**. For **glVertexAttribBinding**, the vertex array object affected is that currently bound. For **glVertexArrayAttribBinding**, **vaobj** is the name of the vertex array object.
    * 
    * **attribindex** must be less than the value of `GL_MAX_VERTEX_ATTRIBS` and **bindingindex** must be less than the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_OPERATION` is generated by **glVertexAttribBinding** if no vertex array object is bound.
    * 
    * `GL_INVALID_OPERATION` is generated by **glVertexArrayAttribBinding** if **vaobj** is not the name of an existing vertex array object.
    * 
    * `GL_INVALID_VALUE` is generated if **attribindex** is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIBS`.
    * 
    * `GL_INVALID_VALUE` is generated if **bindingindex** is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.
    * 
    * @param vaobj Specifies the name of the vertex array object for **glVertexArrayAttribBinding**.
    * @param attribindex The index of the attribute to associate with a vertex buffer binding.
    * @param bindingindex The index of the vertex buffer binding with which to associate the generic vertex attribute.

    * @see **`glBindVertexBuffer`**, **`glVertexAttribFormat`**, **`glVertexBindingDivisor`**, **`glVertexAttribPointer`**.

    **/
    static function vertexAttribBinding(attribin_dex:Int, bin_din_gin_dex:Int):Void return ExtensionsNative.vertexAttribBinding(attribin_dex, bin_din_gin_dex);
    /**
    * - #### Purpose:
    * modify the rate at which generic vertex attributes advance during instanced rendering
    * ### Description:
    * **glVertexAttribDivisor** modifies the rate at which generic vertex attributes advance when rendering multiple instances of primitives in a single draw call. If **divisor** is zero, the attribute at slot **index** advances once per vertex. If **divisor** is non-zero, the attribute advances once per **divisor** instances of the set(s) of vertices being rendered. An attribute is referred to as instanced if its `GL_VERTEX_ATTRIB_ARRAY_DIVISOR` value is non-zero.
    * 
    * **index** must be less than the value of `GL_MAX_VERTEX_ATTRIBS`.
    * 
    * 
    * ### Notes:
    * **glVertexAttribDivisor** is available only if the GL version is 3.3 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIBS`.
    * 
    * @param index Specify the index of the generic vertex attribute.
    * @param divisor Specify the number of instances that will pass between updates of the generic attribute at slot **index**.

    * @see **`glVertexAttribPointer`**, **`glEnableVertexAttribArray`**, **glDisableVertexAttribArray**

    **/
    static function vertexAttribDivisor(in_dex:Int, divisor:Int):Void return ExtensionsNative.vertexAttribDivisor(in_dex, divisor);
    static function vertexAttribDivisorANGLE(in_dex:Int, divisor:Int):Void return ExtensionsNative.vertexAttribDivisorANGLE(in_dex, divisor);
    static function vertexAttribDivisorARB(in_dex:Int, divisor:Int):Void return ExtensionsNative.vertexAttribDivisorARB(in_dex, divisor);
    static function vertexAttribDivisorEXT(in_dex:Int, divisor:Int):Void return ExtensionsNative.vertexAttribDivisorEXT(in_dex, divisor);
    static function vertexAttribDivisorNV(in_dex:Int, divisor:Int):Void return ExtensionsNative.vertexAttribDivisorNV(in_dex, divisor);
    /**
    * - #### Purpose:
    * specify the organization of vertex arrays
    * ### Description:
    * **glVertexAttribFormat**, **glVertexAttribIFormat** and **glVertexAttribLFormat**, as well as **glVertexArrayAttribFormat**, **glVertexArrayAttribIFormat** and **glVertexArrayAttribLFormat** specify the organization of data in vertex arrays. The first three calls operate on the bound vertex array object, whereas the last three ones modify the state of a vertex array object with ID **vaobj**. **attribindex** specifies the index of the generic vertex attribute array whose data layout is being described, and must be less than the value of `GL_MAX_VERTEX_ATTRIBS`.
    * 
    * **size** determines the number of components per vertex are allocated to the specified attribute and must be 1, 2, 3, 4, or GL_BGRA. **type** indicates the type of the data. If **type** is one of `GL_BYTE`, `GL_SHORT`, `GL_INT`, `GL_FIXED`, `GL_FLOAT`, `GL_HALF_FLOAT`, and `GL_DOUBLE` indicate types GLbyte, GLshort, GLint, GLfixed, GLfloat, GLhalf, and GLdouble, respectively; the values `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, and `GL_UNSIGNED_INT` indicate types GLubyte, GLushort, and GLuint, respectively; the values `GL_INT_2_10_10_10_REV` and `GL_UNSIGNED_INT_2_10_10_10_REV` indicating respectively four signed or unsigned elements packed into a single GLuint; and the value `GL_UNSIGNED_INT_10F_11F_11F_REV` indicating three floating point values packed into a single GLuint.
    * 
    * **glVertexAttribLFormat** and **glVertexArrayAttribLFormat** is used to specify layout for data associated with a generic attribute variable declared as 64-bit double precision components. For **glVertexAttribLFormat** and **glVertexArrayAttribLFormat**, **type** must be `GL_DOUBLE`. In contrast to **glVertexAttribFormat** or **glVertexArrayAttribFormat**, which will cause data declared as `GL_DOUBLE` to be converted to 32-bit representation, **glVertexAttribLFormat** and **glVertexArrayAttribLFormat** cause such data to be left in its natural, 64-bit representation.
    * 
    * For **glVertexAttribFormat** and **glVertexArrayAttribFormat**, if **normalized** is `GL_TRUE`, then integer data is normalized to the range [-1, 1] or [0, 1] if it is signed or unsigned, respectively. If **normalized** is `GL_FALSE` then integer data is directly converted to floating point.
    * 
    * **relativeoffset** is the offset, measured in basic machine units of the first element relative to the start of the vertex buffer binding this attribute fetches from.
    * 
    * **glVertexAttribFormat** and **glVertexArrayAttribFormat** should be used to describe vertex attribute layout for floating-point vertex attributes, **glVertexAttribIFormat** and **glVertexArrayAttribIFormat** should be used to describe vertex attribute layout for integer vertex attribute, and **glVertexAttribLFormat** and **glVertexArrayAttribLFormat** should be used to describe the layout for 64-bit vertex attributes. Data for an array specified by **glVertexAttribIFormat** and **glVertexArrayAttribIFormat** will always be left as integer values; such data are referred to as pure integers.
    * 
    * 
    * ### Notes:
    * `GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for **type** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **attribindex** is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIBS`.
    * 
    * `GL_INVALID_VALUE` is generated if **size** is not one of the accepted values.
    * 
    * `GL_INVALID_VALUE` is generated if **relativeoffset** is greater than the value of `GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET`.
    * 
    * `GL_INVALID_ENUM` is generated if **type** is not one of the accepted tokens.
    * 
    * `GL_INVALID_ENUM` is generated by **glVertexAttribIFormat**, **glVertexAttribLFormat**, **glVertexArrayAttribIFormat** and **glVertexArrayAttribLFormat** if **type** is `GL_UNSIGNED_INT_10F_11F_11F_REV`.
    * 
    * `GL_INVALID_OPERATION` is generated by **glVertexAttribFormat**, **glVertexAttribIFormat** and **glVertexAttribLFormat** if no vertex array object is bound.
    * 
    * `GL_INVALID_OPERATION` is generated by **glVertexArrayAttribFormat**, **glVertexArrayAttribIFormat** and **glVertexArrayAttribLFormat** if **vaobj** is not the name of an existing vertex array object.
    * 
    * `GL_INVALID_OPERATION` is generated under any of the following conditions:
    * 
    * **size** is `GL_BGRA` and **type** is not `GL_UNSIGNED_BYTE`, `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`. **type** is `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, and **size** is neither 4 nor `GL_BGRA`. **type** is `GL_UNSIGNED_INT_10F_11F_11F_REV` and **size** is not 3. **size** is `GL_BGRA` and **normalized** is `GL_FALSE`.
    * 
    * @param vaobj Specifies the name of the vertex array object for **glVertexArrayAttrib{I, L}Format** functions.
    * @param attribindex The generic vertex attribute array being described.
    * @param size The number of values per vertex that are stored in the array.
    * @param type The type of the data stored in the array.
    * @param normalized Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if **type** is `GL_FIXED`.
    * @param relativeoffset The distance between elements within the buffer.

    * @see **`glBindVertexBuffer`**, **`glVertexAttribBinding`**, **`glVertexAttribPointer`**, **`glVertexBindingDivisor`**, **`glVertexAttribPointer`**.

    **/
    static function vertexAttribFormat(attribin_dex:Int, size:Int, type:Int, normalized:Bool, relativeoffset:Int):Void return ExtensionsNative.vertexAttribFormat(attribin_dex, size, type, normalized, relativeoffset);
    static function vertexAttribFormatNV(in_dex:Int, size:Int, type:Int, normalized:Bool, stride:Int):Void return ExtensionsNative.vertexAttribFormatNV(in_dex, size, type, normalized, stride);
    static function vertexAttribI1i(in_dex:Int, x:Int):Void return ExtensionsNative.vertexAttribI1i(in_dex, x);
    static function vertexAttribI1iEXT(in_dex:Int, x:Int):Void return ExtensionsNative.vertexAttribI1iEXT(in_dex, x);
    static function vertexAttribI1iv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI1iv(in_dex, v);
    static function vertexAttribI1ivEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI1ivEXT(in_dex, v);
    static function vertexAttribI1ui(in_dex:Int, x:Int):Void return ExtensionsNative.vertexAttribI1ui(in_dex, x);
    static function vertexAttribI1uiEXT(in_dex:Int, x:Int):Void return ExtensionsNative.vertexAttribI1uiEXT(in_dex, x);
    static function vertexAttribI1uiv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI1uiv(in_dex, v);
    static function vertexAttribI1uivEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI1uivEXT(in_dex, v);
    static function vertexAttribI2i(in_dex:Int, x:Int, y:Int):Void return ExtensionsNative.vertexAttribI2i(in_dex, x, y);
    static function vertexAttribI2iEXT(in_dex:Int, x:Int, y:Int):Void return ExtensionsNative.vertexAttribI2iEXT(in_dex, x, y);
    static function vertexAttribI2iv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI2iv(in_dex, v);
    static function vertexAttribI2ivEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI2ivEXT(in_dex, v);
    static function vertexAttribI2ui(in_dex:Int, x:Int, y:Int):Void return ExtensionsNative.vertexAttribI2ui(in_dex, x, y);
    static function vertexAttribI2uiEXT(in_dex:Int, x:Int, y:Int):Void return ExtensionsNative.vertexAttribI2uiEXT(in_dex, x, y);
    static function vertexAttribI2uiv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI2uiv(in_dex, v);
    static function vertexAttribI2uivEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI2uivEXT(in_dex, v);
    static function vertexAttribI3i(in_dex:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexAttribI3i(in_dex, x, y, z);
    static function vertexAttribI3iEXT(in_dex:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexAttribI3iEXT(in_dex, x, y, z);
    static function vertexAttribI3iv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI3iv(in_dex, v);
    static function vertexAttribI3ivEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI3ivEXT(in_dex, v);
    static function vertexAttribI3ui(in_dex:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexAttribI3ui(in_dex, x, y, z);
    static function vertexAttribI3uiEXT(in_dex:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexAttribI3uiEXT(in_dex, x, y, z);
    static function vertexAttribI3uiv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI3uiv(in_dex, v);
    static function vertexAttribI3uivEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI3uivEXT(in_dex, v);
    static function vertexAttribI4bv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4bv(in_dex, v);
    static function vertexAttribI4bvEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4bvEXT(in_dex, v);
    static function vertexAttribI4i(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttribI4i(in_dex, x, y, z, w);
    static function vertexAttribI4iEXT(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttribI4iEXT(in_dex, x, y, z, w);
    static function vertexAttribI4iv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4iv(in_dex, v);
    static function vertexAttribI4ivEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4ivEXT(in_dex, v);
    static function vertexAttribI4sv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4sv(in_dex, v);
    static function vertexAttribI4svEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4svEXT(in_dex, v);
    static function vertexAttribI4ubv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4ubv(in_dex, v);
    static function vertexAttribI4ubvEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4ubvEXT(in_dex, v);
    static function vertexAttribI4ui(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttribI4ui(in_dex, x, y, z, w);
    static function vertexAttribI4uiEXT(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttribI4uiEXT(in_dex, x, y, z, w);
    static function vertexAttribI4uiv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4uiv(in_dex, v);
    static function vertexAttribI4uivEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4uivEXT(in_dex, v);
    static function vertexAttribI4usv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4usv(in_dex, v);
    static function vertexAttribI4usvEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribI4usvEXT(in_dex, v);
    static function vertexAttribIFormat(attribin_dex:Int, size:Int, type:Int, relativeoffset:Int):Void return ExtensionsNative.vertexAttribIFormat(attribin_dex, size, type, relativeoffset);
    static function vertexAttribIFormatNV(in_dex:Int, size:Int, type:Int, stride:Int):Void return ExtensionsNative.vertexAttribIFormatNV(in_dex, size, type, stride);
    static function vertexAttribIPointer(in_dex:Int, size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexAttribIPointer(in_dex, size, type, stride, poin_ter);
    static function vertexAttribIPointerEXT(in_dex:Int, size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexAttribIPointerEXT(in_dex, size, type, stride, poin_ter);
    static function vertexAttribL1d(in_dex:Int, x:DataPointer):Void return ExtensionsNative.vertexAttribL1d(in_dex, x);
    static function vertexAttribL1dEXT(in_dex:Int, x:DataPointer):Void return ExtensionsNative.vertexAttribL1dEXT(in_dex, x);
    static function vertexAttribL1dv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL1dv(in_dex, v);
    static function vertexAttribL1dvEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL1dvEXT(in_dex, v);
    static function vertexAttribL1i64NV(in_dex:Int, x:Int):Void return ExtensionsNative.vertexAttribL1i64NV(in_dex, x);
    static function vertexAttribL1i64vNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL1i64vNV(in_dex, v);
    static function vertexAttribL1ui64ARB(in_dex:Int, x:Int):Void return ExtensionsNative.vertexAttribL1ui64ARB(in_dex, x);
    static function vertexAttribL1ui64NV(in_dex:Int, x:Int):Void return ExtensionsNative.vertexAttribL1ui64NV(in_dex, x);
    static function vertexAttribL1ui64vARB(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL1ui64vARB(in_dex, v);
    static function vertexAttribL1ui64vNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL1ui64vNV(in_dex, v);
    static function vertexAttribL2d(in_dex:Int, x:DataPointer, y:DataPointer):Void return ExtensionsNative.vertexAttribL2d(in_dex, x, y);
    static function vertexAttribL2dEXT(in_dex:Int, x:DataPointer, y:DataPointer):Void return ExtensionsNative.vertexAttribL2dEXT(in_dex, x, y);
    static function vertexAttribL2dv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL2dv(in_dex, v);
    static function vertexAttribL2dvEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL2dvEXT(in_dex, v);
    static function vertexAttribL2i64NV(in_dex:Int, x:Int, y:Int):Void return ExtensionsNative.vertexAttribL2i64NV(in_dex, x, y);
    static function vertexAttribL2i64vNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL2i64vNV(in_dex, v);
    static function vertexAttribL2ui64NV(in_dex:Int, x:Int, y:Int):Void return ExtensionsNative.vertexAttribL2ui64NV(in_dex, x, y);
    static function vertexAttribL2ui64vNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL2ui64vNV(in_dex, v);
    static function vertexAttribL3d(in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.vertexAttribL3d(in_dex, x, y, z);
    static function vertexAttribL3dEXT(in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.vertexAttribL3dEXT(in_dex, x, y, z);
    static function vertexAttribL3dv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL3dv(in_dex, v);
    static function vertexAttribL3dvEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL3dvEXT(in_dex, v);
    static function vertexAttribL3i64NV(in_dex:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexAttribL3i64NV(in_dex, x, y, z);
    static function vertexAttribL3i64vNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL3i64vNV(in_dex, v);
    static function vertexAttribL3ui64NV(in_dex:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexAttribL3ui64NV(in_dex, x, y, z);
    static function vertexAttribL3ui64vNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL3ui64vNV(in_dex, v);
    static function vertexAttribL4d(in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.vertexAttribL4d(in_dex, x, y, z, w);
    static function vertexAttribL4dEXT(in_dex:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.vertexAttribL4dEXT(in_dex, x, y, z, w);
    static function vertexAttribL4dv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL4dv(in_dex, v);
    static function vertexAttribL4dvEXT(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL4dvEXT(in_dex, v);
    static function vertexAttribL4i64NV(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttribL4i64NV(in_dex, x, y, z, w);
    static function vertexAttribL4i64vNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL4i64vNV(in_dex, v);
    static function vertexAttribL4ui64NV(in_dex:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexAttribL4ui64NV(in_dex, x, y, z, w);
    static function vertexAttribL4ui64vNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribL4ui64vNV(in_dex, v);
    static function vertexAttribLFormat(attribin_dex:Int, size:Int, type:Int, relativeoffset:Int):Void return ExtensionsNative.vertexAttribLFormat(attribin_dex, size, type, relativeoffset);
    static function vertexAttribLFormatNV(in_dex:Int, size:Int, type:Int, stride:Int):Void return ExtensionsNative.vertexAttribLFormatNV(in_dex, size, type, stride);
    static function vertexAttribLPointer(in_dex:Int, size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexAttribLPointer(in_dex, size, type, stride, poin_ter);
    static function vertexAttribLPointerEXT(in_dex:Int, size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexAttribLPointerEXT(in_dex, size, type, stride, poin_ter);
    static function vertexAttribP1ui(in_dex:Int, type:Int, normalized:Bool, value:Int):Void return ExtensionsNative.vertexAttribP1ui(in_dex, type, normalized, value);
    static function vertexAttribP1uiv(in_dex:Int, type:Int, normalized:Bool, value:DataPointer):Void return ExtensionsNative.vertexAttribP1uiv(in_dex, type, normalized, value);
    static function vertexAttribP2ui(in_dex:Int, type:Int, normalized:Bool, value:Int):Void return ExtensionsNative.vertexAttribP2ui(in_dex, type, normalized, value);
    static function vertexAttribP2uiv(in_dex:Int, type:Int, normalized:Bool, value:DataPointer):Void return ExtensionsNative.vertexAttribP2uiv(in_dex, type, normalized, value);
    static function vertexAttribP3ui(in_dex:Int, type:Int, normalized:Bool, value:Int):Void return ExtensionsNative.vertexAttribP3ui(in_dex, type, normalized, value);
    static function vertexAttribP3uiv(in_dex:Int, type:Int, normalized:Bool, value:DataPointer):Void return ExtensionsNative.vertexAttribP3uiv(in_dex, type, normalized, value);
    static function vertexAttribP4ui(in_dex:Int, type:Int, normalized:Bool, value:Int):Void return ExtensionsNative.vertexAttribP4ui(in_dex, type, normalized, value);
    static function vertexAttribP4uiv(in_dex:Int, type:Int, normalized:Bool, value:DataPointer):Void return ExtensionsNative.vertexAttribP4uiv(in_dex, type, normalized, value);
    static function vertexAttribParameteriAMD(in_dex:Int, pname:Int, param:Int):Void return ExtensionsNative.vertexAttribParameteriAMD(in_dex, pname, param);
    /**
    * - #### Purpose:
    * define an array of generic vertex attribute data
    * ### Description:
    * **glVertexAttribPointer**, **glVertexAttribIPointer** and **glVertexAttribLPointer** specify the location and data format of the array of generic vertex attributes at index **index** to use when rendering. **size** specifies the number of components per attribute and must be 1, 2, 3, 4, or `GL_BGRA`. **type** specifies the data type of each component, and **stride** specifies the byte stride from one attribute to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays.
    * 
    * For **glVertexAttribPointer**, if **normalized** is set to `GL_TRUE`, it indicates that values stored in an integer format are to be mapped to the range [-1,1] (for signed values) or [0,1] (for unsigned values) when they are accessed and converted to floating point. Otherwise, values will be converted to floats directly without normalization.
    * 
    * For **glVertexAttribIPointer**, only the integer types `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, `GL_UNSIGNED_INT` are accepted. Values are always left as integer values.
    * 
    * **glVertexAttribLPointer** specifies state for a generic vertex attribute array associated with a shader attribute variable declared with 64-bit double precision components. **type** must be `GL_DOUBLE`. **index**, **size**, and **stride** behave as described for **glVertexAttribPointer** and **glVertexAttribIPointer**.
    * 
    * If **pointer** is not NULL, a non-zero named buffer object must be bound to the `GL_ARRAY_BUFFER` target (see **`glBindBuffer`**), otherwise an error is generated. **pointer** is treated as a byte offset into the buffer object's data store. The buffer object binding (`GL_ARRAY_BUFFER_BINDING`) is saved as generic vertex attribute array state (`GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`) for index **index**.
    * 
    * When a generic vertex attribute array is specified, **size**, **type**, **normalized**, **stride**, and **pointer** are saved as vertex array state, in addition to the current vertex array buffer object binding.
    * 
    * To enable and disable a generic vertex attribute array, call **`glEnableVertexAttribArray`** and **glDisableVertexAttribArray** with **index**. If enabled, the generic vertex attribute array is used when **`glDrawArrays`**, **`glMultiDrawArrays`**, **`glDrawElements`**, **`glMultiDrawElements`**, or **`glDrawRangeElements`** is called.
    * 
    * 
    * ### Notes:
    * Each generic vertex attribute array is initially disabled and isn't accessed when **`glDrawElements`**, **`glDrawRangeElements`**, **`glDrawArrays`**, **`glMultiDrawArrays`**, or **`glMultiDrawElements`** is called.
    * 
    * `GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for **type** only if the GL version is 4.4 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **index** is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.
    * 
    * `GL_INVALID_VALUE` is generated if **size** is not 1, 2, 3, 4 or (for **glVertexAttribPointer**), `GL_BGRA`.
    * 
    * `GL_INVALID_ENUM` is generated if **type** is not an accepted value.
    * 
    * `GL_INVALID_VALUE` is generated if **stride** is negative.
    * 
    * `GL_INVALID_OPERATION` is generated if **size** is `GL_BGRA` and **type** is not `GL_UNSIGNED_BYTE`, `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV` and **size** is not 4 or `GL_BGRA`.
    * 
    * `GL_INVALID_OPERATION` is generated if **type** is `GL_UNSIGNED_INT_10F_11F_11F_REV` and **size** is not 3.
    * 
    * `GL_INVALID_OPERATION` is generated by **glVertexAttribPointer** if **size** is `GL_BGRA` and **normalized** is `GL_FALSE`.
    * 
    * `GL_INVALID_OPERATION` is generated if zero is bound to the `GL_ARRAY_BUFFER` buffer object binding point and the **pointer** argument is not `NULL`.
    * 
    * @param index Specifies the index of the generic vertex attribute to be modified.
    * @param size Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant `GL_BGRA` is accepted by **glVertexAttribPointer**. The initial value is 4.
    * @param type Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by **glVertexAttribPointer** and **glVertexAttribIPointer**. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_DOUBLE`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_2_10_10_10_REV` and `GL_UNSIGNED_INT_10F_11F_11F_REV` are accepted by **glVertexAttribPointer**. `GL_DOUBLE` is also accepted by **glVertexAttribLPointer** and is the only token accepted by the **type** parameter for that function. The initial value is `GL_FLOAT`.
    * @param normalized For **glVertexAttribPointer**, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed.
    * @param stride Specifies the byte offset between consecutive generic vertex attributes. If **stride** is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
    * @param pointer Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the `GL_ARRAY_BUFFER` target. The initial value is 0.

    * @see **`glBindAttribLocation`**, **`glBindBuffer`**, **glDisableVertexAttribArray**, **`glDrawArrays`**, **`glDrawElements`**, **`glDrawRangeElements`**, **`glEnableVertexAttribArray`**, **`glMultiDrawArrays`**, **`glMultiDrawElements`**, **`glVertexAttrib`**

    **/
    static function vertexAttribPointer(in_dex:Int, size:Int, type:Int, normalized:Bool, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexAttribPointer(in_dex, size, type, normalized, stride, poin_ter);
    static function vertexAttribPointerARB(in_dex:Int, size:Int, type:Int, normalized:Bool, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexAttribPointerARB(in_dex, size, type, normalized, stride, poin_ter);
    static function vertexAttribPointerNV(in_dex:Int, fsize:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexAttribPointerNV(in_dex, fsize, type, stride, poin_ter);
    static function vertexAttribs1dvNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs1dvNV(in_dex, count, v);
    static function vertexAttribs1fvNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs1fvNV(in_dex, count, v);
    static function vertexAttribs1hvNV(in_dex:Int, n:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs1hvNV(in_dex, n, v);
    static function vertexAttribs1svNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs1svNV(in_dex, count, v);
    static function vertexAttribs2dvNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs2dvNV(in_dex, count, v);
    static function vertexAttribs2fvNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs2fvNV(in_dex, count, v);
    static function vertexAttribs2hvNV(in_dex:Int, n:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs2hvNV(in_dex, n, v);
    static function vertexAttribs2svNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs2svNV(in_dex, count, v);
    static function vertexAttribs3dvNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs3dvNV(in_dex, count, v);
    static function vertexAttribs3fvNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs3fvNV(in_dex, count, v);
    static function vertexAttribs3hvNV(in_dex:Int, n:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs3hvNV(in_dex, n, v);
    static function vertexAttribs3svNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs3svNV(in_dex, count, v);
    static function vertexAttribs4dvNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs4dvNV(in_dex, count, v);
    static function vertexAttribs4fvNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs4fvNV(in_dex, count, v);
    static function vertexAttribs4hvNV(in_dex:Int, n:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs4hvNV(in_dex, n, v);
    static function vertexAttribs4svNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs4svNV(in_dex, count, v);
    static function vertexAttribs4ubvNV(in_dex:Int, count:Int, v:DataPointer):Void return ExtensionsNative.vertexAttribs4ubvNV(in_dex, count, v);
    /**
    * - #### Purpose:
    * modify the rate at which generic vertex attributes
        advance
    * ### Description:
    * **glVertexBindingDivisor** and **glVertexArrayBindingDivisor** modify the rate at which generic vertex attributes advance when rendering multiple instances of primitives in a single draw command. If **divisor** is zero, the attributes using the buffer bound to **bindingindex** advance once per vertex. If **divisor** is non-zero, the attributes advance once per **divisor** instances of the set(s) of vertices being rendered. An attribute is referred to as instanced if the corresponding **divisor** value is non-zero.
    * 
    * **glVertexBindingDivisor** uses currently bound vertex array object , whereas **glVertexArrayBindingDivisor** updates state of the vertex array object with ID **vaobj**.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **bindingindex** is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.
    * 
    * `GL_INVALID_OPERATION` by **glVertexBindingDivisor** is generated if no vertex array object is bound.
    * 
    * `GL_INVALID_OPERATION` is generated by **glVertexArrayBindingDivisor** if **vaobj** is not the name of an existing vertex array object.
    * 
    * @param vaobj Specifies the name of the vertex array object for **glVertexArrayBindingDivisor** function.
    * @param bindingindex The index of the binding whose divisor to modify.
    * @param divisor The new value for the instance step rate to apply.

    * @see **`glBindVertexBuffer`**, **`glVertexAttribBinding`**, **`glVertexAttribPointer`**, **`glVertexBindingDivisor`**, **`glVertexAttribPointer`**.

    **/
    static function vertexBindingDivisor(bin_din_gin_dex:Int, divisor:Int):Void return ExtensionsNative.vertexBindingDivisor(bin_din_gin_dex, divisor);
    static function vertexBlendARB(count:Int):Void return ExtensionsNative.vertexBlendARB(count);
    static function vertexBlendEnvfATI(pname:Int, param:Float):Void return ExtensionsNative.vertexBlendEnvfATI(pname, param);
    static function vertexBlendEnviATI(pname:Int, param:Int):Void return ExtensionsNative.vertexBlendEnviATI(pname, param);
    static function vertexFormatNV(size:Int, type:Int, stride:Int):Void return ExtensionsNative.vertexFormatNV(size, type, stride);
    static function vertexP2ui(type:Int, value:Int):Void return ExtensionsNative.vertexP2ui(type, value);
    static function vertexP2uiv(type:Int, value:DataPointer):Void return ExtensionsNative.vertexP2uiv(type, value);
    static function vertexP3ui(type:Int, value:Int):Void return ExtensionsNative.vertexP3ui(type, value);
    static function vertexP3uiv(type:Int, value:DataPointer):Void return ExtensionsNative.vertexP3uiv(type, value);
    static function vertexP4ui(type:Int, value:Int):Void return ExtensionsNative.vertexP4ui(type, value);
    static function vertexP4uiv(type:Int, value:DataPointer):Void return ExtensionsNative.vertexP4uiv(type, value);
    static function vertexPointer(size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexPointer(size, type, stride, poin_ter);
    static function vertexPointerEXT(size:Int, type:Int, stride:Int, count:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexPointerEXT(size, type, stride, count, poin_ter);
    static function vertexPointerListIBM(size:Int, type:Int, stride:Int, poin_ter:DataPointer, ptrstride:Int):Void return ExtensionsNative.vertexPointerListIBM(size, type, stride, poin_ter, ptrstride);
    static function vertexPointervINTEL(size:Int, type:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexPointervINTEL(size, type, poin_ter);
    static function vertexStream1dATI(stream:Int, x:DataPointer):Void return ExtensionsNative.vertexStream1dATI(stream, x);
    static function vertexStream1dvATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream1dvATI(stream, coords);
    static function vertexStream1fATI(stream:Int, x:Float):Void return ExtensionsNative.vertexStream1fATI(stream, x);
    static function vertexStream1fvATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream1fvATI(stream, coords);
    static function vertexStream1iATI(stream:Int, x:Int):Void return ExtensionsNative.vertexStream1iATI(stream, x);
    static function vertexStream1ivATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream1ivATI(stream, coords);
    static function vertexStream1sATI(stream:Int, x:Int):Void return ExtensionsNative.vertexStream1sATI(stream, x);
    static function vertexStream1svATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream1svATI(stream, coords);
    static function vertexStream2dATI(stream:Int, x:DataPointer, y:DataPointer):Void return ExtensionsNative.vertexStream2dATI(stream, x, y);
    static function vertexStream2dvATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream2dvATI(stream, coords);
    static function vertexStream2fATI(stream:Int, x:Float, y:Float):Void return ExtensionsNative.vertexStream2fATI(stream, x, y);
    static function vertexStream2fvATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream2fvATI(stream, coords);
    static function vertexStream2iATI(stream:Int, x:Int, y:Int):Void return ExtensionsNative.vertexStream2iATI(stream, x, y);
    static function vertexStream2ivATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream2ivATI(stream, coords);
    static function vertexStream2sATI(stream:Int, x:Int, y:Int):Void return ExtensionsNative.vertexStream2sATI(stream, x, y);
    static function vertexStream2svATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream2svATI(stream, coords);
    static function vertexStream3dATI(stream:Int, x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.vertexStream3dATI(stream, x, y, z);
    static function vertexStream3dvATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream3dvATI(stream, coords);
    static function vertexStream3fATI(stream:Int, x:Float, y:Float, z:Float):Void return ExtensionsNative.vertexStream3fATI(stream, x, y, z);
    static function vertexStream3fvATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream3fvATI(stream, coords);
    static function vertexStream3iATI(stream:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexStream3iATI(stream, x, y, z);
    static function vertexStream3ivATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream3ivATI(stream, coords);
    static function vertexStream3sATI(stream:Int, x:Int, y:Int, z:Int):Void return ExtensionsNative.vertexStream3sATI(stream, x, y, z);
    static function vertexStream3svATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream3svATI(stream, coords);
    static function vertexStream4dATI(stream:Int, x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.vertexStream4dATI(stream, x, y, z, w);
    static function vertexStream4dvATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream4dvATI(stream, coords);
    static function vertexStream4fATI(stream:Int, x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.vertexStream4fATI(stream, x, y, z, w);
    static function vertexStream4fvATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream4fvATI(stream, coords);
    static function vertexStream4iATI(stream:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexStream4iATI(stream, x, y, z, w);
    static function vertexStream4ivATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream4ivATI(stream, coords);
    static function vertexStream4sATI(stream:Int, x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.vertexStream4sATI(stream, x, y, z, w);
    static function vertexStream4svATI(stream:Int, coords:DataPointer):Void return ExtensionsNative.vertexStream4svATI(stream, coords);
    static function vertexWeightPointerEXT(size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.vertexWeightPointerEXT(size, type, stride, poin_ter);
    static function vertexWeightfEXT(weight:Float):Void return ExtensionsNative.vertexWeightfEXT(weight);
    static function vertexWeightfvEXT(weight:DataPointer):Void return ExtensionsNative.vertexWeightfvEXT(weight);
    static function vertexWeighthNV(weight:Int):Void return ExtensionsNative.vertexWeighthNV(weight);
    static function vertexWeighthvNV(weight:DataPointer):Void return ExtensionsNative.vertexWeighthvNV(weight);
    static function videoCaptureNV(video_capture_slot:Int, sequence_num:DataPointer, capture_time:DataPointer):Int return ExtensionsNative.videoCaptureNV(video_capture_slot, sequence_num, capture_time);
    static function videoCaptureStreamParameterdvNV(video_capture_slot:Int, stream:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.videoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, params);
    static function videoCaptureStreamParameterfvNV(video_capture_slot:Int, stream:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.videoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, params);
    static function videoCaptureStreamParameterivNV(video_capture_slot:Int, stream:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.videoCaptureStreamParameterivNV(video_capture_slot, stream, pname, params);
    /**
    * - #### Purpose:
    * set the viewport
    * ### Description:
    * **glViewport** specifies the affine transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window coordinates x w y w are computed as follows:
    * 
    * x w = x nd + 1 &amp;it; width 2 + x
    * 
    * y w = y nd + 1 &amp;it; height 2 + y
    * 
    * Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call **`glGet`** with argument `GL_MAX_VIEWPORT_DIMS`.
    * 
    * 
    * ### Notes:
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if either **width** or **height** is negative.
    * 
    * @param x y Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
    * @param width height Specify the width and height of the viewport. When a GL context is first attached to a window, **width** and **height** are set to the dimensions of that window.

    * @see **`glDepthRange`**

    **/
    static function viewport(x:Int, y:Int, width:Int, height:Int):Void return ExtensionsNative.viewport(x, y, width, height);
    static function viewportArrayv(first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.viewportArrayv(first, count, v);
    static function viewportArrayvNV(first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.viewportArrayvNV(first, count, v);
    static function viewportArrayvOES(first:Int, count:Int, v:DataPointer):Void return ExtensionsNative.viewportArrayvOES(first, count, v);
    static function viewportIndexedf(in_dex:Int, x:Float, y:Float, w:Float, h:Float):Void return ExtensionsNative.viewportIndexedf(in_dex, x, y, w, h);
    static function viewportIndexedfOES(in_dex:Int, x:Float, y:Float, w:Float, h:Float):Void return ExtensionsNative.viewportIndexedfOES(in_dex, x, y, w, h);
    static function viewportIndexedfNV(in_dex:Int, x:Float, y:Float, w:Float, h:Float):Void return ExtensionsNative.viewportIndexedfNV(in_dex, x, y, w, h);
    static function viewportIndexedfv(in_dex:Int, v:DataPointer):Void return ExtensionsNative.viewportIndexedfv(in_dex, v);
    static function viewportIndexedfvOES(in_dex:Int, v:DataPointer):Void return ExtensionsNative.viewportIndexedfvOES(in_dex, v);
    static function viewportIndexedfvNV(in_dex:Int, v:DataPointer):Void return ExtensionsNative.viewportIndexedfvNV(in_dex, v);
    static function viewportPositionWScaleNV(in_dex:Int, xcoeff:Float, ycoeff:Float):Void return ExtensionsNative.viewportPositionWScaleNV(in_dex, xcoeff, ycoeff);
    static function viewportSwizzleNV(in_dex:Int, swizzlex:Int, swizzley:Int, swizzlez:Int, swizzlew:Int):Void return ExtensionsNative.viewportSwizzleNV(in_dex, swizzlex, swizzley, swizzlez, swizzlew);
    static function waitSemaphoreEXT(semaphore:Int, numBufferBarriers:Int, buffers:DataPointer, numTextureBarriers:Int, textures:DataPointer, srcLayouts:DataPointer):Void return ExtensionsNative.waitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    static function waitSemaphoreui64NVX(waitGpu:Int, fenceObjectCount:Int, semaphoreArray:DataPointer, fenceValueArray:DataPointer):Void return ExtensionsNative.waitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    /**
    * - #### Purpose:
    * instruct the GL server to block until the specified sync object becomes signaled
    * ### Description:
    * **glWaitSync** causes the GL server to block and wait until **sync** becomes signaled. **sync** is the name of an existing sync object upon which to wait. **flags** and **timeout** are currently not used and must be set to zero and the special value `GL_TIMEOUT_IGNORED`, respectively**flags** and **timeout** are placeholders for anticipated future extensions of sync object capabilities. They must have these reserved values in order that existing code calling **glWaitSync** operate properly in the presence of such extensions.. **glWaitSync** will always wait no longer than an implementation-dependent timeout. The duration of this timeout in nanoseconds may be queried by calling **`glGet`** with the parameter `GL_MAX_SERVER_WAIT_TIMEOUT`. There is currently no way to determine whether **glWaitSync** unblocked because the timeout expired or because the sync object being waited on was signaled.
    * 
    * If an error occurs, **glWaitSync** does not cause the GL server to block.
    * 
    * 
    * ### Notes:
    * **glWaitSync** is available only if the GL version is 3.2 or higher.
    * 
    * 
    * ### Errors:
    * `GL_INVALID_VALUE` is generated if **sync** is not the name of a sync object.
    * 
    * `GL_INVALID_VALUE` is generated if **flags** is not zero.
    * 
    * `GL_INVALID_VALUE` is generated if **timeout** is not `GL_TIMEOUT_IGNORED`.
    * 
    * @param sync Specifies the sync object whose status to wait on.
    * @param flags A bitfield controlling the command flushing behavior. **flags** may be zero.
    * @param timeout Specifies the timeout that the server should wait before continuing. **timeout** must be `GL_TIMEOUT_IGNORED`.

    * @see **`glFenceSync`**, **`glClientWaitSync`**

    **/
    static function waitSync(sync:DataPointer, flags:Int, timeout:Int):Void return ExtensionsNative.waitSync(sync, flags, timeout);
    static function waitSyncAPPLE(sync:DataPointer, flags:Int, timeout:Int):Void return ExtensionsNative.waitSyncAPPLE(sync, flags, timeout);
    static function weightPathsNV(resultPath:Int, numPaths:Int, paths:DataPointer, weights:DataPointer):Void return ExtensionsNative.weightPathsNV(resultPath, numPaths, paths, weights);
    static function weightPointerARB(size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.weightPointerARB(size, type, stride, poin_ter);
    static function weightPointerOES(size:Int, type:Int, stride:Int, poin_ter:DataPointer):Void return ExtensionsNative.weightPointerOES(size, type, stride, poin_ter);
    static function weightbvARB(size:Int, weights:DataPointer):Void return ExtensionsNative.weightbvARB(size, weights);
    static function weightdvARB(size:Int, weights:DataPointer):Void return ExtensionsNative.weightdvARB(size, weights);
    static function weightfvARB(size:Int, weights:DataPointer):Void return ExtensionsNative.weightfvARB(size, weights);
    static function weightivARB(size:Int, weights:DataPointer):Void return ExtensionsNative.weightivARB(size, weights);
    static function weightsvARB(size:Int, weights:DataPointer):Void return ExtensionsNative.weightsvARB(size, weights);
    static function weightubvARB(size:Int, weights:DataPointer):Void return ExtensionsNative.weightubvARB(size, weights);
    static function weightuivARB(size:Int, weights:DataPointer):Void return ExtensionsNative.weightuivARB(size, weights);
    static function weightusvARB(size:Int, weights:DataPointer):Void return ExtensionsNative.weightusvARB(size, weights);
    static function windowPos2d(x:DataPointer, y:DataPointer):Void return ExtensionsNative.windowPos2d(x, y);
    static function windowPos2dARB(x:DataPointer, y:DataPointer):Void return ExtensionsNative.windowPos2dARB(x, y);
    static function windowPos2dMESA(x:DataPointer, y:DataPointer):Void return ExtensionsNative.windowPos2dMESA(x, y);
    static function windowPos2dv(v:DataPointer):Void return ExtensionsNative.windowPos2dv(v);
    static function windowPos2dvARB(v:DataPointer):Void return ExtensionsNative.windowPos2dvARB(v);
    static function windowPos2dvMESA(v:DataPointer):Void return ExtensionsNative.windowPos2dvMESA(v);
    static function windowPos2f(x:Float, y:Float):Void return ExtensionsNative.windowPos2f(x, y);
    static function windowPos2fARB(x:Float, y:Float):Void return ExtensionsNative.windowPos2fARB(x, y);
    static function windowPos2fMESA(x:Float, y:Float):Void return ExtensionsNative.windowPos2fMESA(x, y);
    static function windowPos2fv(v:DataPointer):Void return ExtensionsNative.windowPos2fv(v);
    static function windowPos2fvARB(v:DataPointer):Void return ExtensionsNative.windowPos2fvARB(v);
    static function windowPos2fvMESA(v:DataPointer):Void return ExtensionsNative.windowPos2fvMESA(v);
    static function windowPos2i(x:Int, y:Int):Void return ExtensionsNative.windowPos2i(x, y);
    static function windowPos2iARB(x:Int, y:Int):Void return ExtensionsNative.windowPos2iARB(x, y);
    static function windowPos2iMESA(x:Int, y:Int):Void return ExtensionsNative.windowPos2iMESA(x, y);
    static function windowPos2iv(v:DataPointer):Void return ExtensionsNative.windowPos2iv(v);
    static function windowPos2ivARB(v:DataPointer):Void return ExtensionsNative.windowPos2ivARB(v);
    static function windowPos2ivMESA(v:DataPointer):Void return ExtensionsNative.windowPos2ivMESA(v);
    static function windowPos2s(x:Int, y:Int):Void return ExtensionsNative.windowPos2s(x, y);
    static function windowPos2sARB(x:Int, y:Int):Void return ExtensionsNative.windowPos2sARB(x, y);
    static function windowPos2sMESA(x:Int, y:Int):Void return ExtensionsNative.windowPos2sMESA(x, y);
    static function windowPos2sv(v:DataPointer):Void return ExtensionsNative.windowPos2sv(v);
    static function windowPos2svARB(v:DataPointer):Void return ExtensionsNative.windowPos2svARB(v);
    static function windowPos2svMESA(v:DataPointer):Void return ExtensionsNative.windowPos2svMESA(v);
    static function windowPos3d(x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.windowPos3d(x, y, z);
    static function windowPos3dARB(x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.windowPos3dARB(x, y, z);
    static function windowPos3dMESA(x:DataPointer, y:DataPointer, z:DataPointer):Void return ExtensionsNative.windowPos3dMESA(x, y, z);
    static function windowPos3dv(v:DataPointer):Void return ExtensionsNative.windowPos3dv(v);
    static function windowPos3dvARB(v:DataPointer):Void return ExtensionsNative.windowPos3dvARB(v);
    static function windowPos3dvMESA(v:DataPointer):Void return ExtensionsNative.windowPos3dvMESA(v);
    static function windowPos3f(x:Float, y:Float, z:Float):Void return ExtensionsNative.windowPos3f(x, y, z);
    static function windowPos3fARB(x:Float, y:Float, z:Float):Void return ExtensionsNative.windowPos3fARB(x, y, z);
    static function windowPos3fMESA(x:Float, y:Float, z:Float):Void return ExtensionsNative.windowPos3fMESA(x, y, z);
    static function windowPos3fv(v:DataPointer):Void return ExtensionsNative.windowPos3fv(v);
    static function windowPos3fvARB(v:DataPointer):Void return ExtensionsNative.windowPos3fvARB(v);
    static function windowPos3fvMESA(v:DataPointer):Void return ExtensionsNative.windowPos3fvMESA(v);
    static function windowPos3i(x:Int, y:Int, z:Int):Void return ExtensionsNative.windowPos3i(x, y, z);
    static function windowPos3iARB(x:Int, y:Int, z:Int):Void return ExtensionsNative.windowPos3iARB(x, y, z);
    static function windowPos3iMESA(x:Int, y:Int, z:Int):Void return ExtensionsNative.windowPos3iMESA(x, y, z);
    static function windowPos3iv(v:DataPointer):Void return ExtensionsNative.windowPos3iv(v);
    static function windowPos3ivARB(v:DataPointer):Void return ExtensionsNative.windowPos3ivARB(v);
    static function windowPos3ivMESA(v:DataPointer):Void return ExtensionsNative.windowPos3ivMESA(v);
    static function windowPos3s(x:Int, y:Int, z:Int):Void return ExtensionsNative.windowPos3s(x, y, z);
    static function windowPos3sARB(x:Int, y:Int, z:Int):Void return ExtensionsNative.windowPos3sARB(x, y, z);
    static function windowPos3sMESA(x:Int, y:Int, z:Int):Void return ExtensionsNative.windowPos3sMESA(x, y, z);
    static function windowPos3sv(v:DataPointer):Void return ExtensionsNative.windowPos3sv(v);
    static function windowPos3svARB(v:DataPointer):Void return ExtensionsNative.windowPos3svARB(v);
    static function windowPos3svMESA(v:DataPointer):Void return ExtensionsNative.windowPos3svMESA(v);
    static function windowPos4dMESA(x:DataPointer, y:DataPointer, z:DataPointer, w:DataPointer):Void return ExtensionsNative.windowPos4dMESA(x, y, z, w);
    static function windowPos4dvMESA(v:DataPointer):Void return ExtensionsNative.windowPos4dvMESA(v);
    static function windowPos4fMESA(x:Float, y:Float, z:Float, w:Float):Void return ExtensionsNative.windowPos4fMESA(x, y, z, w);
    static function windowPos4fvMESA(v:DataPointer):Void return ExtensionsNative.windowPos4fvMESA(v);
    static function windowPos4iMESA(x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.windowPos4iMESA(x, y, z, w);
    static function windowPos4ivMESA(v:DataPointer):Void return ExtensionsNative.windowPos4ivMESA(v);
    static function windowPos4sMESA(x:Int, y:Int, z:Int, w:Int):Void return ExtensionsNative.windowPos4sMESA(x, y, z, w);
    static function windowPos4svMESA(v:DataPointer):Void return ExtensionsNative.windowPos4svMESA(v);
    static function windowRectanglesEXT(mode:Int, count:Int, box:DataPointer):Void return ExtensionsNative.windowRectanglesEXT(mode, count, box);
    static function writeMaskEXT(res:Int, in_:Int, outX:Int, outY:Int, outZ:Int, outW:Int):Void return ExtensionsNative.writeMaskEXT(res, in_, outX, outY, outZ, outW);
    static function drawVkImageNV(vkImage:Int, sampler:Int, x0:Float, y0:Float, x1:Float, y1:Float, z:Float, s0:Float, t0:Float, s1:Float, t1:Float):Void return ExtensionsNative.drawVkImageNV(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    static function getVkProcAddrNV(name:String):Dynamic return ExtensionsNative.getVkProcAddrNV(name);
    static function waitVkSemaphoreNV(vkSemaphore:Int):Void return ExtensionsNative.waitVkSemaphoreNV(vkSemaphore);
    static function signalVkSemaphoreNV(vkSemaphore:Int):Void return ExtensionsNative.signalVkSemaphoreNV(vkSemaphore);
    static function signalVkFenceNV(vkFence:Int):Void return ExtensionsNative.signalVkFenceNV(vkFence);
    static function framebufferParameteriMESA(target:Int, pname:Int, param:Int):Void return ExtensionsNative.framebufferParameteriMESA(target, pname, param);
    static function getFramebufferParameterivMESA(target:Int, pname:Int, params:DataPointer):Void return ExtensionsNative.getFramebufferParameterivMESA(target, pname, params);
}
#end